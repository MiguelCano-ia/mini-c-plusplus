Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> func_decl
Rule 5     decl -> var_decl
Rule 6     func_decl -> type_spec IDENT ( param_list ) compound_stmt
Rule 7     param_list -> param_list , param
Rule 8     param_list -> VOID
Rule 9     param_list -> param_list
Rule 10    param -> type_spec IDENT [ INTLIT ]
Rule 11    param -> type_spec IDENT
Rule 12    compound_stmt -> { local_decls stmt_list }
Rule 13    local_decls -> local_decls var_decl
Rule 14    local_decls -> empty
Rule 15    local_decls -> local_decls
Rule 16    stmt_list -> stmt
Rule 17    stmt_list -> stmt_list stmt
Rule 18    stmt_list -> empty
Rule 19    stmt_list -> stmt_list
Rule 20    stmt -> public_stmt
Rule 21    stmt -> private_stmt
Rule 22    stmt -> this_stmt
Rule 23    stmt -> new_stmt
Rule 24    stmt -> print_stmt
Rule 25    stmt -> continue_stmt
Rule 26    stmt -> break_stmt
Rule 27    stmt -> while_stmt
Rule 28    stmt -> return_stmt
Rule 29    stmt -> if_stmt
Rule 30    stmt -> compound_stmt
Rule 31    stmt -> expr_stmt
Rule 32    expr_stmt -> expr ;
Rule 33    if_stmt -> IF ( expr ) { stmt } ELSE { stmt }
Rule 34    if_stmt -> IF ( expr ) stmt ELSE { stmt }
Rule 35    if_stmt -> IF ( expr ) { stmt } ELSE stmt
Rule 36    if_stmt -> IF ( expr ) stmt ELSE stmt
Rule 37    if_stmt -> IF ( expr ) { stmt }
Rule 38    if_stmt -> IF ( expr ) stmt
Rule 39    private_stmt -> PRIVATE : stmt
Rule 40    public_stmt -> PUBLIC : stmt
Rule 41    return_stmt -> RETURN expr ;
Rule 42    return_stmt -> RETURN ;
Rule 43    while_stmt -> WHILE ( stmt ) expr
Rule 44    break_stmt -> BREAK ;
Rule 45    continue_stmt -> CONTINUE ;
Rule 46    new_stmt -> IDENT = NEW IDENT ( args_list ) ;
Rule 47    args_list -> args_list , expr
Rule 48    args_list -> empty
Rule 49    args_list -> args_list
Rule 50    print_stmt -> PRINTF ( expr ) ;
Rule 51    this_stmt -> THIS ;
Rule 52    var_decl -> type_spec IDENT [ INTLIT ] ;
Rule 53    var_decl -> type_spec IDENT = expr ;
Rule 54    var_decl -> type_spec IDENT ;
Rule 55    type_spec -> STRING
Rule 56    type_spec -> BOOL
Rule 57    type_spec -> FLOAT
Rule 58    type_spec -> INT
Rule 59    type_spec -> VOID
Rule 60    expr -> IDENT . SIZE
Rule 61    expr -> ( expr )
Rule 62    expr -> + expr  [precedence=right, level=9]
Rule 63    expr -> ! expr  [precedence=right, level=9]
Rule 64    expr -> - expr  [precedence=right, level=9]
Rule 65    expr -> expr % expr  [precedence=left, level=8]
Rule 66    expr -> expr / expr  [precedence=left, level=8]
Rule 67    expr -> expr * expr  [precedence=left, level=8]
Rule 68    expr -> expr - expr  [precedence=left, level=7]
Rule 69    expr -> expr + expr  [precedence=left, level=7]
Rule 70    expr -> expr GE expr  [precedence=left, level=6]
Rule 71    expr -> expr GT expr  [precedence=left, level=6]
Rule 72    expr -> expr LE expr  [precedence=left, level=6]
Rule 73    expr -> expr LT expr  [precedence=left, level=6]
Rule 74    expr -> expr NE expr  [precedence=left, level=5]
Rule 75    expr -> expr EQ expr  [precedence=left, level=5]
Rule 76    expr -> expr AND expr  [precedence=left, level=4]
Rule 77    expr -> expr OR expr  [precedence=left, level=3]
Rule 78    expr -> IDENT
Rule 79    expr -> IDENT ( args_list )
Rule 80    expr -> IDENT [ expr ]
Rule 81    expr -> IDENT [ expr ] = expr  [precedence=left, level=2]
Rule 82    expr -> IDENT = expr  [precedence=left, level=2]
Rule 83    expr -> STRINGLIT
Rule 84    expr -> BOOLIT
Rule 85    expr -> FLOATLIT
Rule 86    expr -> INTLIT
Rule 87    empty -> <empty>

Unused terminals:

    TRUE
    INCREMENT
    FALSE
    DECREMENT
    SUPER
    NOT
    CLASS

Terminals, with rules where they appear:

!                    : 63
%                    : 65
(                    : 6 33 34 35 36 37 38 43 46 50 61 79
)                    : 6 33 34 35 36 37 38 43 46 50 61 79
*                    : 67
+                    : 62 69
,                    : 7 47
-                    : 64 68
.                    : 60
/                    : 66
:                    : 39 40
;                    : 32 41 42 44 45 46 50 51 52 53 54
=                    : 46 53 81 82
AND                  : 76
BOOL                 : 56
BOOLIT               : 84
BREAK                : 44
CLASS                : 
CONTINUE             : 45
DECREMENT            : 
ELSE                 : 33 34 35 36
EQ                   : 75
FALSE                : 
FLOAT                : 57
FLOATLIT             : 85
GE                   : 70
GT                   : 71
IDENT                : 6 10 11 46 46 52 53 54 60 78 79 80 81 82
IF                   : 33 34 35 36 37 38
INCREMENT            : 
INT                  : 58
INTLIT               : 10 52 86
LE                   : 72
LT                   : 73
NE                   : 74
NEW                  : 46
NOT                  : 
OR                   : 77
PRINTF               : 50
PRIVATE              : 39
PUBLIC               : 40
RETURN               : 41 42
SIZE                 : 60
STRING               : 55
STRINGLIT            : 83
SUPER                : 
THIS                 : 51
TRUE                 : 
VOID                 : 8 59
WHILE                : 43
[                    : 10 52 80 81
]                    : 10 52 80 81
error                : 
{                    : 12 33 33 34 35 37
}                    : 12 33 33 34 35 37

Nonterminals, with rules where they appear:

args_list            : 46 47 49 79
break_stmt           : 26
compound_stmt        : 6 30
continue_stmt        : 25
decl                 : 2 3
decl_list            : 1 3
empty                : 14 18 48
expr                 : 32 33 34 35 36 37 38 41 43 47 50 53 61 62 63 64 65 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 74 74 75 75 76 76 77 77 80 81 81 82
expr_stmt            : 31
func_decl            : 4
if_stmt              : 29
local_decls          : 12 13 15
new_stmt             : 23
param                : 7
param_list           : 6 7 9
print_stmt           : 24
private_stmt         : 21
program              : 0
public_stmt          : 20
return_stmt          : 28
stmt                 : 16 17 33 33 34 34 35 35 36 36 37 38 39 40 43
stmt_list            : 12 17 19
this_stmt            : 22
type_spec            : 6 10 11 52 53 54
var_decl             : 5 13
while_stmt           : 27


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . func_decl
    (5) decl -> . var_decl
    (6) func_decl -> . type_spec IDENT ( param_list ) compound_stmt
    (52) var_decl -> . type_spec IDENT [ INTLIT ] ;
    (53) var_decl -> . type_spec IDENT = expr ;
    (54) var_decl -> . type_spec IDENT ;
    (55) type_spec -> . STRING
    (56) type_spec -> . BOOL
    (57) type_spec -> . FLOAT
    (58) type_spec -> . INT
    (59) type_spec -> . VOID
    STRING          shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    VOID            shift and go to state 11

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    func_decl                      shift and go to state 4
    var_decl                       shift and go to state 5
    type_spec                      shift and go to state 6

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . func_decl
    (5) decl -> . var_decl
    (6) func_decl -> . type_spec IDENT ( param_list ) compound_stmt
    (52) var_decl -> . type_spec IDENT [ INTLIT ] ;
    (53) var_decl -> . type_spec IDENT = expr ;
    (54) var_decl -> . type_spec IDENT ;
    (55) type_spec -> . STRING
    (56) type_spec -> . BOOL
    (57) type_spec -> . FLOAT
    (58) type_spec -> . INT
    (59) type_spec -> . VOID
    $end            reduce using rule 1 (program -> decl_list .)
    STRING          shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    VOID            shift and go to state 11

    decl                           shift and go to state 12
    func_decl                      shift and go to state 4
    var_decl                       shift and go to state 5
    type_spec                      shift and go to state 6

state 3

    (2) decl_list -> decl .
    STRING          reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> func_decl .
    STRING          reduce using rule 4 (decl -> func_decl .)
    BOOL            reduce using rule 4 (decl -> func_decl .)
    FLOAT           reduce using rule 4 (decl -> func_decl .)
    INT             reduce using rule 4 (decl -> func_decl .)
    VOID            reduce using rule 4 (decl -> func_decl .)
    $end            reduce using rule 4 (decl -> func_decl .)


state 5

    (5) decl -> var_decl .
    STRING          reduce using rule 5 (decl -> var_decl .)
    BOOL            reduce using rule 5 (decl -> var_decl .)
    FLOAT           reduce using rule 5 (decl -> var_decl .)
    INT             reduce using rule 5 (decl -> var_decl .)
    VOID            reduce using rule 5 (decl -> var_decl .)
    $end            reduce using rule 5 (decl -> var_decl .)


state 6

    (6) func_decl -> type_spec . IDENT ( param_list ) compound_stmt
    (52) var_decl -> type_spec . IDENT [ INTLIT ] ;
    (53) var_decl -> type_spec . IDENT = expr ;
    (54) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 13


state 7

    (55) type_spec -> STRING .
    IDENT           reduce using rule 55 (type_spec -> STRING .)


state 8

    (56) type_spec -> BOOL .
    IDENT           reduce using rule 56 (type_spec -> BOOL .)


state 9

    (57) type_spec -> FLOAT .
    IDENT           reduce using rule 57 (type_spec -> FLOAT .)


state 10

    (58) type_spec -> INT .
    IDENT           reduce using rule 58 (type_spec -> INT .)


state 11

    (59) type_spec -> VOID .
    IDENT           reduce using rule 59 (type_spec -> VOID .)


state 12

    (3) decl_list -> decl_list decl .
    STRING          reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 13

    (6) func_decl -> type_spec IDENT . ( param_list ) compound_stmt
    (52) var_decl -> type_spec IDENT . [ INTLIT ] ;
    (53) var_decl -> type_spec IDENT . = expr ;
    (54) var_decl -> type_spec IDENT . ;
    (               shift and go to state 14
    [               shift and go to state 15
    =               shift and go to state 17
    ;               shift and go to state 16


state 14

    (6) func_decl -> type_spec IDENT ( . param_list ) compound_stmt
    (7) param_list -> . param_list , param
    (8) param_list -> . VOID
    (9) param_list -> . param_list
    VOID            shift and go to state 19

    param_list                     shift and go to state 18

state 15

    (52) var_decl -> type_spec IDENT [ . INTLIT ] ;
    INTLIT          shift and go to state 20


state 16

    (54) var_decl -> type_spec IDENT ; .
    STRING          reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    PUBLIC          reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    PRIVATE         reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    THIS            reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    IDENT           reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    PRINTF          reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    CONTINUE        reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    IF              reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    {               reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    (               reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    +               reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    !               reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    -               reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    STRINGLIT       reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    BOOLIT          reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    FLOATLIT        reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    INTLIT          reduce using rule 54 (var_decl -> type_spec IDENT ; .)
    }               reduce using rule 54 (var_decl -> type_spec IDENT ; .)


state 17

    (53) var_decl -> type_spec IDENT = . expr ;
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 22

state 18

    (6) func_decl -> type_spec IDENT ( param_list . ) compound_stmt
    (7) param_list -> param_list . , param
    (9) param_list -> param_list .
  ! shift/reduce conflict for ) resolved as shift
  ! shift/reduce conflict for , resolved as shift
    )               shift and go to state 31
    ,               shift and go to state 32


state 19

    (8) param_list -> VOID .
    )               reduce using rule 8 (param_list -> VOID .)
    ,               reduce using rule 8 (param_list -> VOID .)


state 20

    (52) var_decl -> type_spec IDENT [ INTLIT . ] ;
    ]               shift and go to state 33


state 21

    (60) expr -> IDENT . . SIZE
    (78) expr -> IDENT .
    (79) expr -> IDENT . ( args_list )
    (80) expr -> IDENT . [ expr ]
    (81) expr -> IDENT . [ expr ] = expr
    (82) expr -> IDENT . = expr
  ! shift/reduce conflict for ( resolved as shift
    .               shift and go to state 34
    ;               reduce using rule 78 (expr -> IDENT .)
    %               reduce using rule 78 (expr -> IDENT .)
    /               reduce using rule 78 (expr -> IDENT .)
    *               reduce using rule 78 (expr -> IDENT .)
    -               reduce using rule 78 (expr -> IDENT .)
    +               reduce using rule 78 (expr -> IDENT .)
    GE              reduce using rule 78 (expr -> IDENT .)
    GT              reduce using rule 78 (expr -> IDENT .)
    LE              reduce using rule 78 (expr -> IDENT .)
    LT              reduce using rule 78 (expr -> IDENT .)
    NE              reduce using rule 78 (expr -> IDENT .)
    EQ              reduce using rule 78 (expr -> IDENT .)
    AND             reduce using rule 78 (expr -> IDENT .)
    OR              reduce using rule 78 (expr -> IDENT .)
    )               reduce using rule 78 (expr -> IDENT .)
    ]               reduce using rule 78 (expr -> IDENT .)
    ,               reduce using rule 78 (expr -> IDENT .)
    }               reduce using rule 78 (expr -> IDENT .)
    PUBLIC          reduce using rule 78 (expr -> IDENT .)
    PRIVATE         reduce using rule 78 (expr -> IDENT .)
    THIS            reduce using rule 78 (expr -> IDENT .)
    IDENT           reduce using rule 78 (expr -> IDENT .)
    PRINTF          reduce using rule 78 (expr -> IDENT .)
    CONTINUE        reduce using rule 78 (expr -> IDENT .)
    BREAK           reduce using rule 78 (expr -> IDENT .)
    WHILE           reduce using rule 78 (expr -> IDENT .)
    RETURN          reduce using rule 78 (expr -> IDENT .)
    IF              reduce using rule 78 (expr -> IDENT .)
    {               reduce using rule 78 (expr -> IDENT .)
    !               reduce using rule 78 (expr -> IDENT .)
    STRINGLIT       reduce using rule 78 (expr -> IDENT .)
    BOOLIT          reduce using rule 78 (expr -> IDENT .)
    FLOATLIT        reduce using rule 78 (expr -> IDENT .)
    INTLIT          reduce using rule 78 (expr -> IDENT .)
    ELSE            reduce using rule 78 (expr -> IDENT .)
    (               shift and go to state 35
    [               shift and go to state 36
    =               shift and go to state 37


state 22

    (53) var_decl -> type_spec IDENT = expr . ;
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               shift and go to state 38
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47
    NE              shift and go to state 48
    EQ              shift and go to state 49
    AND             shift and go to state 50
    OR              shift and go to state 51


state 23

    (61) expr -> ( . expr )
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 52

state 24

    (62) expr -> + . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 53

state 25

    (63) expr -> ! . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 54

state 26

    (64) expr -> - . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 55

state 27

    (83) expr -> STRINGLIT .
    ;               reduce using rule 83 (expr -> STRINGLIT .)
    %               reduce using rule 83 (expr -> STRINGLIT .)
    /               reduce using rule 83 (expr -> STRINGLIT .)
    *               reduce using rule 83 (expr -> STRINGLIT .)
    -               reduce using rule 83 (expr -> STRINGLIT .)
    +               reduce using rule 83 (expr -> STRINGLIT .)
    GE              reduce using rule 83 (expr -> STRINGLIT .)
    GT              reduce using rule 83 (expr -> STRINGLIT .)
    LE              reduce using rule 83 (expr -> STRINGLIT .)
    LT              reduce using rule 83 (expr -> STRINGLIT .)
    NE              reduce using rule 83 (expr -> STRINGLIT .)
    EQ              reduce using rule 83 (expr -> STRINGLIT .)
    AND             reduce using rule 83 (expr -> STRINGLIT .)
    OR              reduce using rule 83 (expr -> STRINGLIT .)
    )               reduce using rule 83 (expr -> STRINGLIT .)
    ]               reduce using rule 83 (expr -> STRINGLIT .)
    ,               reduce using rule 83 (expr -> STRINGLIT .)
    }               reduce using rule 83 (expr -> STRINGLIT .)
    PUBLIC          reduce using rule 83 (expr -> STRINGLIT .)
    PRIVATE         reduce using rule 83 (expr -> STRINGLIT .)
    THIS            reduce using rule 83 (expr -> STRINGLIT .)
    IDENT           reduce using rule 83 (expr -> STRINGLIT .)
    PRINTF          reduce using rule 83 (expr -> STRINGLIT .)
    CONTINUE        reduce using rule 83 (expr -> STRINGLIT .)
    BREAK           reduce using rule 83 (expr -> STRINGLIT .)
    WHILE           reduce using rule 83 (expr -> STRINGLIT .)
    RETURN          reduce using rule 83 (expr -> STRINGLIT .)
    IF              reduce using rule 83 (expr -> STRINGLIT .)
    {               reduce using rule 83 (expr -> STRINGLIT .)
    (               reduce using rule 83 (expr -> STRINGLIT .)
    !               reduce using rule 83 (expr -> STRINGLIT .)
    STRINGLIT       reduce using rule 83 (expr -> STRINGLIT .)
    BOOLIT          reduce using rule 83 (expr -> STRINGLIT .)
    FLOATLIT        reduce using rule 83 (expr -> STRINGLIT .)
    INTLIT          reduce using rule 83 (expr -> STRINGLIT .)
    ELSE            reduce using rule 83 (expr -> STRINGLIT .)


state 28

    (84) expr -> BOOLIT .
    ;               reduce using rule 84 (expr -> BOOLIT .)
    %               reduce using rule 84 (expr -> BOOLIT .)
    /               reduce using rule 84 (expr -> BOOLIT .)
    *               reduce using rule 84 (expr -> BOOLIT .)
    -               reduce using rule 84 (expr -> BOOLIT .)
    +               reduce using rule 84 (expr -> BOOLIT .)
    GE              reduce using rule 84 (expr -> BOOLIT .)
    GT              reduce using rule 84 (expr -> BOOLIT .)
    LE              reduce using rule 84 (expr -> BOOLIT .)
    LT              reduce using rule 84 (expr -> BOOLIT .)
    NE              reduce using rule 84 (expr -> BOOLIT .)
    EQ              reduce using rule 84 (expr -> BOOLIT .)
    AND             reduce using rule 84 (expr -> BOOLIT .)
    OR              reduce using rule 84 (expr -> BOOLIT .)
    )               reduce using rule 84 (expr -> BOOLIT .)
    ]               reduce using rule 84 (expr -> BOOLIT .)
    ,               reduce using rule 84 (expr -> BOOLIT .)
    }               reduce using rule 84 (expr -> BOOLIT .)
    PUBLIC          reduce using rule 84 (expr -> BOOLIT .)
    PRIVATE         reduce using rule 84 (expr -> BOOLIT .)
    THIS            reduce using rule 84 (expr -> BOOLIT .)
    IDENT           reduce using rule 84 (expr -> BOOLIT .)
    PRINTF          reduce using rule 84 (expr -> BOOLIT .)
    CONTINUE        reduce using rule 84 (expr -> BOOLIT .)
    BREAK           reduce using rule 84 (expr -> BOOLIT .)
    WHILE           reduce using rule 84 (expr -> BOOLIT .)
    RETURN          reduce using rule 84 (expr -> BOOLIT .)
    IF              reduce using rule 84 (expr -> BOOLIT .)
    {               reduce using rule 84 (expr -> BOOLIT .)
    (               reduce using rule 84 (expr -> BOOLIT .)
    !               reduce using rule 84 (expr -> BOOLIT .)
    STRINGLIT       reduce using rule 84 (expr -> BOOLIT .)
    BOOLIT          reduce using rule 84 (expr -> BOOLIT .)
    FLOATLIT        reduce using rule 84 (expr -> BOOLIT .)
    INTLIT          reduce using rule 84 (expr -> BOOLIT .)
    ELSE            reduce using rule 84 (expr -> BOOLIT .)


state 29

    (85) expr -> FLOATLIT .
    ;               reduce using rule 85 (expr -> FLOATLIT .)
    %               reduce using rule 85 (expr -> FLOATLIT .)
    /               reduce using rule 85 (expr -> FLOATLIT .)
    *               reduce using rule 85 (expr -> FLOATLIT .)
    -               reduce using rule 85 (expr -> FLOATLIT .)
    +               reduce using rule 85 (expr -> FLOATLIT .)
    GE              reduce using rule 85 (expr -> FLOATLIT .)
    GT              reduce using rule 85 (expr -> FLOATLIT .)
    LE              reduce using rule 85 (expr -> FLOATLIT .)
    LT              reduce using rule 85 (expr -> FLOATLIT .)
    NE              reduce using rule 85 (expr -> FLOATLIT .)
    EQ              reduce using rule 85 (expr -> FLOATLIT .)
    AND             reduce using rule 85 (expr -> FLOATLIT .)
    OR              reduce using rule 85 (expr -> FLOATLIT .)
    )               reduce using rule 85 (expr -> FLOATLIT .)
    ]               reduce using rule 85 (expr -> FLOATLIT .)
    ,               reduce using rule 85 (expr -> FLOATLIT .)
    }               reduce using rule 85 (expr -> FLOATLIT .)
    PUBLIC          reduce using rule 85 (expr -> FLOATLIT .)
    PRIVATE         reduce using rule 85 (expr -> FLOATLIT .)
    THIS            reduce using rule 85 (expr -> FLOATLIT .)
    IDENT           reduce using rule 85 (expr -> FLOATLIT .)
    PRINTF          reduce using rule 85 (expr -> FLOATLIT .)
    CONTINUE        reduce using rule 85 (expr -> FLOATLIT .)
    BREAK           reduce using rule 85 (expr -> FLOATLIT .)
    WHILE           reduce using rule 85 (expr -> FLOATLIT .)
    RETURN          reduce using rule 85 (expr -> FLOATLIT .)
    IF              reduce using rule 85 (expr -> FLOATLIT .)
    {               reduce using rule 85 (expr -> FLOATLIT .)
    (               reduce using rule 85 (expr -> FLOATLIT .)
    !               reduce using rule 85 (expr -> FLOATLIT .)
    STRINGLIT       reduce using rule 85 (expr -> FLOATLIT .)
    BOOLIT          reduce using rule 85 (expr -> FLOATLIT .)
    FLOATLIT        reduce using rule 85 (expr -> FLOATLIT .)
    INTLIT          reduce using rule 85 (expr -> FLOATLIT .)
    ELSE            reduce using rule 85 (expr -> FLOATLIT .)


state 30

    (86) expr -> INTLIT .
    ;               reduce using rule 86 (expr -> INTLIT .)
    %               reduce using rule 86 (expr -> INTLIT .)
    /               reduce using rule 86 (expr -> INTLIT .)
    *               reduce using rule 86 (expr -> INTLIT .)
    -               reduce using rule 86 (expr -> INTLIT .)
    +               reduce using rule 86 (expr -> INTLIT .)
    GE              reduce using rule 86 (expr -> INTLIT .)
    GT              reduce using rule 86 (expr -> INTLIT .)
    LE              reduce using rule 86 (expr -> INTLIT .)
    LT              reduce using rule 86 (expr -> INTLIT .)
    NE              reduce using rule 86 (expr -> INTLIT .)
    EQ              reduce using rule 86 (expr -> INTLIT .)
    AND             reduce using rule 86 (expr -> INTLIT .)
    OR              reduce using rule 86 (expr -> INTLIT .)
    )               reduce using rule 86 (expr -> INTLIT .)
    ]               reduce using rule 86 (expr -> INTLIT .)
    ,               reduce using rule 86 (expr -> INTLIT .)
    }               reduce using rule 86 (expr -> INTLIT .)
    PUBLIC          reduce using rule 86 (expr -> INTLIT .)
    PRIVATE         reduce using rule 86 (expr -> INTLIT .)
    THIS            reduce using rule 86 (expr -> INTLIT .)
    IDENT           reduce using rule 86 (expr -> INTLIT .)
    PRINTF          reduce using rule 86 (expr -> INTLIT .)
    CONTINUE        reduce using rule 86 (expr -> INTLIT .)
    BREAK           reduce using rule 86 (expr -> INTLIT .)
    WHILE           reduce using rule 86 (expr -> INTLIT .)
    RETURN          reduce using rule 86 (expr -> INTLIT .)
    IF              reduce using rule 86 (expr -> INTLIT .)
    {               reduce using rule 86 (expr -> INTLIT .)
    (               reduce using rule 86 (expr -> INTLIT .)
    !               reduce using rule 86 (expr -> INTLIT .)
    STRINGLIT       reduce using rule 86 (expr -> INTLIT .)
    BOOLIT          reduce using rule 86 (expr -> INTLIT .)
    FLOATLIT        reduce using rule 86 (expr -> INTLIT .)
    INTLIT          reduce using rule 86 (expr -> INTLIT .)
    ELSE            reduce using rule 86 (expr -> INTLIT .)


state 31

    (6) func_decl -> type_spec IDENT ( param_list ) . compound_stmt
    (12) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 57

    compound_stmt                  shift and go to state 56

state 32

    (7) param_list -> param_list , . param
    (10) param -> . type_spec IDENT [ INTLIT ]
    (11) param -> . type_spec IDENT
    (55) type_spec -> . STRING
    (56) type_spec -> . BOOL
    (57) type_spec -> . FLOAT
    (58) type_spec -> . INT
    (59) type_spec -> . VOID
    STRING          shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    VOID            shift and go to state 11

    param                          shift and go to state 58
    type_spec                      shift and go to state 59

state 33

    (52) var_decl -> type_spec IDENT [ INTLIT ] . ;
    ;               shift and go to state 60


state 34

    (60) expr -> IDENT . . SIZE
    SIZE            shift and go to state 61


state 35

    (79) expr -> IDENT ( . args_list )
    (47) args_list -> . args_list , expr
    (48) args_list -> . empty
    (49) args_list -> . args_list
    (87) empty -> .
    )               reduce using rule 87 (empty -> .)
    ,               reduce using rule 87 (empty -> .)

    args_list                      shift and go to state 62
    empty                          shift and go to state 63

state 36

    (80) expr -> IDENT [ . expr ]
    (81) expr -> IDENT [ . expr ] = expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 64

state 37

    (82) expr -> IDENT = . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 65

state 38

    (53) var_decl -> type_spec IDENT = expr ; .
    STRING          reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    BOOL            reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    FLOAT           reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    INT             reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    VOID            reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    $end            reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    PUBLIC          reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    PRIVATE         reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    THIS            reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    IDENT           reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    PRINTF          reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    CONTINUE        reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    BREAK           reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    WHILE           reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    RETURN          reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    IF              reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    {               reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    (               reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    +               reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    !               reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    -               reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    STRINGLIT       reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    BOOLIT          reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    FLOATLIT        reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    INTLIT          reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)
    }               reduce using rule 53 (var_decl -> type_spec IDENT = expr ; .)


state 39

    (65) expr -> expr % . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 66

state 40

    (66) expr -> expr / . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 67

state 41

    (67) expr -> expr * . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 68

state 42

    (68) expr -> expr - . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 69

state 43

    (69) expr -> expr + . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 70

state 44

    (70) expr -> expr GE . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 71

state 45

    (71) expr -> expr GT . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 72

state 46

    (72) expr -> expr LE . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 73

state 47

    (73) expr -> expr LT . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 74

state 48

    (74) expr -> expr NE . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 75

state 49

    (75) expr -> expr EQ . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 76

state 50

    (76) expr -> expr AND . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 77

state 51

    (77) expr -> expr OR . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 78

state 52

    (61) expr -> ( expr . )
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    )               shift and go to state 79
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47
    NE              shift and go to state 48
    EQ              shift and go to state 49
    AND             shift and go to state 50
    OR              shift and go to state 51


state 53

    (62) expr -> + expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 62 (expr -> + expr .)
    %               reduce using rule 62 (expr -> + expr .)
    /               reduce using rule 62 (expr -> + expr .)
    *               reduce using rule 62 (expr -> + expr .)
    -               reduce using rule 62 (expr -> + expr .)
    +               reduce using rule 62 (expr -> + expr .)
    GE              reduce using rule 62 (expr -> + expr .)
    GT              reduce using rule 62 (expr -> + expr .)
    LE              reduce using rule 62 (expr -> + expr .)
    LT              reduce using rule 62 (expr -> + expr .)
    NE              reduce using rule 62 (expr -> + expr .)
    EQ              reduce using rule 62 (expr -> + expr .)
    AND             reduce using rule 62 (expr -> + expr .)
    OR              reduce using rule 62 (expr -> + expr .)
    )               reduce using rule 62 (expr -> + expr .)
    ]               reduce using rule 62 (expr -> + expr .)
    ,               reduce using rule 62 (expr -> + expr .)
    }               reduce using rule 62 (expr -> + expr .)
    PUBLIC          reduce using rule 62 (expr -> + expr .)
    PRIVATE         reduce using rule 62 (expr -> + expr .)
    THIS            reduce using rule 62 (expr -> + expr .)
    IDENT           reduce using rule 62 (expr -> + expr .)
    PRINTF          reduce using rule 62 (expr -> + expr .)
    CONTINUE        reduce using rule 62 (expr -> + expr .)
    BREAK           reduce using rule 62 (expr -> + expr .)
    WHILE           reduce using rule 62 (expr -> + expr .)
    RETURN          reduce using rule 62 (expr -> + expr .)
    IF              reduce using rule 62 (expr -> + expr .)
    {               reduce using rule 62 (expr -> + expr .)
    (               reduce using rule 62 (expr -> + expr .)
    !               reduce using rule 62 (expr -> + expr .)
    STRINGLIT       reduce using rule 62 (expr -> + expr .)
    BOOLIT          reduce using rule 62 (expr -> + expr .)
    FLOATLIT        reduce using rule 62 (expr -> + expr .)
    INTLIT          reduce using rule 62 (expr -> + expr .)
    ELSE            reduce using rule 62 (expr -> + expr .)


state 54

    (63) expr -> ! expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 63 (expr -> ! expr .)
    %               reduce using rule 63 (expr -> ! expr .)
    /               reduce using rule 63 (expr -> ! expr .)
    *               reduce using rule 63 (expr -> ! expr .)
    -               reduce using rule 63 (expr -> ! expr .)
    +               reduce using rule 63 (expr -> ! expr .)
    GE              reduce using rule 63 (expr -> ! expr .)
    GT              reduce using rule 63 (expr -> ! expr .)
    LE              reduce using rule 63 (expr -> ! expr .)
    LT              reduce using rule 63 (expr -> ! expr .)
    NE              reduce using rule 63 (expr -> ! expr .)
    EQ              reduce using rule 63 (expr -> ! expr .)
    AND             reduce using rule 63 (expr -> ! expr .)
    OR              reduce using rule 63 (expr -> ! expr .)
    )               reduce using rule 63 (expr -> ! expr .)
    ]               reduce using rule 63 (expr -> ! expr .)
    ,               reduce using rule 63 (expr -> ! expr .)
    }               reduce using rule 63 (expr -> ! expr .)
    PUBLIC          reduce using rule 63 (expr -> ! expr .)
    PRIVATE         reduce using rule 63 (expr -> ! expr .)
    THIS            reduce using rule 63 (expr -> ! expr .)
    IDENT           reduce using rule 63 (expr -> ! expr .)
    PRINTF          reduce using rule 63 (expr -> ! expr .)
    CONTINUE        reduce using rule 63 (expr -> ! expr .)
    BREAK           reduce using rule 63 (expr -> ! expr .)
    WHILE           reduce using rule 63 (expr -> ! expr .)
    RETURN          reduce using rule 63 (expr -> ! expr .)
    IF              reduce using rule 63 (expr -> ! expr .)
    {               reduce using rule 63 (expr -> ! expr .)
    (               reduce using rule 63 (expr -> ! expr .)
    !               reduce using rule 63 (expr -> ! expr .)
    STRINGLIT       reduce using rule 63 (expr -> ! expr .)
    BOOLIT          reduce using rule 63 (expr -> ! expr .)
    FLOATLIT        reduce using rule 63 (expr -> ! expr .)
    INTLIT          reduce using rule 63 (expr -> ! expr .)
    ELSE            reduce using rule 63 (expr -> ! expr .)


state 55

    (64) expr -> - expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 64 (expr -> - expr .)
    %               reduce using rule 64 (expr -> - expr .)
    /               reduce using rule 64 (expr -> - expr .)
    *               reduce using rule 64 (expr -> - expr .)
    -               reduce using rule 64 (expr -> - expr .)
    +               reduce using rule 64 (expr -> - expr .)
    GE              reduce using rule 64 (expr -> - expr .)
    GT              reduce using rule 64 (expr -> - expr .)
    LE              reduce using rule 64 (expr -> - expr .)
    LT              reduce using rule 64 (expr -> - expr .)
    NE              reduce using rule 64 (expr -> - expr .)
    EQ              reduce using rule 64 (expr -> - expr .)
    AND             reduce using rule 64 (expr -> - expr .)
    OR              reduce using rule 64 (expr -> - expr .)
    )               reduce using rule 64 (expr -> - expr .)
    ]               reduce using rule 64 (expr -> - expr .)
    ,               reduce using rule 64 (expr -> - expr .)
    }               reduce using rule 64 (expr -> - expr .)
    PUBLIC          reduce using rule 64 (expr -> - expr .)
    PRIVATE         reduce using rule 64 (expr -> - expr .)
    THIS            reduce using rule 64 (expr -> - expr .)
    IDENT           reduce using rule 64 (expr -> - expr .)
    PRINTF          reduce using rule 64 (expr -> - expr .)
    CONTINUE        reduce using rule 64 (expr -> - expr .)
    BREAK           reduce using rule 64 (expr -> - expr .)
    WHILE           reduce using rule 64 (expr -> - expr .)
    RETURN          reduce using rule 64 (expr -> - expr .)
    IF              reduce using rule 64 (expr -> - expr .)
    {               reduce using rule 64 (expr -> - expr .)
    (               reduce using rule 64 (expr -> - expr .)
    !               reduce using rule 64 (expr -> - expr .)
    STRINGLIT       reduce using rule 64 (expr -> - expr .)
    BOOLIT          reduce using rule 64 (expr -> - expr .)
    FLOATLIT        reduce using rule 64 (expr -> - expr .)
    INTLIT          reduce using rule 64 (expr -> - expr .)
    ELSE            reduce using rule 64 (expr -> - expr .)


state 56

    (6) func_decl -> type_spec IDENT ( param_list ) compound_stmt .
    STRING          reduce using rule 6 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    BOOL            reduce using rule 6 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    FLOAT           reduce using rule 6 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    INT             reduce using rule 6 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    VOID            reduce using rule 6 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    $end            reduce using rule 6 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)


state 57

    (12) compound_stmt -> { . local_decls stmt_list }
    (13) local_decls -> . local_decls var_decl
    (14) local_decls -> . empty
    (15) local_decls -> . local_decls
    (87) empty -> .
    STRING          reduce using rule 87 (empty -> .)
    BOOL            reduce using rule 87 (empty -> .)
    FLOAT           reduce using rule 87 (empty -> .)
    INT             reduce using rule 87 (empty -> .)
    VOID            reduce using rule 87 (empty -> .)
    PUBLIC          reduce using rule 87 (empty -> .)
    PRIVATE         reduce using rule 87 (empty -> .)
    THIS            reduce using rule 87 (empty -> .)
    IDENT           reduce using rule 87 (empty -> .)
    PRINTF          reduce using rule 87 (empty -> .)
    CONTINUE        reduce using rule 87 (empty -> .)
    BREAK           reduce using rule 87 (empty -> .)
    WHILE           reduce using rule 87 (empty -> .)
    RETURN          reduce using rule 87 (empty -> .)
    IF              reduce using rule 87 (empty -> .)
    {               reduce using rule 87 (empty -> .)
    (               reduce using rule 87 (empty -> .)
    +               reduce using rule 87 (empty -> .)
    !               reduce using rule 87 (empty -> .)
    -               reduce using rule 87 (empty -> .)
    STRINGLIT       reduce using rule 87 (empty -> .)
    BOOLIT          reduce using rule 87 (empty -> .)
    FLOATLIT        reduce using rule 87 (empty -> .)
    INTLIT          reduce using rule 87 (empty -> .)
    }               reduce using rule 87 (empty -> .)

    local_decls                    shift and go to state 80
    empty                          shift and go to state 81

state 58

    (7) param_list -> param_list , param .
    )               reduce using rule 7 (param_list -> param_list , param .)
    ,               reduce using rule 7 (param_list -> param_list , param .)


state 59

    (10) param -> type_spec . IDENT [ INTLIT ]
    (11) param -> type_spec . IDENT
    IDENT           shift and go to state 82


state 60

    (52) var_decl -> type_spec IDENT [ INTLIT ] ; .
    STRING          reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    BOOL            reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    FLOAT           reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    INT             reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    VOID            reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    $end            reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    PUBLIC          reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    PRIVATE         reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    THIS            reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    IDENT           reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    PRINTF          reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    CONTINUE        reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    BREAK           reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    WHILE           reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    RETURN          reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    IF              reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    {               reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    (               reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    +               reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    !               reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    -               reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    STRINGLIT       reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    BOOLIT          reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    FLOATLIT        reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    INTLIT          reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)
    }               reduce using rule 52 (var_decl -> type_spec IDENT [ INTLIT ] ; .)


state 61

    (60) expr -> IDENT . SIZE .
    ;               reduce using rule 60 (expr -> IDENT . SIZE .)
    %               reduce using rule 60 (expr -> IDENT . SIZE .)
    /               reduce using rule 60 (expr -> IDENT . SIZE .)
    *               reduce using rule 60 (expr -> IDENT . SIZE .)
    -               reduce using rule 60 (expr -> IDENT . SIZE .)
    +               reduce using rule 60 (expr -> IDENT . SIZE .)
    GE              reduce using rule 60 (expr -> IDENT . SIZE .)
    GT              reduce using rule 60 (expr -> IDENT . SIZE .)
    LE              reduce using rule 60 (expr -> IDENT . SIZE .)
    LT              reduce using rule 60 (expr -> IDENT . SIZE .)
    NE              reduce using rule 60 (expr -> IDENT . SIZE .)
    EQ              reduce using rule 60 (expr -> IDENT . SIZE .)
    AND             reduce using rule 60 (expr -> IDENT . SIZE .)
    OR              reduce using rule 60 (expr -> IDENT . SIZE .)
    )               reduce using rule 60 (expr -> IDENT . SIZE .)
    ]               reduce using rule 60 (expr -> IDENT . SIZE .)
    ,               reduce using rule 60 (expr -> IDENT . SIZE .)
    }               reduce using rule 60 (expr -> IDENT . SIZE .)
    PUBLIC          reduce using rule 60 (expr -> IDENT . SIZE .)
    PRIVATE         reduce using rule 60 (expr -> IDENT . SIZE .)
    THIS            reduce using rule 60 (expr -> IDENT . SIZE .)
    IDENT           reduce using rule 60 (expr -> IDENT . SIZE .)
    PRINTF          reduce using rule 60 (expr -> IDENT . SIZE .)
    CONTINUE        reduce using rule 60 (expr -> IDENT . SIZE .)
    BREAK           reduce using rule 60 (expr -> IDENT . SIZE .)
    WHILE           reduce using rule 60 (expr -> IDENT . SIZE .)
    RETURN          reduce using rule 60 (expr -> IDENT . SIZE .)
    IF              reduce using rule 60 (expr -> IDENT . SIZE .)
    {               reduce using rule 60 (expr -> IDENT . SIZE .)
    (               reduce using rule 60 (expr -> IDENT . SIZE .)
    !               reduce using rule 60 (expr -> IDENT . SIZE .)
    STRINGLIT       reduce using rule 60 (expr -> IDENT . SIZE .)
    BOOLIT          reduce using rule 60 (expr -> IDENT . SIZE .)
    FLOATLIT        reduce using rule 60 (expr -> IDENT . SIZE .)
    INTLIT          reduce using rule 60 (expr -> IDENT . SIZE .)
    ELSE            reduce using rule 60 (expr -> IDENT . SIZE .)


state 62

    (79) expr -> IDENT ( args_list . )
    (47) args_list -> args_list . , expr
    (49) args_list -> args_list .
  ! shift/reduce conflict for ) resolved as shift
  ! shift/reduce conflict for , resolved as shift
    )               shift and go to state 83
    ,               shift and go to state 84


state 63

    (48) args_list -> empty .
    )               reduce using rule 48 (args_list -> empty .)
    ,               reduce using rule 48 (args_list -> empty .)


state 64

    (80) expr -> IDENT [ expr . ]
    (81) expr -> IDENT [ expr . ] = expr
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ]               shift and go to state 85
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47
    NE              shift and go to state 48
    EQ              shift and go to state 49
    AND             shift and go to state 50
    OR              shift and go to state 51


state 65

    (82) expr -> IDENT = expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 82 (expr -> IDENT = expr .)
    )               reduce using rule 82 (expr -> IDENT = expr .)
    ]               reduce using rule 82 (expr -> IDENT = expr .)
    ,               reduce using rule 82 (expr -> IDENT = expr .)
    }               reduce using rule 82 (expr -> IDENT = expr .)
    PUBLIC          reduce using rule 82 (expr -> IDENT = expr .)
    PRIVATE         reduce using rule 82 (expr -> IDENT = expr .)
    THIS            reduce using rule 82 (expr -> IDENT = expr .)
    IDENT           reduce using rule 82 (expr -> IDENT = expr .)
    PRINTF          reduce using rule 82 (expr -> IDENT = expr .)
    CONTINUE        reduce using rule 82 (expr -> IDENT = expr .)
    BREAK           reduce using rule 82 (expr -> IDENT = expr .)
    WHILE           reduce using rule 82 (expr -> IDENT = expr .)
    RETURN          reduce using rule 82 (expr -> IDENT = expr .)
    IF              reduce using rule 82 (expr -> IDENT = expr .)
    {               reduce using rule 82 (expr -> IDENT = expr .)
    (               reduce using rule 82 (expr -> IDENT = expr .)
    !               reduce using rule 82 (expr -> IDENT = expr .)
    STRINGLIT       reduce using rule 82 (expr -> IDENT = expr .)
    BOOLIT          reduce using rule 82 (expr -> IDENT = expr .)
    FLOATLIT        reduce using rule 82 (expr -> IDENT = expr .)
    INTLIT          reduce using rule 82 (expr -> IDENT = expr .)
    ELSE            reduce using rule 82 (expr -> IDENT = expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47
    NE              shift and go to state 48
    EQ              shift and go to state 49
    AND             shift and go to state 50
    OR              shift and go to state 51


state 66

    (65) expr -> expr % expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 65 (expr -> expr % expr .)
    %               reduce using rule 65 (expr -> expr % expr .)
    /               reduce using rule 65 (expr -> expr % expr .)
    *               reduce using rule 65 (expr -> expr % expr .)
    -               reduce using rule 65 (expr -> expr % expr .)
    +               reduce using rule 65 (expr -> expr % expr .)
    GE              reduce using rule 65 (expr -> expr % expr .)
    GT              reduce using rule 65 (expr -> expr % expr .)
    LE              reduce using rule 65 (expr -> expr % expr .)
    LT              reduce using rule 65 (expr -> expr % expr .)
    NE              reduce using rule 65 (expr -> expr % expr .)
    EQ              reduce using rule 65 (expr -> expr % expr .)
    AND             reduce using rule 65 (expr -> expr % expr .)
    OR              reduce using rule 65 (expr -> expr % expr .)
    )               reduce using rule 65 (expr -> expr % expr .)
    ]               reduce using rule 65 (expr -> expr % expr .)
    ,               reduce using rule 65 (expr -> expr % expr .)
    }               reduce using rule 65 (expr -> expr % expr .)
    PUBLIC          reduce using rule 65 (expr -> expr % expr .)
    PRIVATE         reduce using rule 65 (expr -> expr % expr .)
    THIS            reduce using rule 65 (expr -> expr % expr .)
    IDENT           reduce using rule 65 (expr -> expr % expr .)
    PRINTF          reduce using rule 65 (expr -> expr % expr .)
    CONTINUE        reduce using rule 65 (expr -> expr % expr .)
    BREAK           reduce using rule 65 (expr -> expr % expr .)
    WHILE           reduce using rule 65 (expr -> expr % expr .)
    RETURN          reduce using rule 65 (expr -> expr % expr .)
    IF              reduce using rule 65 (expr -> expr % expr .)
    {               reduce using rule 65 (expr -> expr % expr .)
    (               reduce using rule 65 (expr -> expr % expr .)
    !               reduce using rule 65 (expr -> expr % expr .)
    STRINGLIT       reduce using rule 65 (expr -> expr % expr .)
    BOOLIT          reduce using rule 65 (expr -> expr % expr .)
    FLOATLIT        reduce using rule 65 (expr -> expr % expr .)
    INTLIT          reduce using rule 65 (expr -> expr % expr .)
    ELSE            reduce using rule 65 (expr -> expr % expr .)


state 67

    (66) expr -> expr / expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 66 (expr -> expr / expr .)
    %               reduce using rule 66 (expr -> expr / expr .)
    /               reduce using rule 66 (expr -> expr / expr .)
    *               reduce using rule 66 (expr -> expr / expr .)
    -               reduce using rule 66 (expr -> expr / expr .)
    +               reduce using rule 66 (expr -> expr / expr .)
    GE              reduce using rule 66 (expr -> expr / expr .)
    GT              reduce using rule 66 (expr -> expr / expr .)
    LE              reduce using rule 66 (expr -> expr / expr .)
    LT              reduce using rule 66 (expr -> expr / expr .)
    NE              reduce using rule 66 (expr -> expr / expr .)
    EQ              reduce using rule 66 (expr -> expr / expr .)
    AND             reduce using rule 66 (expr -> expr / expr .)
    OR              reduce using rule 66 (expr -> expr / expr .)
    )               reduce using rule 66 (expr -> expr / expr .)
    ]               reduce using rule 66 (expr -> expr / expr .)
    ,               reduce using rule 66 (expr -> expr / expr .)
    }               reduce using rule 66 (expr -> expr / expr .)
    PUBLIC          reduce using rule 66 (expr -> expr / expr .)
    PRIVATE         reduce using rule 66 (expr -> expr / expr .)
    THIS            reduce using rule 66 (expr -> expr / expr .)
    IDENT           reduce using rule 66 (expr -> expr / expr .)
    PRINTF          reduce using rule 66 (expr -> expr / expr .)
    CONTINUE        reduce using rule 66 (expr -> expr / expr .)
    BREAK           reduce using rule 66 (expr -> expr / expr .)
    WHILE           reduce using rule 66 (expr -> expr / expr .)
    RETURN          reduce using rule 66 (expr -> expr / expr .)
    IF              reduce using rule 66 (expr -> expr / expr .)
    {               reduce using rule 66 (expr -> expr / expr .)
    (               reduce using rule 66 (expr -> expr / expr .)
    !               reduce using rule 66 (expr -> expr / expr .)
    STRINGLIT       reduce using rule 66 (expr -> expr / expr .)
    BOOLIT          reduce using rule 66 (expr -> expr / expr .)
    FLOATLIT        reduce using rule 66 (expr -> expr / expr .)
    INTLIT          reduce using rule 66 (expr -> expr / expr .)
    ELSE            reduce using rule 66 (expr -> expr / expr .)


state 68

    (67) expr -> expr * expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 67 (expr -> expr * expr .)
    %               reduce using rule 67 (expr -> expr * expr .)
    /               reduce using rule 67 (expr -> expr * expr .)
    *               reduce using rule 67 (expr -> expr * expr .)
    -               reduce using rule 67 (expr -> expr * expr .)
    +               reduce using rule 67 (expr -> expr * expr .)
    GE              reduce using rule 67 (expr -> expr * expr .)
    GT              reduce using rule 67 (expr -> expr * expr .)
    LE              reduce using rule 67 (expr -> expr * expr .)
    LT              reduce using rule 67 (expr -> expr * expr .)
    NE              reduce using rule 67 (expr -> expr * expr .)
    EQ              reduce using rule 67 (expr -> expr * expr .)
    AND             reduce using rule 67 (expr -> expr * expr .)
    OR              reduce using rule 67 (expr -> expr * expr .)
    )               reduce using rule 67 (expr -> expr * expr .)
    ]               reduce using rule 67 (expr -> expr * expr .)
    ,               reduce using rule 67 (expr -> expr * expr .)
    }               reduce using rule 67 (expr -> expr * expr .)
    PUBLIC          reduce using rule 67 (expr -> expr * expr .)
    PRIVATE         reduce using rule 67 (expr -> expr * expr .)
    THIS            reduce using rule 67 (expr -> expr * expr .)
    IDENT           reduce using rule 67 (expr -> expr * expr .)
    PRINTF          reduce using rule 67 (expr -> expr * expr .)
    CONTINUE        reduce using rule 67 (expr -> expr * expr .)
    BREAK           reduce using rule 67 (expr -> expr * expr .)
    WHILE           reduce using rule 67 (expr -> expr * expr .)
    RETURN          reduce using rule 67 (expr -> expr * expr .)
    IF              reduce using rule 67 (expr -> expr * expr .)
    {               reduce using rule 67 (expr -> expr * expr .)
    (               reduce using rule 67 (expr -> expr * expr .)
    !               reduce using rule 67 (expr -> expr * expr .)
    STRINGLIT       reduce using rule 67 (expr -> expr * expr .)
    BOOLIT          reduce using rule 67 (expr -> expr * expr .)
    FLOATLIT        reduce using rule 67 (expr -> expr * expr .)
    INTLIT          reduce using rule 67 (expr -> expr * expr .)
    ELSE            reduce using rule 67 (expr -> expr * expr .)


state 69

    (68) expr -> expr - expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 68 (expr -> expr - expr .)
    -               reduce using rule 68 (expr -> expr - expr .)
    +               reduce using rule 68 (expr -> expr - expr .)
    GE              reduce using rule 68 (expr -> expr - expr .)
    GT              reduce using rule 68 (expr -> expr - expr .)
    LE              reduce using rule 68 (expr -> expr - expr .)
    LT              reduce using rule 68 (expr -> expr - expr .)
    NE              reduce using rule 68 (expr -> expr - expr .)
    EQ              reduce using rule 68 (expr -> expr - expr .)
    AND             reduce using rule 68 (expr -> expr - expr .)
    OR              reduce using rule 68 (expr -> expr - expr .)
    )               reduce using rule 68 (expr -> expr - expr .)
    ]               reduce using rule 68 (expr -> expr - expr .)
    ,               reduce using rule 68 (expr -> expr - expr .)
    }               reduce using rule 68 (expr -> expr - expr .)
    PUBLIC          reduce using rule 68 (expr -> expr - expr .)
    PRIVATE         reduce using rule 68 (expr -> expr - expr .)
    THIS            reduce using rule 68 (expr -> expr - expr .)
    IDENT           reduce using rule 68 (expr -> expr - expr .)
    PRINTF          reduce using rule 68 (expr -> expr - expr .)
    CONTINUE        reduce using rule 68 (expr -> expr - expr .)
    BREAK           reduce using rule 68 (expr -> expr - expr .)
    WHILE           reduce using rule 68 (expr -> expr - expr .)
    RETURN          reduce using rule 68 (expr -> expr - expr .)
    IF              reduce using rule 68 (expr -> expr - expr .)
    {               reduce using rule 68 (expr -> expr - expr .)
    (               reduce using rule 68 (expr -> expr - expr .)
    !               reduce using rule 68 (expr -> expr - expr .)
    STRINGLIT       reduce using rule 68 (expr -> expr - expr .)
    BOOLIT          reduce using rule 68 (expr -> expr - expr .)
    FLOATLIT        reduce using rule 68 (expr -> expr - expr .)
    INTLIT          reduce using rule 68 (expr -> expr - expr .)
    ELSE            reduce using rule 68 (expr -> expr - expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41


state 70

    (69) expr -> expr + expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 69 (expr -> expr + expr .)
    -               reduce using rule 69 (expr -> expr + expr .)
    +               reduce using rule 69 (expr -> expr + expr .)
    GE              reduce using rule 69 (expr -> expr + expr .)
    GT              reduce using rule 69 (expr -> expr + expr .)
    LE              reduce using rule 69 (expr -> expr + expr .)
    LT              reduce using rule 69 (expr -> expr + expr .)
    NE              reduce using rule 69 (expr -> expr + expr .)
    EQ              reduce using rule 69 (expr -> expr + expr .)
    AND             reduce using rule 69 (expr -> expr + expr .)
    OR              reduce using rule 69 (expr -> expr + expr .)
    )               reduce using rule 69 (expr -> expr + expr .)
    ]               reduce using rule 69 (expr -> expr + expr .)
    ,               reduce using rule 69 (expr -> expr + expr .)
    }               reduce using rule 69 (expr -> expr + expr .)
    PUBLIC          reduce using rule 69 (expr -> expr + expr .)
    PRIVATE         reduce using rule 69 (expr -> expr + expr .)
    THIS            reduce using rule 69 (expr -> expr + expr .)
    IDENT           reduce using rule 69 (expr -> expr + expr .)
    PRINTF          reduce using rule 69 (expr -> expr + expr .)
    CONTINUE        reduce using rule 69 (expr -> expr + expr .)
    BREAK           reduce using rule 69 (expr -> expr + expr .)
    WHILE           reduce using rule 69 (expr -> expr + expr .)
    RETURN          reduce using rule 69 (expr -> expr + expr .)
    IF              reduce using rule 69 (expr -> expr + expr .)
    {               reduce using rule 69 (expr -> expr + expr .)
    (               reduce using rule 69 (expr -> expr + expr .)
    !               reduce using rule 69 (expr -> expr + expr .)
    STRINGLIT       reduce using rule 69 (expr -> expr + expr .)
    BOOLIT          reduce using rule 69 (expr -> expr + expr .)
    FLOATLIT        reduce using rule 69 (expr -> expr + expr .)
    INTLIT          reduce using rule 69 (expr -> expr + expr .)
    ELSE            reduce using rule 69 (expr -> expr + expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41


state 71

    (70) expr -> expr GE expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 70 (expr -> expr GE expr .)
    GE              reduce using rule 70 (expr -> expr GE expr .)
    GT              reduce using rule 70 (expr -> expr GE expr .)
    LE              reduce using rule 70 (expr -> expr GE expr .)
    LT              reduce using rule 70 (expr -> expr GE expr .)
    NE              reduce using rule 70 (expr -> expr GE expr .)
    EQ              reduce using rule 70 (expr -> expr GE expr .)
    AND             reduce using rule 70 (expr -> expr GE expr .)
    OR              reduce using rule 70 (expr -> expr GE expr .)
    )               reduce using rule 70 (expr -> expr GE expr .)
    ]               reduce using rule 70 (expr -> expr GE expr .)
    ,               reduce using rule 70 (expr -> expr GE expr .)
    }               reduce using rule 70 (expr -> expr GE expr .)
    PUBLIC          reduce using rule 70 (expr -> expr GE expr .)
    PRIVATE         reduce using rule 70 (expr -> expr GE expr .)
    THIS            reduce using rule 70 (expr -> expr GE expr .)
    IDENT           reduce using rule 70 (expr -> expr GE expr .)
    PRINTF          reduce using rule 70 (expr -> expr GE expr .)
    CONTINUE        reduce using rule 70 (expr -> expr GE expr .)
    BREAK           reduce using rule 70 (expr -> expr GE expr .)
    WHILE           reduce using rule 70 (expr -> expr GE expr .)
    RETURN          reduce using rule 70 (expr -> expr GE expr .)
    IF              reduce using rule 70 (expr -> expr GE expr .)
    {               reduce using rule 70 (expr -> expr GE expr .)
    (               reduce using rule 70 (expr -> expr GE expr .)
    !               reduce using rule 70 (expr -> expr GE expr .)
    STRINGLIT       reduce using rule 70 (expr -> expr GE expr .)
    BOOLIT          reduce using rule 70 (expr -> expr GE expr .)
    FLOATLIT        reduce using rule 70 (expr -> expr GE expr .)
    INTLIT          reduce using rule 70 (expr -> expr GE expr .)
    ELSE            reduce using rule 70 (expr -> expr GE expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 72

    (71) expr -> expr GT expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 71 (expr -> expr GT expr .)
    GE              reduce using rule 71 (expr -> expr GT expr .)
    GT              reduce using rule 71 (expr -> expr GT expr .)
    LE              reduce using rule 71 (expr -> expr GT expr .)
    LT              reduce using rule 71 (expr -> expr GT expr .)
    NE              reduce using rule 71 (expr -> expr GT expr .)
    EQ              reduce using rule 71 (expr -> expr GT expr .)
    AND             reduce using rule 71 (expr -> expr GT expr .)
    OR              reduce using rule 71 (expr -> expr GT expr .)
    )               reduce using rule 71 (expr -> expr GT expr .)
    ]               reduce using rule 71 (expr -> expr GT expr .)
    ,               reduce using rule 71 (expr -> expr GT expr .)
    }               reduce using rule 71 (expr -> expr GT expr .)
    PUBLIC          reduce using rule 71 (expr -> expr GT expr .)
    PRIVATE         reduce using rule 71 (expr -> expr GT expr .)
    THIS            reduce using rule 71 (expr -> expr GT expr .)
    IDENT           reduce using rule 71 (expr -> expr GT expr .)
    PRINTF          reduce using rule 71 (expr -> expr GT expr .)
    CONTINUE        reduce using rule 71 (expr -> expr GT expr .)
    BREAK           reduce using rule 71 (expr -> expr GT expr .)
    WHILE           reduce using rule 71 (expr -> expr GT expr .)
    RETURN          reduce using rule 71 (expr -> expr GT expr .)
    IF              reduce using rule 71 (expr -> expr GT expr .)
    {               reduce using rule 71 (expr -> expr GT expr .)
    (               reduce using rule 71 (expr -> expr GT expr .)
    !               reduce using rule 71 (expr -> expr GT expr .)
    STRINGLIT       reduce using rule 71 (expr -> expr GT expr .)
    BOOLIT          reduce using rule 71 (expr -> expr GT expr .)
    FLOATLIT        reduce using rule 71 (expr -> expr GT expr .)
    INTLIT          reduce using rule 71 (expr -> expr GT expr .)
    ELSE            reduce using rule 71 (expr -> expr GT expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 73

    (72) expr -> expr LE expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 72 (expr -> expr LE expr .)
    GE              reduce using rule 72 (expr -> expr LE expr .)
    GT              reduce using rule 72 (expr -> expr LE expr .)
    LE              reduce using rule 72 (expr -> expr LE expr .)
    LT              reduce using rule 72 (expr -> expr LE expr .)
    NE              reduce using rule 72 (expr -> expr LE expr .)
    EQ              reduce using rule 72 (expr -> expr LE expr .)
    AND             reduce using rule 72 (expr -> expr LE expr .)
    OR              reduce using rule 72 (expr -> expr LE expr .)
    )               reduce using rule 72 (expr -> expr LE expr .)
    ]               reduce using rule 72 (expr -> expr LE expr .)
    ,               reduce using rule 72 (expr -> expr LE expr .)
    }               reduce using rule 72 (expr -> expr LE expr .)
    PUBLIC          reduce using rule 72 (expr -> expr LE expr .)
    PRIVATE         reduce using rule 72 (expr -> expr LE expr .)
    THIS            reduce using rule 72 (expr -> expr LE expr .)
    IDENT           reduce using rule 72 (expr -> expr LE expr .)
    PRINTF          reduce using rule 72 (expr -> expr LE expr .)
    CONTINUE        reduce using rule 72 (expr -> expr LE expr .)
    BREAK           reduce using rule 72 (expr -> expr LE expr .)
    WHILE           reduce using rule 72 (expr -> expr LE expr .)
    RETURN          reduce using rule 72 (expr -> expr LE expr .)
    IF              reduce using rule 72 (expr -> expr LE expr .)
    {               reduce using rule 72 (expr -> expr LE expr .)
    (               reduce using rule 72 (expr -> expr LE expr .)
    !               reduce using rule 72 (expr -> expr LE expr .)
    STRINGLIT       reduce using rule 72 (expr -> expr LE expr .)
    BOOLIT          reduce using rule 72 (expr -> expr LE expr .)
    FLOATLIT        reduce using rule 72 (expr -> expr LE expr .)
    INTLIT          reduce using rule 72 (expr -> expr LE expr .)
    ELSE            reduce using rule 72 (expr -> expr LE expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 74

    (73) expr -> expr LT expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 73 (expr -> expr LT expr .)
    GE              reduce using rule 73 (expr -> expr LT expr .)
    GT              reduce using rule 73 (expr -> expr LT expr .)
    LE              reduce using rule 73 (expr -> expr LT expr .)
    LT              reduce using rule 73 (expr -> expr LT expr .)
    NE              reduce using rule 73 (expr -> expr LT expr .)
    EQ              reduce using rule 73 (expr -> expr LT expr .)
    AND             reduce using rule 73 (expr -> expr LT expr .)
    OR              reduce using rule 73 (expr -> expr LT expr .)
    )               reduce using rule 73 (expr -> expr LT expr .)
    ]               reduce using rule 73 (expr -> expr LT expr .)
    ,               reduce using rule 73 (expr -> expr LT expr .)
    }               reduce using rule 73 (expr -> expr LT expr .)
    PUBLIC          reduce using rule 73 (expr -> expr LT expr .)
    PRIVATE         reduce using rule 73 (expr -> expr LT expr .)
    THIS            reduce using rule 73 (expr -> expr LT expr .)
    IDENT           reduce using rule 73 (expr -> expr LT expr .)
    PRINTF          reduce using rule 73 (expr -> expr LT expr .)
    CONTINUE        reduce using rule 73 (expr -> expr LT expr .)
    BREAK           reduce using rule 73 (expr -> expr LT expr .)
    WHILE           reduce using rule 73 (expr -> expr LT expr .)
    RETURN          reduce using rule 73 (expr -> expr LT expr .)
    IF              reduce using rule 73 (expr -> expr LT expr .)
    {               reduce using rule 73 (expr -> expr LT expr .)
    (               reduce using rule 73 (expr -> expr LT expr .)
    !               reduce using rule 73 (expr -> expr LT expr .)
    STRINGLIT       reduce using rule 73 (expr -> expr LT expr .)
    BOOLIT          reduce using rule 73 (expr -> expr LT expr .)
    FLOATLIT        reduce using rule 73 (expr -> expr LT expr .)
    INTLIT          reduce using rule 73 (expr -> expr LT expr .)
    ELSE            reduce using rule 73 (expr -> expr LT expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43


state 75

    (74) expr -> expr NE expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 74 (expr -> expr NE expr .)
    NE              reduce using rule 74 (expr -> expr NE expr .)
    EQ              reduce using rule 74 (expr -> expr NE expr .)
    AND             reduce using rule 74 (expr -> expr NE expr .)
    OR              reduce using rule 74 (expr -> expr NE expr .)
    )               reduce using rule 74 (expr -> expr NE expr .)
    ]               reduce using rule 74 (expr -> expr NE expr .)
    ,               reduce using rule 74 (expr -> expr NE expr .)
    }               reduce using rule 74 (expr -> expr NE expr .)
    PUBLIC          reduce using rule 74 (expr -> expr NE expr .)
    PRIVATE         reduce using rule 74 (expr -> expr NE expr .)
    THIS            reduce using rule 74 (expr -> expr NE expr .)
    IDENT           reduce using rule 74 (expr -> expr NE expr .)
    PRINTF          reduce using rule 74 (expr -> expr NE expr .)
    CONTINUE        reduce using rule 74 (expr -> expr NE expr .)
    BREAK           reduce using rule 74 (expr -> expr NE expr .)
    WHILE           reduce using rule 74 (expr -> expr NE expr .)
    RETURN          reduce using rule 74 (expr -> expr NE expr .)
    IF              reduce using rule 74 (expr -> expr NE expr .)
    {               reduce using rule 74 (expr -> expr NE expr .)
    (               reduce using rule 74 (expr -> expr NE expr .)
    !               reduce using rule 74 (expr -> expr NE expr .)
    STRINGLIT       reduce using rule 74 (expr -> expr NE expr .)
    BOOLIT          reduce using rule 74 (expr -> expr NE expr .)
    FLOATLIT        reduce using rule 74 (expr -> expr NE expr .)
    INTLIT          reduce using rule 74 (expr -> expr NE expr .)
    ELSE            reduce using rule 74 (expr -> expr NE expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47


state 76

    (75) expr -> expr EQ expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 75 (expr -> expr EQ expr .)
    NE              reduce using rule 75 (expr -> expr EQ expr .)
    EQ              reduce using rule 75 (expr -> expr EQ expr .)
    AND             reduce using rule 75 (expr -> expr EQ expr .)
    OR              reduce using rule 75 (expr -> expr EQ expr .)
    )               reduce using rule 75 (expr -> expr EQ expr .)
    ]               reduce using rule 75 (expr -> expr EQ expr .)
    ,               reduce using rule 75 (expr -> expr EQ expr .)
    }               reduce using rule 75 (expr -> expr EQ expr .)
    PUBLIC          reduce using rule 75 (expr -> expr EQ expr .)
    PRIVATE         reduce using rule 75 (expr -> expr EQ expr .)
    THIS            reduce using rule 75 (expr -> expr EQ expr .)
    IDENT           reduce using rule 75 (expr -> expr EQ expr .)
    PRINTF          reduce using rule 75 (expr -> expr EQ expr .)
    CONTINUE        reduce using rule 75 (expr -> expr EQ expr .)
    BREAK           reduce using rule 75 (expr -> expr EQ expr .)
    WHILE           reduce using rule 75 (expr -> expr EQ expr .)
    RETURN          reduce using rule 75 (expr -> expr EQ expr .)
    IF              reduce using rule 75 (expr -> expr EQ expr .)
    {               reduce using rule 75 (expr -> expr EQ expr .)
    (               reduce using rule 75 (expr -> expr EQ expr .)
    !               reduce using rule 75 (expr -> expr EQ expr .)
    STRINGLIT       reduce using rule 75 (expr -> expr EQ expr .)
    BOOLIT          reduce using rule 75 (expr -> expr EQ expr .)
    FLOATLIT        reduce using rule 75 (expr -> expr EQ expr .)
    INTLIT          reduce using rule 75 (expr -> expr EQ expr .)
    ELSE            reduce using rule 75 (expr -> expr EQ expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47


state 77

    (76) expr -> expr AND expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 76 (expr -> expr AND expr .)
    AND             reduce using rule 76 (expr -> expr AND expr .)
    OR              reduce using rule 76 (expr -> expr AND expr .)
    )               reduce using rule 76 (expr -> expr AND expr .)
    ]               reduce using rule 76 (expr -> expr AND expr .)
    ,               reduce using rule 76 (expr -> expr AND expr .)
    }               reduce using rule 76 (expr -> expr AND expr .)
    PUBLIC          reduce using rule 76 (expr -> expr AND expr .)
    PRIVATE         reduce using rule 76 (expr -> expr AND expr .)
    THIS            reduce using rule 76 (expr -> expr AND expr .)
    IDENT           reduce using rule 76 (expr -> expr AND expr .)
    PRINTF          reduce using rule 76 (expr -> expr AND expr .)
    CONTINUE        reduce using rule 76 (expr -> expr AND expr .)
    BREAK           reduce using rule 76 (expr -> expr AND expr .)
    WHILE           reduce using rule 76 (expr -> expr AND expr .)
    RETURN          reduce using rule 76 (expr -> expr AND expr .)
    IF              reduce using rule 76 (expr -> expr AND expr .)
    {               reduce using rule 76 (expr -> expr AND expr .)
    (               reduce using rule 76 (expr -> expr AND expr .)
    !               reduce using rule 76 (expr -> expr AND expr .)
    STRINGLIT       reduce using rule 76 (expr -> expr AND expr .)
    BOOLIT          reduce using rule 76 (expr -> expr AND expr .)
    FLOATLIT        reduce using rule 76 (expr -> expr AND expr .)
    INTLIT          reduce using rule 76 (expr -> expr AND expr .)
    ELSE            reduce using rule 76 (expr -> expr AND expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47
    NE              shift and go to state 48
    EQ              shift and go to state 49


state 78

    (77) expr -> expr OR expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 77 (expr -> expr OR expr .)
    OR              reduce using rule 77 (expr -> expr OR expr .)
    )               reduce using rule 77 (expr -> expr OR expr .)
    ]               reduce using rule 77 (expr -> expr OR expr .)
    ,               reduce using rule 77 (expr -> expr OR expr .)
    }               reduce using rule 77 (expr -> expr OR expr .)
    PUBLIC          reduce using rule 77 (expr -> expr OR expr .)
    PRIVATE         reduce using rule 77 (expr -> expr OR expr .)
    THIS            reduce using rule 77 (expr -> expr OR expr .)
    IDENT           reduce using rule 77 (expr -> expr OR expr .)
    PRINTF          reduce using rule 77 (expr -> expr OR expr .)
    CONTINUE        reduce using rule 77 (expr -> expr OR expr .)
    BREAK           reduce using rule 77 (expr -> expr OR expr .)
    WHILE           reduce using rule 77 (expr -> expr OR expr .)
    RETURN          reduce using rule 77 (expr -> expr OR expr .)
    IF              reduce using rule 77 (expr -> expr OR expr .)
    {               reduce using rule 77 (expr -> expr OR expr .)
    (               reduce using rule 77 (expr -> expr OR expr .)
    !               reduce using rule 77 (expr -> expr OR expr .)
    STRINGLIT       reduce using rule 77 (expr -> expr OR expr .)
    BOOLIT          reduce using rule 77 (expr -> expr OR expr .)
    FLOATLIT        reduce using rule 77 (expr -> expr OR expr .)
    INTLIT          reduce using rule 77 (expr -> expr OR expr .)
    ELSE            reduce using rule 77 (expr -> expr OR expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47
    NE              shift and go to state 48
    EQ              shift and go to state 49
    AND             shift and go to state 50


state 79

    (61) expr -> ( expr ) .
    ;               reduce using rule 61 (expr -> ( expr ) .)
    %               reduce using rule 61 (expr -> ( expr ) .)
    /               reduce using rule 61 (expr -> ( expr ) .)
    *               reduce using rule 61 (expr -> ( expr ) .)
    -               reduce using rule 61 (expr -> ( expr ) .)
    +               reduce using rule 61 (expr -> ( expr ) .)
    GE              reduce using rule 61 (expr -> ( expr ) .)
    GT              reduce using rule 61 (expr -> ( expr ) .)
    LE              reduce using rule 61 (expr -> ( expr ) .)
    LT              reduce using rule 61 (expr -> ( expr ) .)
    NE              reduce using rule 61 (expr -> ( expr ) .)
    EQ              reduce using rule 61 (expr -> ( expr ) .)
    AND             reduce using rule 61 (expr -> ( expr ) .)
    OR              reduce using rule 61 (expr -> ( expr ) .)
    )               reduce using rule 61 (expr -> ( expr ) .)
    ]               reduce using rule 61 (expr -> ( expr ) .)
    ,               reduce using rule 61 (expr -> ( expr ) .)
    }               reduce using rule 61 (expr -> ( expr ) .)
    PUBLIC          reduce using rule 61 (expr -> ( expr ) .)
    PRIVATE         reduce using rule 61 (expr -> ( expr ) .)
    THIS            reduce using rule 61 (expr -> ( expr ) .)
    IDENT           reduce using rule 61 (expr -> ( expr ) .)
    PRINTF          reduce using rule 61 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 61 (expr -> ( expr ) .)
    BREAK           reduce using rule 61 (expr -> ( expr ) .)
    WHILE           reduce using rule 61 (expr -> ( expr ) .)
    RETURN          reduce using rule 61 (expr -> ( expr ) .)
    IF              reduce using rule 61 (expr -> ( expr ) .)
    {               reduce using rule 61 (expr -> ( expr ) .)
    (               reduce using rule 61 (expr -> ( expr ) .)
    !               reduce using rule 61 (expr -> ( expr ) .)
    STRINGLIT       reduce using rule 61 (expr -> ( expr ) .)
    BOOLIT          reduce using rule 61 (expr -> ( expr ) .)
    FLOATLIT        reduce using rule 61 (expr -> ( expr ) .)
    INTLIT          reduce using rule 61 (expr -> ( expr ) .)
    ELSE            reduce using rule 61 (expr -> ( expr ) .)


state 80

    (12) compound_stmt -> { local_decls . stmt_list }
    (13) local_decls -> local_decls . var_decl
    (15) local_decls -> local_decls .
    (16) stmt_list -> . stmt
    (17) stmt_list -> . stmt_list stmt
    (18) stmt_list -> . empty
    (19) stmt_list -> . stmt_list
    (52) var_decl -> . type_spec IDENT [ INTLIT ] ;
    (53) var_decl -> . type_spec IDENT = expr ;
    (54) var_decl -> . type_spec IDENT ;
    (20) stmt -> . public_stmt
    (21) stmt -> . private_stmt
    (22) stmt -> . this_stmt
    (23) stmt -> . new_stmt
    (24) stmt -> . print_stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . while_stmt
    (28) stmt -> . return_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (87) empty -> .
    (55) type_spec -> . STRING
    (56) type_spec -> . BOOL
    (57) type_spec -> . FLOAT
    (58) type_spec -> . INT
    (59) type_spec -> . VOID
    (40) public_stmt -> . PUBLIC : stmt
    (39) private_stmt -> . PRIVATE : stmt
    (51) this_stmt -> . THIS ;
    (46) new_stmt -> . IDENT = NEW IDENT ( args_list ) ;
    (50) print_stmt -> . PRINTF ( expr ) ;
    (45) continue_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (43) while_stmt -> . WHILE ( stmt ) expr
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (33) if_stmt -> . IF ( expr ) { stmt } ELSE { stmt }
    (34) if_stmt -> . IF ( expr ) stmt ELSE { stmt }
    (35) if_stmt -> . IF ( expr ) { stmt } ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (37) if_stmt -> . IF ( expr ) { stmt }
    (38) if_stmt -> . IF ( expr ) stmt
    (12) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . expr ;
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
  ! reduce/reduce conflict for } resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for PUBLIC resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for PRIVATE resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for THIS resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for IDENT resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for PRINTF resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for BREAK resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for WHILE resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for RETURN resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for IF resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for { resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for ( resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for + resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for ! resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for - resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for STRINGLIT resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for BOOLIT resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for FLOATLIT resolved using rule 15 (local_decls -> local_decls .)
  ! reduce/reduce conflict for INTLIT resolved using rule 15 (local_decls -> local_decls .)
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for ! resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for STRINGLIT resolved as shift
  ! shift/reduce conflict for BOOLIT resolved as shift
  ! shift/reduce conflict for FLOATLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
    }               reduce using rule 15 (local_decls -> local_decls .)
    STRING          shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    INT             shift and go to state 10
    VOID            shift and go to state 11
    PUBLIC          shift and go to state 105
    PRIVATE         shift and go to state 106
    THIS            shift and go to state 107
    IDENT           shift and go to state 91
    PRINTF          shift and go to state 108
    CONTINUE        shift and go to state 109
    BREAK           shift and go to state 110
    WHILE           shift and go to state 111
    RETURN          shift and go to state 112
    IF              shift and go to state 113
    {               shift and go to state 57
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    stmt_list                      shift and go to state 86
    var_decl                       shift and go to state 87
    stmt                           shift and go to state 88
    empty                          shift and go to state 89
    type_spec                      shift and go to state 90
    expr                           shift and go to state 92
    public_stmt                    shift and go to state 93
    private_stmt                   shift and go to state 94
    this_stmt                      shift and go to state 95
    new_stmt                       shift and go to state 96
    print_stmt                     shift and go to state 97
    continue_stmt                  shift and go to state 98
    break_stmt                     shift and go to state 99
    while_stmt                     shift and go to state 100
    return_stmt                    shift and go to state 101
    if_stmt                        shift and go to state 102
    compound_stmt                  shift and go to state 103
    expr_stmt                      shift and go to state 104

state 81

    (14) local_decls -> empty .
    STRING          reduce using rule 14 (local_decls -> empty .)
    BOOL            reduce using rule 14 (local_decls -> empty .)
    FLOAT           reduce using rule 14 (local_decls -> empty .)
    INT             reduce using rule 14 (local_decls -> empty .)
    VOID            reduce using rule 14 (local_decls -> empty .)
    PUBLIC          reduce using rule 14 (local_decls -> empty .)
    PRIVATE         reduce using rule 14 (local_decls -> empty .)
    THIS            reduce using rule 14 (local_decls -> empty .)
    IDENT           reduce using rule 14 (local_decls -> empty .)
    PRINTF          reduce using rule 14 (local_decls -> empty .)
    CONTINUE        reduce using rule 14 (local_decls -> empty .)
    BREAK           reduce using rule 14 (local_decls -> empty .)
    WHILE           reduce using rule 14 (local_decls -> empty .)
    RETURN          reduce using rule 14 (local_decls -> empty .)
    IF              reduce using rule 14 (local_decls -> empty .)
    {               reduce using rule 14 (local_decls -> empty .)
    (               reduce using rule 14 (local_decls -> empty .)
    +               reduce using rule 14 (local_decls -> empty .)
    !               reduce using rule 14 (local_decls -> empty .)
    -               reduce using rule 14 (local_decls -> empty .)
    STRINGLIT       reduce using rule 14 (local_decls -> empty .)
    BOOLIT          reduce using rule 14 (local_decls -> empty .)
    FLOATLIT        reduce using rule 14 (local_decls -> empty .)
    INTLIT          reduce using rule 14 (local_decls -> empty .)
    }               reduce using rule 14 (local_decls -> empty .)


state 82

    (10) param -> type_spec IDENT . [ INTLIT ]
    (11) param -> type_spec IDENT .
    [               shift and go to state 114
    )               reduce using rule 11 (param -> type_spec IDENT .)
    ,               reduce using rule 11 (param -> type_spec IDENT .)


state 83

    (79) expr -> IDENT ( args_list ) .
    ;               reduce using rule 79 (expr -> IDENT ( args_list ) .)
    %               reduce using rule 79 (expr -> IDENT ( args_list ) .)
    /               reduce using rule 79 (expr -> IDENT ( args_list ) .)
    *               reduce using rule 79 (expr -> IDENT ( args_list ) .)
    -               reduce using rule 79 (expr -> IDENT ( args_list ) .)
    +               reduce using rule 79 (expr -> IDENT ( args_list ) .)
    GE              reduce using rule 79 (expr -> IDENT ( args_list ) .)
    GT              reduce using rule 79 (expr -> IDENT ( args_list ) .)
    LE              reduce using rule 79 (expr -> IDENT ( args_list ) .)
    LT              reduce using rule 79 (expr -> IDENT ( args_list ) .)
    NE              reduce using rule 79 (expr -> IDENT ( args_list ) .)
    EQ              reduce using rule 79 (expr -> IDENT ( args_list ) .)
    AND             reduce using rule 79 (expr -> IDENT ( args_list ) .)
    OR              reduce using rule 79 (expr -> IDENT ( args_list ) .)
    )               reduce using rule 79 (expr -> IDENT ( args_list ) .)
    ]               reduce using rule 79 (expr -> IDENT ( args_list ) .)
    ,               reduce using rule 79 (expr -> IDENT ( args_list ) .)
    }               reduce using rule 79 (expr -> IDENT ( args_list ) .)
    PUBLIC          reduce using rule 79 (expr -> IDENT ( args_list ) .)
    PRIVATE         reduce using rule 79 (expr -> IDENT ( args_list ) .)
    THIS            reduce using rule 79 (expr -> IDENT ( args_list ) .)
    IDENT           reduce using rule 79 (expr -> IDENT ( args_list ) .)
    PRINTF          reduce using rule 79 (expr -> IDENT ( args_list ) .)
    CONTINUE        reduce using rule 79 (expr -> IDENT ( args_list ) .)
    BREAK           reduce using rule 79 (expr -> IDENT ( args_list ) .)
    WHILE           reduce using rule 79 (expr -> IDENT ( args_list ) .)
    RETURN          reduce using rule 79 (expr -> IDENT ( args_list ) .)
    IF              reduce using rule 79 (expr -> IDENT ( args_list ) .)
    {               reduce using rule 79 (expr -> IDENT ( args_list ) .)
    (               reduce using rule 79 (expr -> IDENT ( args_list ) .)
    !               reduce using rule 79 (expr -> IDENT ( args_list ) .)
    STRINGLIT       reduce using rule 79 (expr -> IDENT ( args_list ) .)
    BOOLIT          reduce using rule 79 (expr -> IDENT ( args_list ) .)
    FLOATLIT        reduce using rule 79 (expr -> IDENT ( args_list ) .)
    INTLIT          reduce using rule 79 (expr -> IDENT ( args_list ) .)
    ELSE            reduce using rule 79 (expr -> IDENT ( args_list ) .)


state 84

    (47) args_list -> args_list , . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 115

state 85

    (80) expr -> IDENT [ expr ] .
    (81) expr -> IDENT [ expr ] . = expr
    ;               reduce using rule 80 (expr -> IDENT [ expr ] .)
    %               reduce using rule 80 (expr -> IDENT [ expr ] .)
    /               reduce using rule 80 (expr -> IDENT [ expr ] .)
    *               reduce using rule 80 (expr -> IDENT [ expr ] .)
    -               reduce using rule 80 (expr -> IDENT [ expr ] .)
    +               reduce using rule 80 (expr -> IDENT [ expr ] .)
    GE              reduce using rule 80 (expr -> IDENT [ expr ] .)
    GT              reduce using rule 80 (expr -> IDENT [ expr ] .)
    LE              reduce using rule 80 (expr -> IDENT [ expr ] .)
    LT              reduce using rule 80 (expr -> IDENT [ expr ] .)
    NE              reduce using rule 80 (expr -> IDENT [ expr ] .)
    EQ              reduce using rule 80 (expr -> IDENT [ expr ] .)
    AND             reduce using rule 80 (expr -> IDENT [ expr ] .)
    OR              reduce using rule 80 (expr -> IDENT [ expr ] .)
    )               reduce using rule 80 (expr -> IDENT [ expr ] .)
    ]               reduce using rule 80 (expr -> IDENT [ expr ] .)
    ,               reduce using rule 80 (expr -> IDENT [ expr ] .)
    }               reduce using rule 80 (expr -> IDENT [ expr ] .)
    PUBLIC          reduce using rule 80 (expr -> IDENT [ expr ] .)
    PRIVATE         reduce using rule 80 (expr -> IDENT [ expr ] .)
    THIS            reduce using rule 80 (expr -> IDENT [ expr ] .)
    IDENT           reduce using rule 80 (expr -> IDENT [ expr ] .)
    PRINTF          reduce using rule 80 (expr -> IDENT [ expr ] .)
    CONTINUE        reduce using rule 80 (expr -> IDENT [ expr ] .)
    BREAK           reduce using rule 80 (expr -> IDENT [ expr ] .)
    WHILE           reduce using rule 80 (expr -> IDENT [ expr ] .)
    RETURN          reduce using rule 80 (expr -> IDENT [ expr ] .)
    IF              reduce using rule 80 (expr -> IDENT [ expr ] .)
    {               reduce using rule 80 (expr -> IDENT [ expr ] .)
    (               reduce using rule 80 (expr -> IDENT [ expr ] .)
    !               reduce using rule 80 (expr -> IDENT [ expr ] .)
    STRINGLIT       reduce using rule 80 (expr -> IDENT [ expr ] .)
    BOOLIT          reduce using rule 80 (expr -> IDENT [ expr ] .)
    FLOATLIT        reduce using rule 80 (expr -> IDENT [ expr ] .)
    INTLIT          reduce using rule 80 (expr -> IDENT [ expr ] .)
    ELSE            reduce using rule 80 (expr -> IDENT [ expr ] .)
    =               shift and go to state 116


state 86

    (12) compound_stmt -> { local_decls stmt_list . }
    (17) stmt_list -> stmt_list . stmt
    (19) stmt_list -> stmt_list .
    (20) stmt -> . public_stmt
    (21) stmt -> . private_stmt
    (22) stmt -> . this_stmt
    (23) stmt -> . new_stmt
    (24) stmt -> . print_stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . while_stmt
    (28) stmt -> . return_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (40) public_stmt -> . PUBLIC : stmt
    (39) private_stmt -> . PRIVATE : stmt
    (51) this_stmt -> . THIS ;
    (46) new_stmt -> . IDENT = NEW IDENT ( args_list ) ;
    (50) print_stmt -> . PRINTF ( expr ) ;
    (45) continue_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (43) while_stmt -> . WHILE ( stmt ) expr
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (33) if_stmt -> . IF ( expr ) { stmt } ELSE { stmt }
    (34) if_stmt -> . IF ( expr ) stmt ELSE { stmt }
    (35) if_stmt -> . IF ( expr ) { stmt } ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (37) if_stmt -> . IF ( expr ) { stmt }
    (38) if_stmt -> . IF ( expr ) stmt
    (12) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . expr ;
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
  ! shift/reduce conflict for } resolved as shift
  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for ! resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for STRINGLIT resolved as shift
  ! shift/reduce conflict for BOOLIT resolved as shift
  ! shift/reduce conflict for FLOATLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
    }               shift and go to state 117
    PUBLIC          shift and go to state 105
    PRIVATE         shift and go to state 106
    THIS            shift and go to state 107
    IDENT           shift and go to state 91
    PRINTF          shift and go to state 108
    CONTINUE        shift and go to state 109
    BREAK           shift and go to state 110
    WHILE           shift and go to state 111
    RETURN          shift and go to state 112
    IF              shift and go to state 113
    {               shift and go to state 57
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    stmt                           shift and go to state 118
    public_stmt                    shift and go to state 93
    private_stmt                   shift and go to state 94
    this_stmt                      shift and go to state 95
    new_stmt                       shift and go to state 96
    print_stmt                     shift and go to state 97
    continue_stmt                  shift and go to state 98
    break_stmt                     shift and go to state 99
    while_stmt                     shift and go to state 100
    return_stmt                    shift and go to state 101
    if_stmt                        shift and go to state 102
    compound_stmt                  shift and go to state 103
    expr_stmt                      shift and go to state 104
    expr                           shift and go to state 92

state 87

    (13) local_decls -> local_decls var_decl .
    STRING          reduce using rule 13 (local_decls -> local_decls var_decl .)
    BOOL            reduce using rule 13 (local_decls -> local_decls var_decl .)
    FLOAT           reduce using rule 13 (local_decls -> local_decls var_decl .)
    INT             reduce using rule 13 (local_decls -> local_decls var_decl .)
    VOID            reduce using rule 13 (local_decls -> local_decls var_decl .)
    PUBLIC          reduce using rule 13 (local_decls -> local_decls var_decl .)
    PRIVATE         reduce using rule 13 (local_decls -> local_decls var_decl .)
    THIS            reduce using rule 13 (local_decls -> local_decls var_decl .)
    IDENT           reduce using rule 13 (local_decls -> local_decls var_decl .)
    PRINTF          reduce using rule 13 (local_decls -> local_decls var_decl .)
    CONTINUE        reduce using rule 13 (local_decls -> local_decls var_decl .)
    BREAK           reduce using rule 13 (local_decls -> local_decls var_decl .)
    WHILE           reduce using rule 13 (local_decls -> local_decls var_decl .)
    RETURN          reduce using rule 13 (local_decls -> local_decls var_decl .)
    IF              reduce using rule 13 (local_decls -> local_decls var_decl .)
    {               reduce using rule 13 (local_decls -> local_decls var_decl .)
    (               reduce using rule 13 (local_decls -> local_decls var_decl .)
    +               reduce using rule 13 (local_decls -> local_decls var_decl .)
    !               reduce using rule 13 (local_decls -> local_decls var_decl .)
    -               reduce using rule 13 (local_decls -> local_decls var_decl .)
    STRINGLIT       reduce using rule 13 (local_decls -> local_decls var_decl .)
    BOOLIT          reduce using rule 13 (local_decls -> local_decls var_decl .)
    FLOATLIT        reduce using rule 13 (local_decls -> local_decls var_decl .)
    INTLIT          reduce using rule 13 (local_decls -> local_decls var_decl .)
    }               reduce using rule 13 (local_decls -> local_decls var_decl .)


state 88

    (16) stmt_list -> stmt .
    }               reduce using rule 16 (stmt_list -> stmt .)
    PUBLIC          reduce using rule 16 (stmt_list -> stmt .)
    PRIVATE         reduce using rule 16 (stmt_list -> stmt .)
    THIS            reduce using rule 16 (stmt_list -> stmt .)
    IDENT           reduce using rule 16 (stmt_list -> stmt .)
    PRINTF          reduce using rule 16 (stmt_list -> stmt .)
    CONTINUE        reduce using rule 16 (stmt_list -> stmt .)
    BREAK           reduce using rule 16 (stmt_list -> stmt .)
    WHILE           reduce using rule 16 (stmt_list -> stmt .)
    RETURN          reduce using rule 16 (stmt_list -> stmt .)
    IF              reduce using rule 16 (stmt_list -> stmt .)
    {               reduce using rule 16 (stmt_list -> stmt .)
    (               reduce using rule 16 (stmt_list -> stmt .)
    +               reduce using rule 16 (stmt_list -> stmt .)
    !               reduce using rule 16 (stmt_list -> stmt .)
    -               reduce using rule 16 (stmt_list -> stmt .)
    STRINGLIT       reduce using rule 16 (stmt_list -> stmt .)
    BOOLIT          reduce using rule 16 (stmt_list -> stmt .)
    FLOATLIT        reduce using rule 16 (stmt_list -> stmt .)
    INTLIT          reduce using rule 16 (stmt_list -> stmt .)


state 89

    (18) stmt_list -> empty .
    }               reduce using rule 18 (stmt_list -> empty .)
    PUBLIC          reduce using rule 18 (stmt_list -> empty .)
    PRIVATE         reduce using rule 18 (stmt_list -> empty .)
    THIS            reduce using rule 18 (stmt_list -> empty .)
    IDENT           reduce using rule 18 (stmt_list -> empty .)
    PRINTF          reduce using rule 18 (stmt_list -> empty .)
    CONTINUE        reduce using rule 18 (stmt_list -> empty .)
    BREAK           reduce using rule 18 (stmt_list -> empty .)
    WHILE           reduce using rule 18 (stmt_list -> empty .)
    RETURN          reduce using rule 18 (stmt_list -> empty .)
    IF              reduce using rule 18 (stmt_list -> empty .)
    {               reduce using rule 18 (stmt_list -> empty .)
    (               reduce using rule 18 (stmt_list -> empty .)
    +               reduce using rule 18 (stmt_list -> empty .)
    !               reduce using rule 18 (stmt_list -> empty .)
    -               reduce using rule 18 (stmt_list -> empty .)
    STRINGLIT       reduce using rule 18 (stmt_list -> empty .)
    BOOLIT          reduce using rule 18 (stmt_list -> empty .)
    FLOATLIT        reduce using rule 18 (stmt_list -> empty .)
    INTLIT          reduce using rule 18 (stmt_list -> empty .)


state 90

    (52) var_decl -> type_spec . IDENT [ INTLIT ] ;
    (53) var_decl -> type_spec . IDENT = expr ;
    (54) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 119


state 91

    (46) new_stmt -> IDENT . = NEW IDENT ( args_list ) ;
    (60) expr -> IDENT . . SIZE
    (78) expr -> IDENT .
    (79) expr -> IDENT . ( args_list )
    (80) expr -> IDENT . [ expr ]
    (81) expr -> IDENT . [ expr ] = expr
    (82) expr -> IDENT . = expr
    =               shift and go to state 120
    .               shift and go to state 34
    ;               reduce using rule 78 (expr -> IDENT .)
    %               reduce using rule 78 (expr -> IDENT .)
    /               reduce using rule 78 (expr -> IDENT .)
    *               reduce using rule 78 (expr -> IDENT .)
    -               reduce using rule 78 (expr -> IDENT .)
    +               reduce using rule 78 (expr -> IDENT .)
    GE              reduce using rule 78 (expr -> IDENT .)
    GT              reduce using rule 78 (expr -> IDENT .)
    LE              reduce using rule 78 (expr -> IDENT .)
    LT              reduce using rule 78 (expr -> IDENT .)
    NE              reduce using rule 78 (expr -> IDENT .)
    EQ              reduce using rule 78 (expr -> IDENT .)
    AND             reduce using rule 78 (expr -> IDENT .)
    OR              reduce using rule 78 (expr -> IDENT .)
    (               shift and go to state 35
    [               shift and go to state 36


state 92

    (32) expr_stmt -> expr . ;
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               shift and go to state 121
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47
    NE              shift and go to state 48
    EQ              shift and go to state 49
    AND             shift and go to state 50
    OR              shift and go to state 51


state 93

    (20) stmt -> public_stmt .
    }               reduce using rule 20 (stmt -> public_stmt .)
    PUBLIC          reduce using rule 20 (stmt -> public_stmt .)
    PRIVATE         reduce using rule 20 (stmt -> public_stmt .)
    THIS            reduce using rule 20 (stmt -> public_stmt .)
    IDENT           reduce using rule 20 (stmt -> public_stmt .)
    PRINTF          reduce using rule 20 (stmt -> public_stmt .)
    CONTINUE        reduce using rule 20 (stmt -> public_stmt .)
    BREAK           reduce using rule 20 (stmt -> public_stmt .)
    WHILE           reduce using rule 20 (stmt -> public_stmt .)
    RETURN          reduce using rule 20 (stmt -> public_stmt .)
    IF              reduce using rule 20 (stmt -> public_stmt .)
    {               reduce using rule 20 (stmt -> public_stmt .)
    (               reduce using rule 20 (stmt -> public_stmt .)
    +               reduce using rule 20 (stmt -> public_stmt .)
    !               reduce using rule 20 (stmt -> public_stmt .)
    -               reduce using rule 20 (stmt -> public_stmt .)
    STRINGLIT       reduce using rule 20 (stmt -> public_stmt .)
    BOOLIT          reduce using rule 20 (stmt -> public_stmt .)
    FLOATLIT        reduce using rule 20 (stmt -> public_stmt .)
    INTLIT          reduce using rule 20 (stmt -> public_stmt .)
    )               reduce using rule 20 (stmt -> public_stmt .)
    ELSE            reduce using rule 20 (stmt -> public_stmt .)


state 94

    (21) stmt -> private_stmt .
    }               reduce using rule 21 (stmt -> private_stmt .)
    PUBLIC          reduce using rule 21 (stmt -> private_stmt .)
    PRIVATE         reduce using rule 21 (stmt -> private_stmt .)
    THIS            reduce using rule 21 (stmt -> private_stmt .)
    IDENT           reduce using rule 21 (stmt -> private_stmt .)
    PRINTF          reduce using rule 21 (stmt -> private_stmt .)
    CONTINUE        reduce using rule 21 (stmt -> private_stmt .)
    BREAK           reduce using rule 21 (stmt -> private_stmt .)
    WHILE           reduce using rule 21 (stmt -> private_stmt .)
    RETURN          reduce using rule 21 (stmt -> private_stmt .)
    IF              reduce using rule 21 (stmt -> private_stmt .)
    {               reduce using rule 21 (stmt -> private_stmt .)
    (               reduce using rule 21 (stmt -> private_stmt .)
    +               reduce using rule 21 (stmt -> private_stmt .)
    !               reduce using rule 21 (stmt -> private_stmt .)
    -               reduce using rule 21 (stmt -> private_stmt .)
    STRINGLIT       reduce using rule 21 (stmt -> private_stmt .)
    BOOLIT          reduce using rule 21 (stmt -> private_stmt .)
    FLOATLIT        reduce using rule 21 (stmt -> private_stmt .)
    INTLIT          reduce using rule 21 (stmt -> private_stmt .)
    )               reduce using rule 21 (stmt -> private_stmt .)
    ELSE            reduce using rule 21 (stmt -> private_stmt .)


state 95

    (22) stmt -> this_stmt .
    }               reduce using rule 22 (stmt -> this_stmt .)
    PUBLIC          reduce using rule 22 (stmt -> this_stmt .)
    PRIVATE         reduce using rule 22 (stmt -> this_stmt .)
    THIS            reduce using rule 22 (stmt -> this_stmt .)
    IDENT           reduce using rule 22 (stmt -> this_stmt .)
    PRINTF          reduce using rule 22 (stmt -> this_stmt .)
    CONTINUE        reduce using rule 22 (stmt -> this_stmt .)
    BREAK           reduce using rule 22 (stmt -> this_stmt .)
    WHILE           reduce using rule 22 (stmt -> this_stmt .)
    RETURN          reduce using rule 22 (stmt -> this_stmt .)
    IF              reduce using rule 22 (stmt -> this_stmt .)
    {               reduce using rule 22 (stmt -> this_stmt .)
    (               reduce using rule 22 (stmt -> this_stmt .)
    +               reduce using rule 22 (stmt -> this_stmt .)
    !               reduce using rule 22 (stmt -> this_stmt .)
    -               reduce using rule 22 (stmt -> this_stmt .)
    STRINGLIT       reduce using rule 22 (stmt -> this_stmt .)
    BOOLIT          reduce using rule 22 (stmt -> this_stmt .)
    FLOATLIT        reduce using rule 22 (stmt -> this_stmt .)
    INTLIT          reduce using rule 22 (stmt -> this_stmt .)
    )               reduce using rule 22 (stmt -> this_stmt .)
    ELSE            reduce using rule 22 (stmt -> this_stmt .)


state 96

    (23) stmt -> new_stmt .
    }               reduce using rule 23 (stmt -> new_stmt .)
    PUBLIC          reduce using rule 23 (stmt -> new_stmt .)
    PRIVATE         reduce using rule 23 (stmt -> new_stmt .)
    THIS            reduce using rule 23 (stmt -> new_stmt .)
    IDENT           reduce using rule 23 (stmt -> new_stmt .)
    PRINTF          reduce using rule 23 (stmt -> new_stmt .)
    CONTINUE        reduce using rule 23 (stmt -> new_stmt .)
    BREAK           reduce using rule 23 (stmt -> new_stmt .)
    WHILE           reduce using rule 23 (stmt -> new_stmt .)
    RETURN          reduce using rule 23 (stmt -> new_stmt .)
    IF              reduce using rule 23 (stmt -> new_stmt .)
    {               reduce using rule 23 (stmt -> new_stmt .)
    (               reduce using rule 23 (stmt -> new_stmt .)
    +               reduce using rule 23 (stmt -> new_stmt .)
    !               reduce using rule 23 (stmt -> new_stmt .)
    -               reduce using rule 23 (stmt -> new_stmt .)
    STRINGLIT       reduce using rule 23 (stmt -> new_stmt .)
    BOOLIT          reduce using rule 23 (stmt -> new_stmt .)
    FLOATLIT        reduce using rule 23 (stmt -> new_stmt .)
    INTLIT          reduce using rule 23 (stmt -> new_stmt .)
    )               reduce using rule 23 (stmt -> new_stmt .)
    ELSE            reduce using rule 23 (stmt -> new_stmt .)


state 97

    (24) stmt -> print_stmt .
    }               reduce using rule 24 (stmt -> print_stmt .)
    PUBLIC          reduce using rule 24 (stmt -> print_stmt .)
    PRIVATE         reduce using rule 24 (stmt -> print_stmt .)
    THIS            reduce using rule 24 (stmt -> print_stmt .)
    IDENT           reduce using rule 24 (stmt -> print_stmt .)
    PRINTF          reduce using rule 24 (stmt -> print_stmt .)
    CONTINUE        reduce using rule 24 (stmt -> print_stmt .)
    BREAK           reduce using rule 24 (stmt -> print_stmt .)
    WHILE           reduce using rule 24 (stmt -> print_stmt .)
    RETURN          reduce using rule 24 (stmt -> print_stmt .)
    IF              reduce using rule 24 (stmt -> print_stmt .)
    {               reduce using rule 24 (stmt -> print_stmt .)
    (               reduce using rule 24 (stmt -> print_stmt .)
    +               reduce using rule 24 (stmt -> print_stmt .)
    !               reduce using rule 24 (stmt -> print_stmt .)
    -               reduce using rule 24 (stmt -> print_stmt .)
    STRINGLIT       reduce using rule 24 (stmt -> print_stmt .)
    BOOLIT          reduce using rule 24 (stmt -> print_stmt .)
    FLOATLIT        reduce using rule 24 (stmt -> print_stmt .)
    INTLIT          reduce using rule 24 (stmt -> print_stmt .)
    )               reduce using rule 24 (stmt -> print_stmt .)
    ELSE            reduce using rule 24 (stmt -> print_stmt .)


state 98

    (25) stmt -> continue_stmt .
    }               reduce using rule 25 (stmt -> continue_stmt .)
    PUBLIC          reduce using rule 25 (stmt -> continue_stmt .)
    PRIVATE         reduce using rule 25 (stmt -> continue_stmt .)
    THIS            reduce using rule 25 (stmt -> continue_stmt .)
    IDENT           reduce using rule 25 (stmt -> continue_stmt .)
    PRINTF          reduce using rule 25 (stmt -> continue_stmt .)
    CONTINUE        reduce using rule 25 (stmt -> continue_stmt .)
    BREAK           reduce using rule 25 (stmt -> continue_stmt .)
    WHILE           reduce using rule 25 (stmt -> continue_stmt .)
    RETURN          reduce using rule 25 (stmt -> continue_stmt .)
    IF              reduce using rule 25 (stmt -> continue_stmt .)
    {               reduce using rule 25 (stmt -> continue_stmt .)
    (               reduce using rule 25 (stmt -> continue_stmt .)
    +               reduce using rule 25 (stmt -> continue_stmt .)
    !               reduce using rule 25 (stmt -> continue_stmt .)
    -               reduce using rule 25 (stmt -> continue_stmt .)
    STRINGLIT       reduce using rule 25 (stmt -> continue_stmt .)
    BOOLIT          reduce using rule 25 (stmt -> continue_stmt .)
    FLOATLIT        reduce using rule 25 (stmt -> continue_stmt .)
    INTLIT          reduce using rule 25 (stmt -> continue_stmt .)
    )               reduce using rule 25 (stmt -> continue_stmt .)
    ELSE            reduce using rule 25 (stmt -> continue_stmt .)


state 99

    (26) stmt -> break_stmt .
    }               reduce using rule 26 (stmt -> break_stmt .)
    PUBLIC          reduce using rule 26 (stmt -> break_stmt .)
    PRIVATE         reduce using rule 26 (stmt -> break_stmt .)
    THIS            reduce using rule 26 (stmt -> break_stmt .)
    IDENT           reduce using rule 26 (stmt -> break_stmt .)
    PRINTF          reduce using rule 26 (stmt -> break_stmt .)
    CONTINUE        reduce using rule 26 (stmt -> break_stmt .)
    BREAK           reduce using rule 26 (stmt -> break_stmt .)
    WHILE           reduce using rule 26 (stmt -> break_stmt .)
    RETURN          reduce using rule 26 (stmt -> break_stmt .)
    IF              reduce using rule 26 (stmt -> break_stmt .)
    {               reduce using rule 26 (stmt -> break_stmt .)
    (               reduce using rule 26 (stmt -> break_stmt .)
    +               reduce using rule 26 (stmt -> break_stmt .)
    !               reduce using rule 26 (stmt -> break_stmt .)
    -               reduce using rule 26 (stmt -> break_stmt .)
    STRINGLIT       reduce using rule 26 (stmt -> break_stmt .)
    BOOLIT          reduce using rule 26 (stmt -> break_stmt .)
    FLOATLIT        reduce using rule 26 (stmt -> break_stmt .)
    INTLIT          reduce using rule 26 (stmt -> break_stmt .)
    )               reduce using rule 26 (stmt -> break_stmt .)
    ELSE            reduce using rule 26 (stmt -> break_stmt .)


state 100

    (27) stmt -> while_stmt .
    }               reduce using rule 27 (stmt -> while_stmt .)
    PUBLIC          reduce using rule 27 (stmt -> while_stmt .)
    PRIVATE         reduce using rule 27 (stmt -> while_stmt .)
    THIS            reduce using rule 27 (stmt -> while_stmt .)
    IDENT           reduce using rule 27 (stmt -> while_stmt .)
    PRINTF          reduce using rule 27 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 27 (stmt -> while_stmt .)
    BREAK           reduce using rule 27 (stmt -> while_stmt .)
    WHILE           reduce using rule 27 (stmt -> while_stmt .)
    RETURN          reduce using rule 27 (stmt -> while_stmt .)
    IF              reduce using rule 27 (stmt -> while_stmt .)
    {               reduce using rule 27 (stmt -> while_stmt .)
    (               reduce using rule 27 (stmt -> while_stmt .)
    +               reduce using rule 27 (stmt -> while_stmt .)
    !               reduce using rule 27 (stmt -> while_stmt .)
    -               reduce using rule 27 (stmt -> while_stmt .)
    STRINGLIT       reduce using rule 27 (stmt -> while_stmt .)
    BOOLIT          reduce using rule 27 (stmt -> while_stmt .)
    FLOATLIT        reduce using rule 27 (stmt -> while_stmt .)
    INTLIT          reduce using rule 27 (stmt -> while_stmt .)
    )               reduce using rule 27 (stmt -> while_stmt .)
    ELSE            reduce using rule 27 (stmt -> while_stmt .)


state 101

    (28) stmt -> return_stmt .
    }               reduce using rule 28 (stmt -> return_stmt .)
    PUBLIC          reduce using rule 28 (stmt -> return_stmt .)
    PRIVATE         reduce using rule 28 (stmt -> return_stmt .)
    THIS            reduce using rule 28 (stmt -> return_stmt .)
    IDENT           reduce using rule 28 (stmt -> return_stmt .)
    PRINTF          reduce using rule 28 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 28 (stmt -> return_stmt .)
    BREAK           reduce using rule 28 (stmt -> return_stmt .)
    WHILE           reduce using rule 28 (stmt -> return_stmt .)
    RETURN          reduce using rule 28 (stmt -> return_stmt .)
    IF              reduce using rule 28 (stmt -> return_stmt .)
    {               reduce using rule 28 (stmt -> return_stmt .)
    (               reduce using rule 28 (stmt -> return_stmt .)
    +               reduce using rule 28 (stmt -> return_stmt .)
    !               reduce using rule 28 (stmt -> return_stmt .)
    -               reduce using rule 28 (stmt -> return_stmt .)
    STRINGLIT       reduce using rule 28 (stmt -> return_stmt .)
    BOOLIT          reduce using rule 28 (stmt -> return_stmt .)
    FLOATLIT        reduce using rule 28 (stmt -> return_stmt .)
    INTLIT          reduce using rule 28 (stmt -> return_stmt .)
    )               reduce using rule 28 (stmt -> return_stmt .)
    ELSE            reduce using rule 28 (stmt -> return_stmt .)


state 102

    (29) stmt -> if_stmt .
    }               reduce using rule 29 (stmt -> if_stmt .)
    PUBLIC          reduce using rule 29 (stmt -> if_stmt .)
    PRIVATE         reduce using rule 29 (stmt -> if_stmt .)
    THIS            reduce using rule 29 (stmt -> if_stmt .)
    IDENT           reduce using rule 29 (stmt -> if_stmt .)
    PRINTF          reduce using rule 29 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 29 (stmt -> if_stmt .)
    BREAK           reduce using rule 29 (stmt -> if_stmt .)
    WHILE           reduce using rule 29 (stmt -> if_stmt .)
    RETURN          reduce using rule 29 (stmt -> if_stmt .)
    IF              reduce using rule 29 (stmt -> if_stmt .)
    {               reduce using rule 29 (stmt -> if_stmt .)
    (               reduce using rule 29 (stmt -> if_stmt .)
    +               reduce using rule 29 (stmt -> if_stmt .)
    !               reduce using rule 29 (stmt -> if_stmt .)
    -               reduce using rule 29 (stmt -> if_stmt .)
    STRINGLIT       reduce using rule 29 (stmt -> if_stmt .)
    BOOLIT          reduce using rule 29 (stmt -> if_stmt .)
    FLOATLIT        reduce using rule 29 (stmt -> if_stmt .)
    INTLIT          reduce using rule 29 (stmt -> if_stmt .)
    )               reduce using rule 29 (stmt -> if_stmt .)
    ELSE            reduce using rule 29 (stmt -> if_stmt .)


state 103

    (30) stmt -> compound_stmt .
    }               reduce using rule 30 (stmt -> compound_stmt .)
    PUBLIC          reduce using rule 30 (stmt -> compound_stmt .)
    PRIVATE         reduce using rule 30 (stmt -> compound_stmt .)
    THIS            reduce using rule 30 (stmt -> compound_stmt .)
    IDENT           reduce using rule 30 (stmt -> compound_stmt .)
    PRINTF          reduce using rule 30 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 30 (stmt -> compound_stmt .)
    BREAK           reduce using rule 30 (stmt -> compound_stmt .)
    WHILE           reduce using rule 30 (stmt -> compound_stmt .)
    RETURN          reduce using rule 30 (stmt -> compound_stmt .)
    IF              reduce using rule 30 (stmt -> compound_stmt .)
    {               reduce using rule 30 (stmt -> compound_stmt .)
    (               reduce using rule 30 (stmt -> compound_stmt .)
    +               reduce using rule 30 (stmt -> compound_stmt .)
    !               reduce using rule 30 (stmt -> compound_stmt .)
    -               reduce using rule 30 (stmt -> compound_stmt .)
    STRINGLIT       reduce using rule 30 (stmt -> compound_stmt .)
    BOOLIT          reduce using rule 30 (stmt -> compound_stmt .)
    FLOATLIT        reduce using rule 30 (stmt -> compound_stmt .)
    INTLIT          reduce using rule 30 (stmt -> compound_stmt .)
    )               reduce using rule 30 (stmt -> compound_stmt .)
    ELSE            reduce using rule 30 (stmt -> compound_stmt .)


state 104

    (31) stmt -> expr_stmt .
    }               reduce using rule 31 (stmt -> expr_stmt .)
    PUBLIC          reduce using rule 31 (stmt -> expr_stmt .)
    PRIVATE         reduce using rule 31 (stmt -> expr_stmt .)
    THIS            reduce using rule 31 (stmt -> expr_stmt .)
    IDENT           reduce using rule 31 (stmt -> expr_stmt .)
    PRINTF          reduce using rule 31 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 31 (stmt -> expr_stmt .)
    BREAK           reduce using rule 31 (stmt -> expr_stmt .)
    WHILE           reduce using rule 31 (stmt -> expr_stmt .)
    RETURN          reduce using rule 31 (stmt -> expr_stmt .)
    IF              reduce using rule 31 (stmt -> expr_stmt .)
    {               reduce using rule 31 (stmt -> expr_stmt .)
    (               reduce using rule 31 (stmt -> expr_stmt .)
    +               reduce using rule 31 (stmt -> expr_stmt .)
    !               reduce using rule 31 (stmt -> expr_stmt .)
    -               reduce using rule 31 (stmt -> expr_stmt .)
    STRINGLIT       reduce using rule 31 (stmt -> expr_stmt .)
    BOOLIT          reduce using rule 31 (stmt -> expr_stmt .)
    FLOATLIT        reduce using rule 31 (stmt -> expr_stmt .)
    INTLIT          reduce using rule 31 (stmt -> expr_stmt .)
    )               reduce using rule 31 (stmt -> expr_stmt .)
    ELSE            reduce using rule 31 (stmt -> expr_stmt .)


state 105

    (40) public_stmt -> PUBLIC . : stmt
    :               shift and go to state 122


state 106

    (39) private_stmt -> PRIVATE . : stmt
    :               shift and go to state 123


state 107

    (51) this_stmt -> THIS . ;
    ;               shift and go to state 124


state 108

    (50) print_stmt -> PRINTF . ( expr ) ;
    (               shift and go to state 125


state 109

    (45) continue_stmt -> CONTINUE . ;
    ;               shift and go to state 126


state 110

    (44) break_stmt -> BREAK . ;
    ;               shift and go to state 127


state 111

    (43) while_stmt -> WHILE . ( stmt ) expr
    (               shift and go to state 128


state 112

    (41) return_stmt -> RETURN . expr ;
    (42) return_stmt -> RETURN . ;
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    ;               shift and go to state 130
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 129

state 113

    (33) if_stmt -> IF . ( expr ) { stmt } ELSE { stmt }
    (34) if_stmt -> IF . ( expr ) stmt ELSE { stmt }
    (35) if_stmt -> IF . ( expr ) { stmt } ELSE stmt
    (36) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (37) if_stmt -> IF . ( expr ) { stmt }
    (38) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 131


state 114

    (10) param -> type_spec IDENT [ . INTLIT ]
    INTLIT          shift and go to state 132


state 115

    (47) args_list -> args_list , expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    )               reduce using rule 47 (args_list -> args_list , expr .)
    ,               reduce using rule 47 (args_list -> args_list , expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47
    NE              shift and go to state 48
    EQ              shift and go to state 49
    AND             shift and go to state 50
    OR              shift and go to state 51


state 116

    (81) expr -> IDENT [ expr ] = . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 133

state 117

    (12) compound_stmt -> { local_decls stmt_list } .
    STRING          reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT           reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    PUBLIC          reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    PRIVATE         reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    THIS            reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    IDENT           reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    PRINTF          reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    CONTINUE        reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    STRINGLIT       reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    BOOLIT          reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    FLOATLIT        reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    INTLIT          reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    )               reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 12 (compound_stmt -> { local_decls stmt_list } .)


state 118

    (17) stmt_list -> stmt_list stmt .
    }               reduce using rule 17 (stmt_list -> stmt_list stmt .)
    PUBLIC          reduce using rule 17 (stmt_list -> stmt_list stmt .)
    PRIVATE         reduce using rule 17 (stmt_list -> stmt_list stmt .)
    THIS            reduce using rule 17 (stmt_list -> stmt_list stmt .)
    IDENT           reduce using rule 17 (stmt_list -> stmt_list stmt .)
    PRINTF          reduce using rule 17 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 17 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 17 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 17 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 17 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 17 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 17 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 17 (stmt_list -> stmt_list stmt .)
    +               reduce using rule 17 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 17 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 17 (stmt_list -> stmt_list stmt .)
    STRINGLIT       reduce using rule 17 (stmt_list -> stmt_list stmt .)
    BOOLIT          reduce using rule 17 (stmt_list -> stmt_list stmt .)
    FLOATLIT        reduce using rule 17 (stmt_list -> stmt_list stmt .)
    INTLIT          reduce using rule 17 (stmt_list -> stmt_list stmt .)


state 119

    (52) var_decl -> type_spec IDENT . [ INTLIT ] ;
    (53) var_decl -> type_spec IDENT . = expr ;
    (54) var_decl -> type_spec IDENT . ;
    [               shift and go to state 15
    =               shift and go to state 17
    ;               shift and go to state 16


state 120

    (46) new_stmt -> IDENT = . NEW IDENT ( args_list ) ;
    (82) expr -> IDENT = . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    NEW             shift and go to state 134
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 65

state 121

    (32) expr_stmt -> expr ; .
    }               reduce using rule 32 (expr_stmt -> expr ; .)
    PUBLIC          reduce using rule 32 (expr_stmt -> expr ; .)
    PRIVATE         reduce using rule 32 (expr_stmt -> expr ; .)
    THIS            reduce using rule 32 (expr_stmt -> expr ; .)
    IDENT           reduce using rule 32 (expr_stmt -> expr ; .)
    PRINTF          reduce using rule 32 (expr_stmt -> expr ; .)
    CONTINUE        reduce using rule 32 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 32 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 32 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 32 (expr_stmt -> expr ; .)
    IF              reduce using rule 32 (expr_stmt -> expr ; .)
    {               reduce using rule 32 (expr_stmt -> expr ; .)
    (               reduce using rule 32 (expr_stmt -> expr ; .)
    +               reduce using rule 32 (expr_stmt -> expr ; .)
    !               reduce using rule 32 (expr_stmt -> expr ; .)
    -               reduce using rule 32 (expr_stmt -> expr ; .)
    STRINGLIT       reduce using rule 32 (expr_stmt -> expr ; .)
    BOOLIT          reduce using rule 32 (expr_stmt -> expr ; .)
    FLOATLIT        reduce using rule 32 (expr_stmt -> expr ; .)
    INTLIT          reduce using rule 32 (expr_stmt -> expr ; .)
    )               reduce using rule 32 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 32 (expr_stmt -> expr ; .)


state 122

    (40) public_stmt -> PUBLIC : . stmt
    (20) stmt -> . public_stmt
    (21) stmt -> . private_stmt
    (22) stmt -> . this_stmt
    (23) stmt -> . new_stmt
    (24) stmt -> . print_stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . while_stmt
    (28) stmt -> . return_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (40) public_stmt -> . PUBLIC : stmt
    (39) private_stmt -> . PRIVATE : stmt
    (51) this_stmt -> . THIS ;
    (46) new_stmt -> . IDENT = NEW IDENT ( args_list ) ;
    (50) print_stmt -> . PRINTF ( expr ) ;
    (45) continue_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (43) while_stmt -> . WHILE ( stmt ) expr
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (33) if_stmt -> . IF ( expr ) { stmt } ELSE { stmt }
    (34) if_stmt -> . IF ( expr ) stmt ELSE { stmt }
    (35) if_stmt -> . IF ( expr ) { stmt } ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (37) if_stmt -> . IF ( expr ) { stmt }
    (38) if_stmt -> . IF ( expr ) stmt
    (12) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . expr ;
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    PUBLIC          shift and go to state 105
    PRIVATE         shift and go to state 106
    THIS            shift and go to state 107
    IDENT           shift and go to state 91
    PRINTF          shift and go to state 108
    CONTINUE        shift and go to state 109
    BREAK           shift and go to state 110
    WHILE           shift and go to state 111
    RETURN          shift and go to state 112
    IF              shift and go to state 113
    {               shift and go to state 57
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    stmt                           shift and go to state 135
    public_stmt                    shift and go to state 93
    private_stmt                   shift and go to state 94
    this_stmt                      shift and go to state 95
    new_stmt                       shift and go to state 96
    print_stmt                     shift and go to state 97
    continue_stmt                  shift and go to state 98
    break_stmt                     shift and go to state 99
    while_stmt                     shift and go to state 100
    return_stmt                    shift and go to state 101
    if_stmt                        shift and go to state 102
    compound_stmt                  shift and go to state 103
    expr_stmt                      shift and go to state 104
    expr                           shift and go to state 92

state 123

    (39) private_stmt -> PRIVATE : . stmt
    (20) stmt -> . public_stmt
    (21) stmt -> . private_stmt
    (22) stmt -> . this_stmt
    (23) stmt -> . new_stmt
    (24) stmt -> . print_stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . while_stmt
    (28) stmt -> . return_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (40) public_stmt -> . PUBLIC : stmt
    (39) private_stmt -> . PRIVATE : stmt
    (51) this_stmt -> . THIS ;
    (46) new_stmt -> . IDENT = NEW IDENT ( args_list ) ;
    (50) print_stmt -> . PRINTF ( expr ) ;
    (45) continue_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (43) while_stmt -> . WHILE ( stmt ) expr
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (33) if_stmt -> . IF ( expr ) { stmt } ELSE { stmt }
    (34) if_stmt -> . IF ( expr ) stmt ELSE { stmt }
    (35) if_stmt -> . IF ( expr ) { stmt } ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (37) if_stmt -> . IF ( expr ) { stmt }
    (38) if_stmt -> . IF ( expr ) stmt
    (12) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . expr ;
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    PUBLIC          shift and go to state 105
    PRIVATE         shift and go to state 106
    THIS            shift and go to state 107
    IDENT           shift and go to state 91
    PRINTF          shift and go to state 108
    CONTINUE        shift and go to state 109
    BREAK           shift and go to state 110
    WHILE           shift and go to state 111
    RETURN          shift and go to state 112
    IF              shift and go to state 113
    {               shift and go to state 57
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    stmt                           shift and go to state 136
    public_stmt                    shift and go to state 93
    private_stmt                   shift and go to state 94
    this_stmt                      shift and go to state 95
    new_stmt                       shift and go to state 96
    print_stmt                     shift and go to state 97
    continue_stmt                  shift and go to state 98
    break_stmt                     shift and go to state 99
    while_stmt                     shift and go to state 100
    return_stmt                    shift and go to state 101
    if_stmt                        shift and go to state 102
    compound_stmt                  shift and go to state 103
    expr_stmt                      shift and go to state 104
    expr                           shift and go to state 92

state 124

    (51) this_stmt -> THIS ; .
    }               reduce using rule 51 (this_stmt -> THIS ; .)
    PUBLIC          reduce using rule 51 (this_stmt -> THIS ; .)
    PRIVATE         reduce using rule 51 (this_stmt -> THIS ; .)
    THIS            reduce using rule 51 (this_stmt -> THIS ; .)
    IDENT           reduce using rule 51 (this_stmt -> THIS ; .)
    PRINTF          reduce using rule 51 (this_stmt -> THIS ; .)
    CONTINUE        reduce using rule 51 (this_stmt -> THIS ; .)
    BREAK           reduce using rule 51 (this_stmt -> THIS ; .)
    WHILE           reduce using rule 51 (this_stmt -> THIS ; .)
    RETURN          reduce using rule 51 (this_stmt -> THIS ; .)
    IF              reduce using rule 51 (this_stmt -> THIS ; .)
    {               reduce using rule 51 (this_stmt -> THIS ; .)
    (               reduce using rule 51 (this_stmt -> THIS ; .)
    +               reduce using rule 51 (this_stmt -> THIS ; .)
    !               reduce using rule 51 (this_stmt -> THIS ; .)
    -               reduce using rule 51 (this_stmt -> THIS ; .)
    STRINGLIT       reduce using rule 51 (this_stmt -> THIS ; .)
    BOOLIT          reduce using rule 51 (this_stmt -> THIS ; .)
    FLOATLIT        reduce using rule 51 (this_stmt -> THIS ; .)
    INTLIT          reduce using rule 51 (this_stmt -> THIS ; .)
    )               reduce using rule 51 (this_stmt -> THIS ; .)
    ELSE            reduce using rule 51 (this_stmt -> THIS ; .)


state 125

    (50) print_stmt -> PRINTF ( . expr ) ;
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 137

state 126

    (45) continue_stmt -> CONTINUE ; .
    }               reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    PUBLIC          reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    PRIVATE         reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    THIS            reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    IDENT           reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    PRINTF          reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    IF              reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    {               reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    (               reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    +               reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    !               reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    -               reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    STRINGLIT       reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    BOOLIT          reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    FLOATLIT        reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    INTLIT          reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    )               reduce using rule 45 (continue_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 45 (continue_stmt -> CONTINUE ; .)


state 127

    (44) break_stmt -> BREAK ; .
    }               reduce using rule 44 (break_stmt -> BREAK ; .)
    PUBLIC          reduce using rule 44 (break_stmt -> BREAK ; .)
    PRIVATE         reduce using rule 44 (break_stmt -> BREAK ; .)
    THIS            reduce using rule 44 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 44 (break_stmt -> BREAK ; .)
    PRINTF          reduce using rule 44 (break_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 44 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 44 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 44 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 44 (break_stmt -> BREAK ; .)
    IF              reduce using rule 44 (break_stmt -> BREAK ; .)
    {               reduce using rule 44 (break_stmt -> BREAK ; .)
    (               reduce using rule 44 (break_stmt -> BREAK ; .)
    +               reduce using rule 44 (break_stmt -> BREAK ; .)
    !               reduce using rule 44 (break_stmt -> BREAK ; .)
    -               reduce using rule 44 (break_stmt -> BREAK ; .)
    STRINGLIT       reduce using rule 44 (break_stmt -> BREAK ; .)
    BOOLIT          reduce using rule 44 (break_stmt -> BREAK ; .)
    FLOATLIT        reduce using rule 44 (break_stmt -> BREAK ; .)
    INTLIT          reduce using rule 44 (break_stmt -> BREAK ; .)
    )               reduce using rule 44 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 44 (break_stmt -> BREAK ; .)


state 128

    (43) while_stmt -> WHILE ( . stmt ) expr
    (20) stmt -> . public_stmt
    (21) stmt -> . private_stmt
    (22) stmt -> . this_stmt
    (23) stmt -> . new_stmt
    (24) stmt -> . print_stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . while_stmt
    (28) stmt -> . return_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (40) public_stmt -> . PUBLIC : stmt
    (39) private_stmt -> . PRIVATE : stmt
    (51) this_stmt -> . THIS ;
    (46) new_stmt -> . IDENT = NEW IDENT ( args_list ) ;
    (50) print_stmt -> . PRINTF ( expr ) ;
    (45) continue_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (43) while_stmt -> . WHILE ( stmt ) expr
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (33) if_stmt -> . IF ( expr ) { stmt } ELSE { stmt }
    (34) if_stmt -> . IF ( expr ) stmt ELSE { stmt }
    (35) if_stmt -> . IF ( expr ) { stmt } ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (37) if_stmt -> . IF ( expr ) { stmt }
    (38) if_stmt -> . IF ( expr ) stmt
    (12) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . expr ;
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    PUBLIC          shift and go to state 105
    PRIVATE         shift and go to state 106
    THIS            shift and go to state 107
    IDENT           shift and go to state 91
    PRINTF          shift and go to state 108
    CONTINUE        shift and go to state 109
    BREAK           shift and go to state 110
    WHILE           shift and go to state 111
    RETURN          shift and go to state 112
    IF              shift and go to state 113
    {               shift and go to state 57
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    stmt                           shift and go to state 138
    expr                           shift and go to state 92
    public_stmt                    shift and go to state 93
    private_stmt                   shift and go to state 94
    this_stmt                      shift and go to state 95
    new_stmt                       shift and go to state 96
    print_stmt                     shift and go to state 97
    continue_stmt                  shift and go to state 98
    break_stmt                     shift and go to state 99
    while_stmt                     shift and go to state 100
    return_stmt                    shift and go to state 101
    if_stmt                        shift and go to state 102
    compound_stmt                  shift and go to state 103
    expr_stmt                      shift and go to state 104

state 129

    (41) return_stmt -> RETURN expr . ;
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               shift and go to state 139
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47
    NE              shift and go to state 48
    EQ              shift and go to state 49
    AND             shift and go to state 50
    OR              shift and go to state 51


state 130

    (42) return_stmt -> RETURN ; .
    }               reduce using rule 42 (return_stmt -> RETURN ; .)
    PUBLIC          reduce using rule 42 (return_stmt -> RETURN ; .)
    PRIVATE         reduce using rule 42 (return_stmt -> RETURN ; .)
    THIS            reduce using rule 42 (return_stmt -> RETURN ; .)
    IDENT           reduce using rule 42 (return_stmt -> RETURN ; .)
    PRINTF          reduce using rule 42 (return_stmt -> RETURN ; .)
    CONTINUE        reduce using rule 42 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 42 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 42 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 42 (return_stmt -> RETURN ; .)
    IF              reduce using rule 42 (return_stmt -> RETURN ; .)
    {               reduce using rule 42 (return_stmt -> RETURN ; .)
    (               reduce using rule 42 (return_stmt -> RETURN ; .)
    +               reduce using rule 42 (return_stmt -> RETURN ; .)
    !               reduce using rule 42 (return_stmt -> RETURN ; .)
    -               reduce using rule 42 (return_stmt -> RETURN ; .)
    STRINGLIT       reduce using rule 42 (return_stmt -> RETURN ; .)
    BOOLIT          reduce using rule 42 (return_stmt -> RETURN ; .)
    FLOATLIT        reduce using rule 42 (return_stmt -> RETURN ; .)
    INTLIT          reduce using rule 42 (return_stmt -> RETURN ; .)
    )               reduce using rule 42 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 42 (return_stmt -> RETURN ; .)


state 131

    (33) if_stmt -> IF ( . expr ) { stmt } ELSE { stmt }
    (34) if_stmt -> IF ( . expr ) stmt ELSE { stmt }
    (35) if_stmt -> IF ( . expr ) { stmt } ELSE stmt
    (36) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (37) if_stmt -> IF ( . expr ) { stmt }
    (38) if_stmt -> IF ( . expr ) stmt
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 140

state 132

    (10) param -> type_spec IDENT [ INTLIT . ]
    ]               shift and go to state 141


state 133

    (81) expr -> IDENT [ expr ] = expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    ;               reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    )               reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    ]               reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    ,               reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    }               reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    PUBLIC          reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    PRIVATE         reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    THIS            reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    IDENT           reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    PRINTF          reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    CONTINUE        reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    BREAK           reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    WHILE           reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    RETURN          reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    IF              reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    {               reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    (               reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    !               reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    STRINGLIT       reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    BOOLIT          reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    FLOATLIT        reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    INTLIT          reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    ELSE            reduce using rule 81 (expr -> IDENT [ expr ] = expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47
    NE              shift and go to state 48
    EQ              shift and go to state 49
    AND             shift and go to state 50
    OR              shift and go to state 51


state 134

    (46) new_stmt -> IDENT = NEW . IDENT ( args_list ) ;
    IDENT           shift and go to state 142


state 135

    (40) public_stmt -> PUBLIC : stmt .
    }               reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    PUBLIC          reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    PRIVATE         reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    THIS            reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    IDENT           reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    PRINTF          reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    CONTINUE        reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    BREAK           reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    WHILE           reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    RETURN          reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    IF              reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    {               reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    (               reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    +               reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    !               reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    -               reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    STRINGLIT       reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    BOOLIT          reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    FLOATLIT        reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    INTLIT          reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    )               reduce using rule 40 (public_stmt -> PUBLIC : stmt .)
    ELSE            reduce using rule 40 (public_stmt -> PUBLIC : stmt .)


state 136

    (39) private_stmt -> PRIVATE : stmt .
    }               reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    PUBLIC          reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    PRIVATE         reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    THIS            reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    IDENT           reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    PRINTF          reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    CONTINUE        reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    BREAK           reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    WHILE           reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    RETURN          reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    IF              reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    {               reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    (               reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    +               reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    !               reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    -               reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    STRINGLIT       reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    BOOLIT          reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    FLOATLIT        reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    INTLIT          reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    )               reduce using rule 39 (private_stmt -> PRIVATE : stmt .)
    ELSE            reduce using rule 39 (private_stmt -> PRIVATE : stmt .)


state 137

    (50) print_stmt -> PRINTF ( expr . ) ;
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    )               shift and go to state 143
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47
    NE              shift and go to state 48
    EQ              shift and go to state 49
    AND             shift and go to state 50
    OR              shift and go to state 51


state 138

    (43) while_stmt -> WHILE ( stmt . ) expr
    )               shift and go to state 144


state 139

    (41) return_stmt -> RETURN expr ; .
    }               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    PUBLIC          reduce using rule 41 (return_stmt -> RETURN expr ; .)
    PRIVATE         reduce using rule 41 (return_stmt -> RETURN expr ; .)
    THIS            reduce using rule 41 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 41 (return_stmt -> RETURN expr ; .)
    PRINTF          reduce using rule 41 (return_stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 41 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 41 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 41 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 41 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 41 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    STRINGLIT       reduce using rule 41 (return_stmt -> RETURN expr ; .)
    BOOLIT          reduce using rule 41 (return_stmt -> RETURN expr ; .)
    FLOATLIT        reduce using rule 41 (return_stmt -> RETURN expr ; .)
    INTLIT          reduce using rule 41 (return_stmt -> RETURN expr ; .)
    )               reduce using rule 41 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 41 (return_stmt -> RETURN expr ; .)


state 140

    (33) if_stmt -> IF ( expr . ) { stmt } ELSE { stmt }
    (34) if_stmt -> IF ( expr . ) stmt ELSE { stmt }
    (35) if_stmt -> IF ( expr . ) { stmt } ELSE stmt
    (36) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (37) if_stmt -> IF ( expr . ) { stmt }
    (38) if_stmt -> IF ( expr . ) stmt
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
    )               shift and go to state 145
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47
    NE              shift and go to state 48
    EQ              shift and go to state 49
    AND             shift and go to state 50
    OR              shift and go to state 51


state 141

    (10) param -> type_spec IDENT [ INTLIT ] .
    )               reduce using rule 10 (param -> type_spec IDENT [ INTLIT ] .)
    ,               reduce using rule 10 (param -> type_spec IDENT [ INTLIT ] .)


state 142

    (46) new_stmt -> IDENT = NEW IDENT . ( args_list ) ;
    (               shift and go to state 146


state 143

    (50) print_stmt -> PRINTF ( expr ) . ;
    ;               shift and go to state 147


state 144

    (43) while_stmt -> WHILE ( stmt ) . expr
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    IDENT           shift and go to state 21
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 148

state 145

    (33) if_stmt -> IF ( expr ) . { stmt } ELSE { stmt }
    (34) if_stmt -> IF ( expr ) . stmt ELSE { stmt }
    (35) if_stmt -> IF ( expr ) . { stmt } ELSE stmt
    (36) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (37) if_stmt -> IF ( expr ) . { stmt }
    (38) if_stmt -> IF ( expr ) . stmt
    (20) stmt -> . public_stmt
    (21) stmt -> . private_stmt
    (22) stmt -> . this_stmt
    (23) stmt -> . new_stmt
    (24) stmt -> . print_stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . while_stmt
    (28) stmt -> . return_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (40) public_stmt -> . PUBLIC : stmt
    (39) private_stmt -> . PRIVATE : stmt
    (51) this_stmt -> . THIS ;
    (46) new_stmt -> . IDENT = NEW IDENT ( args_list ) ;
    (50) print_stmt -> . PRINTF ( expr ) ;
    (45) continue_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (43) while_stmt -> . WHILE ( stmt ) expr
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (33) if_stmt -> . IF ( expr ) { stmt } ELSE { stmt }
    (34) if_stmt -> . IF ( expr ) stmt ELSE { stmt }
    (35) if_stmt -> . IF ( expr ) { stmt } ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (37) if_stmt -> . IF ( expr ) { stmt }
    (38) if_stmt -> . IF ( expr ) stmt
    (12) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . expr ;
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    {               shift and go to state 149
    PUBLIC          shift and go to state 105
    PRIVATE         shift and go to state 106
    THIS            shift and go to state 107
    IDENT           shift and go to state 91
    PRINTF          shift and go to state 108
    CONTINUE        shift and go to state 109
    BREAK           shift and go to state 110
    WHILE           shift and go to state 111
    RETURN          shift and go to state 112
    IF              shift and go to state 113
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 92
    stmt                           shift and go to state 150
    public_stmt                    shift and go to state 93
    private_stmt                   shift and go to state 94
    this_stmt                      shift and go to state 95
    new_stmt                       shift and go to state 96
    print_stmt                     shift and go to state 97
    continue_stmt                  shift and go to state 98
    break_stmt                     shift and go to state 99
    while_stmt                     shift and go to state 100
    return_stmt                    shift and go to state 101
    if_stmt                        shift and go to state 102
    compound_stmt                  shift and go to state 103
    expr_stmt                      shift and go to state 104

state 146

    (46) new_stmt -> IDENT = NEW IDENT ( . args_list ) ;
    (47) args_list -> . args_list , expr
    (48) args_list -> . empty
    (49) args_list -> . args_list
    (87) empty -> .
    )               reduce using rule 87 (empty -> .)
    ,               reduce using rule 87 (empty -> .)

    args_list                      shift and go to state 151
    empty                          shift and go to state 63

state 147

    (50) print_stmt -> PRINTF ( expr ) ; .
    }               reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    PUBLIC          reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    PRIVATE         reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    THIS            reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    IDENT           reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    PRINTF          reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    CONTINUE        reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    BREAK           reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    WHILE           reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    RETURN          reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    IF              reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    {               reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    (               reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    +               reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    !               reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    -               reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    STRINGLIT       reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    BOOLIT          reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    FLOATLIT        reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    INTLIT          reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    )               reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)
    ELSE            reduce using rule 50 (print_stmt -> PRINTF ( expr ) ; .)


state 148

    (43) while_stmt -> WHILE ( stmt ) expr .
    (65) expr -> expr . % expr
    (66) expr -> expr . / expr
    (67) expr -> expr . * expr
    (68) expr -> expr . - expr
    (69) expr -> expr . + expr
    (70) expr -> expr . GE expr
    (71) expr -> expr . GT expr
    (72) expr -> expr . LE expr
    (73) expr -> expr . LT expr
    (74) expr -> expr . NE expr
    (75) expr -> expr . EQ expr
    (76) expr -> expr . AND expr
    (77) expr -> expr . OR expr
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
    }               reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    PUBLIC          reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    PRIVATE         reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    THIS            reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    IDENT           reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    PRINTF          reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    CONTINUE        reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    BREAK           reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    WHILE           reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    RETURN          reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    IF              reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    {               reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    (               reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    !               reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    STRINGLIT       reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    BOOLIT          reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    FLOATLIT        reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    INTLIT          reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    )               reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    ELSE            reduce using rule 43 (while_stmt -> WHILE ( stmt ) expr .)
    %               shift and go to state 39
    /               shift and go to state 40
    *               shift and go to state 41
    -               shift and go to state 42
    +               shift and go to state 43
    GE              shift and go to state 44
    GT              shift and go to state 45
    LE              shift and go to state 46
    LT              shift and go to state 47
    NE              shift and go to state 48
    EQ              shift and go to state 49
    AND             shift and go to state 50
    OR              shift and go to state 51


state 149

    (33) if_stmt -> IF ( expr ) { . stmt } ELSE { stmt }
    (35) if_stmt -> IF ( expr ) { . stmt } ELSE stmt
    (37) if_stmt -> IF ( expr ) { . stmt }
    (12) compound_stmt -> { . local_decls stmt_list }
    (20) stmt -> . public_stmt
    (21) stmt -> . private_stmt
    (22) stmt -> . this_stmt
    (23) stmt -> . new_stmt
    (24) stmt -> . print_stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . while_stmt
    (28) stmt -> . return_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (13) local_decls -> . local_decls var_decl
    (14) local_decls -> . empty
    (15) local_decls -> . local_decls
    (40) public_stmt -> . PUBLIC : stmt
    (39) private_stmt -> . PRIVATE : stmt
    (51) this_stmt -> . THIS ;
    (46) new_stmt -> . IDENT = NEW IDENT ( args_list ) ;
    (50) print_stmt -> . PRINTF ( expr ) ;
    (45) continue_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (43) while_stmt -> . WHILE ( stmt ) expr
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (33) if_stmt -> . IF ( expr ) { stmt } ELSE { stmt }
    (34) if_stmt -> . IF ( expr ) stmt ELSE { stmt }
    (35) if_stmt -> . IF ( expr ) { stmt } ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (37) if_stmt -> . IF ( expr ) { stmt }
    (38) if_stmt -> . IF ( expr ) stmt
    (12) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . expr ;
    (87) empty -> .
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for ! resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for STRINGLIT resolved as shift
  ! shift/reduce conflict for BOOLIT resolved as shift
  ! shift/reduce conflict for FLOATLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
    PUBLIC          shift and go to state 105
    PRIVATE         shift and go to state 106
    THIS            shift and go to state 107
    IDENT           shift and go to state 91
    PRINTF          shift and go to state 108
    CONTINUE        shift and go to state 109
    BREAK           shift and go to state 110
    WHILE           shift and go to state 111
    RETURN          shift and go to state 112
    IF              shift and go to state 113
    {               shift and go to state 57
    STRING          reduce using rule 87 (empty -> .)
    BOOL            reduce using rule 87 (empty -> .)
    FLOAT           reduce using rule 87 (empty -> .)
    INT             reduce using rule 87 (empty -> .)
    VOID            reduce using rule 87 (empty -> .)
    }               reduce using rule 87 (empty -> .)
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 92
    stmt                           shift and go to state 152
    local_decls                    shift and go to state 80
    public_stmt                    shift and go to state 93
    private_stmt                   shift and go to state 94
    this_stmt                      shift and go to state 95
    new_stmt                       shift and go to state 96
    print_stmt                     shift and go to state 97
    continue_stmt                  shift and go to state 98
    break_stmt                     shift and go to state 99
    while_stmt                     shift and go to state 100
    return_stmt                    shift and go to state 101
    if_stmt                        shift and go to state 102
    compound_stmt                  shift and go to state 103
    expr_stmt                      shift and go to state 104
    empty                          shift and go to state 81

state 150

    (34) if_stmt -> IF ( expr ) stmt . ELSE { stmt }
    (36) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (38) if_stmt -> IF ( expr ) stmt .
  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 153
    }               reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    PUBLIC          reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    PRIVATE         reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    THIS            reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    PRINTF          reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    STRINGLIT       reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    BOOLIT          reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    FLOATLIT        reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    INTLIT          reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)
    )               reduce using rule 38 (if_stmt -> IF ( expr ) stmt .)


state 151

    (46) new_stmt -> IDENT = NEW IDENT ( args_list . ) ;
    (47) args_list -> args_list . , expr
    (49) args_list -> args_list .
  ! shift/reduce conflict for ) resolved as shift
  ! shift/reduce conflict for , resolved as shift
    )               shift and go to state 154
    ,               shift and go to state 84


state 152

    (33) if_stmt -> IF ( expr ) { stmt . } ELSE { stmt }
    (35) if_stmt -> IF ( expr ) { stmt . } ELSE stmt
    (37) if_stmt -> IF ( expr ) { stmt . }
    }               shift and go to state 155


state 153

    (34) if_stmt -> IF ( expr ) stmt ELSE . { stmt }
    (36) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (20) stmt -> . public_stmt
    (21) stmt -> . private_stmt
    (22) stmt -> . this_stmt
    (23) stmt -> . new_stmt
    (24) stmt -> . print_stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . while_stmt
    (28) stmt -> . return_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (40) public_stmt -> . PUBLIC : stmt
    (39) private_stmt -> . PRIVATE : stmt
    (51) this_stmt -> . THIS ;
    (46) new_stmt -> . IDENT = NEW IDENT ( args_list ) ;
    (50) print_stmt -> . PRINTF ( expr ) ;
    (45) continue_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (43) while_stmt -> . WHILE ( stmt ) expr
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (33) if_stmt -> . IF ( expr ) { stmt } ELSE { stmt }
    (34) if_stmt -> . IF ( expr ) stmt ELSE { stmt }
    (35) if_stmt -> . IF ( expr ) { stmt } ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (37) if_stmt -> . IF ( expr ) { stmt }
    (38) if_stmt -> . IF ( expr ) stmt
    (12) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . expr ;
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    {               shift and go to state 157
    PUBLIC          shift and go to state 105
    PRIVATE         shift and go to state 106
    THIS            shift and go to state 107
    IDENT           shift and go to state 91
    PRINTF          shift and go to state 108
    CONTINUE        shift and go to state 109
    BREAK           shift and go to state 110
    WHILE           shift and go to state 111
    RETURN          shift and go to state 112
    IF              shift and go to state 113
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 92
    stmt                           shift and go to state 156
    public_stmt                    shift and go to state 93
    private_stmt                   shift and go to state 94
    this_stmt                      shift and go to state 95
    new_stmt                       shift and go to state 96
    print_stmt                     shift and go to state 97
    continue_stmt                  shift and go to state 98
    break_stmt                     shift and go to state 99
    while_stmt                     shift and go to state 100
    return_stmt                    shift and go to state 101
    if_stmt                        shift and go to state 102
    compound_stmt                  shift and go to state 103
    expr_stmt                      shift and go to state 104

state 154

    (46) new_stmt -> IDENT = NEW IDENT ( args_list ) . ;
    ;               shift and go to state 158


state 155

    (33) if_stmt -> IF ( expr ) { stmt } . ELSE { stmt }
    (35) if_stmt -> IF ( expr ) { stmt } . ELSE stmt
    (37) if_stmt -> IF ( expr ) { stmt } .
  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 159
    }               reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    PUBLIC          reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    PRIVATE         reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    THIS            reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    IDENT           reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    PRINTF          reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    CONTINUE        reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    BREAK           reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    WHILE           reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    RETURN          reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    IF              reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    {               reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    (               reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    +               reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    !               reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    -               reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    STRINGLIT       reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    BOOLIT          reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    FLOATLIT        reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    INTLIT          reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)
    )               reduce using rule 37 (if_stmt -> IF ( expr ) { stmt } .)


state 156

    (36) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PUBLIC          reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PRIVATE         reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    THIS            reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINTF          reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRINGLIT       reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOLIT          reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOATLIT        reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INTLIT          reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    )               reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 36 (if_stmt -> IF ( expr ) stmt ELSE stmt .)


state 157

    (34) if_stmt -> IF ( expr ) stmt ELSE { . stmt }
    (12) compound_stmt -> { . local_decls stmt_list }
    (20) stmt -> . public_stmt
    (21) stmt -> . private_stmt
    (22) stmt -> . this_stmt
    (23) stmt -> . new_stmt
    (24) stmt -> . print_stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . while_stmt
    (28) stmt -> . return_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (13) local_decls -> . local_decls var_decl
    (14) local_decls -> . empty
    (15) local_decls -> . local_decls
    (40) public_stmt -> . PUBLIC : stmt
    (39) private_stmt -> . PRIVATE : stmt
    (51) this_stmt -> . THIS ;
    (46) new_stmt -> . IDENT = NEW IDENT ( args_list ) ;
    (50) print_stmt -> . PRINTF ( expr ) ;
    (45) continue_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (43) while_stmt -> . WHILE ( stmt ) expr
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (33) if_stmt -> . IF ( expr ) { stmt } ELSE { stmt }
    (34) if_stmt -> . IF ( expr ) stmt ELSE { stmt }
    (35) if_stmt -> . IF ( expr ) { stmt } ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (37) if_stmt -> . IF ( expr ) { stmt }
    (38) if_stmt -> . IF ( expr ) stmt
    (12) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . expr ;
    (87) empty -> .
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for ! resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for STRINGLIT resolved as shift
  ! shift/reduce conflict for BOOLIT resolved as shift
  ! shift/reduce conflict for FLOATLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
    PUBLIC          shift and go to state 105
    PRIVATE         shift and go to state 106
    THIS            shift and go to state 107
    IDENT           shift and go to state 91
    PRINTF          shift and go to state 108
    CONTINUE        shift and go to state 109
    BREAK           shift and go to state 110
    WHILE           shift and go to state 111
    RETURN          shift and go to state 112
    IF              shift and go to state 113
    {               shift and go to state 57
    STRING          reduce using rule 87 (empty -> .)
    BOOL            reduce using rule 87 (empty -> .)
    FLOAT           reduce using rule 87 (empty -> .)
    INT             reduce using rule 87 (empty -> .)
    VOID            reduce using rule 87 (empty -> .)
    }               reduce using rule 87 (empty -> .)
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 92
    stmt                           shift and go to state 160
    local_decls                    shift and go to state 80
    public_stmt                    shift and go to state 93
    private_stmt                   shift and go to state 94
    this_stmt                      shift and go to state 95
    new_stmt                       shift and go to state 96
    print_stmt                     shift and go to state 97
    continue_stmt                  shift and go to state 98
    break_stmt                     shift and go to state 99
    while_stmt                     shift and go to state 100
    return_stmt                    shift and go to state 101
    if_stmt                        shift and go to state 102
    compound_stmt                  shift and go to state 103
    expr_stmt                      shift and go to state 104
    empty                          shift and go to state 81

state 158

    (46) new_stmt -> IDENT = NEW IDENT ( args_list ) ; .
    }               reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    PUBLIC          reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    PRIVATE         reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    THIS            reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    IDENT           reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    PRINTF          reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    CONTINUE        reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    BREAK           reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    WHILE           reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    RETURN          reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    IF              reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    {               reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    (               reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    +               reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    !               reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    -               reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    STRINGLIT       reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    BOOLIT          reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    FLOATLIT        reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    INTLIT          reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    )               reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)
    ELSE            reduce using rule 46 (new_stmt -> IDENT = NEW IDENT ( args_list ) ; .)


state 159

    (33) if_stmt -> IF ( expr ) { stmt } ELSE . { stmt }
    (35) if_stmt -> IF ( expr ) { stmt } ELSE . stmt
    (20) stmt -> . public_stmt
    (21) stmt -> . private_stmt
    (22) stmt -> . this_stmt
    (23) stmt -> . new_stmt
    (24) stmt -> . print_stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . while_stmt
    (28) stmt -> . return_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (40) public_stmt -> . PUBLIC : stmt
    (39) private_stmt -> . PRIVATE : stmt
    (51) this_stmt -> . THIS ;
    (46) new_stmt -> . IDENT = NEW IDENT ( args_list ) ;
    (50) print_stmt -> . PRINTF ( expr ) ;
    (45) continue_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (43) while_stmt -> . WHILE ( stmt ) expr
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (33) if_stmt -> . IF ( expr ) { stmt } ELSE { stmt }
    (34) if_stmt -> . IF ( expr ) stmt ELSE { stmt }
    (35) if_stmt -> . IF ( expr ) { stmt } ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (37) if_stmt -> . IF ( expr ) { stmt }
    (38) if_stmt -> . IF ( expr ) stmt
    (12) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . expr ;
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
    {               shift and go to state 161
    PUBLIC          shift and go to state 105
    PRIVATE         shift and go to state 106
    THIS            shift and go to state 107
    IDENT           shift and go to state 91
    PRINTF          shift and go to state 108
    CONTINUE        shift and go to state 109
    BREAK           shift and go to state 110
    WHILE           shift and go to state 111
    RETURN          shift and go to state 112
    IF              shift and go to state 113
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 92
    stmt                           shift and go to state 162
    public_stmt                    shift and go to state 93
    private_stmt                   shift and go to state 94
    this_stmt                      shift and go to state 95
    new_stmt                       shift and go to state 96
    print_stmt                     shift and go to state 97
    continue_stmt                  shift and go to state 98
    break_stmt                     shift and go to state 99
    while_stmt                     shift and go to state 100
    return_stmt                    shift and go to state 101
    if_stmt                        shift and go to state 102
    compound_stmt                  shift and go to state 103
    expr_stmt                      shift and go to state 104

state 160

    (34) if_stmt -> IF ( expr ) stmt ELSE { stmt . }
    }               shift and go to state 163


state 161

    (33) if_stmt -> IF ( expr ) { stmt } ELSE { . stmt }
    (12) compound_stmt -> { . local_decls stmt_list }
    (20) stmt -> . public_stmt
    (21) stmt -> . private_stmt
    (22) stmt -> . this_stmt
    (23) stmt -> . new_stmt
    (24) stmt -> . print_stmt
    (25) stmt -> . continue_stmt
    (26) stmt -> . break_stmt
    (27) stmt -> . while_stmt
    (28) stmt -> . return_stmt
    (29) stmt -> . if_stmt
    (30) stmt -> . compound_stmt
    (31) stmt -> . expr_stmt
    (13) local_decls -> . local_decls var_decl
    (14) local_decls -> . empty
    (15) local_decls -> . local_decls
    (40) public_stmt -> . PUBLIC : stmt
    (39) private_stmt -> . PRIVATE : stmt
    (51) this_stmt -> . THIS ;
    (46) new_stmt -> . IDENT = NEW IDENT ( args_list ) ;
    (50) print_stmt -> . PRINTF ( expr ) ;
    (45) continue_stmt -> . CONTINUE ;
    (44) break_stmt -> . BREAK ;
    (43) while_stmt -> . WHILE ( stmt ) expr
    (41) return_stmt -> . RETURN expr ;
    (42) return_stmt -> . RETURN ;
    (33) if_stmt -> . IF ( expr ) { stmt } ELSE { stmt }
    (34) if_stmt -> . IF ( expr ) stmt ELSE { stmt }
    (35) if_stmt -> . IF ( expr ) { stmt } ELSE stmt
    (36) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (37) if_stmt -> . IF ( expr ) { stmt }
    (38) if_stmt -> . IF ( expr ) stmt
    (12) compound_stmt -> . { local_decls stmt_list }
    (32) expr_stmt -> . expr ;
    (87) empty -> .
    (60) expr -> . IDENT . SIZE
    (61) expr -> . ( expr )
    (62) expr -> . + expr
    (63) expr -> . ! expr
    (64) expr -> . - expr
    (65) expr -> . expr % expr
    (66) expr -> . expr / expr
    (67) expr -> . expr * expr
    (68) expr -> . expr - expr
    (69) expr -> . expr + expr
    (70) expr -> . expr GE expr
    (71) expr -> . expr GT expr
    (72) expr -> . expr LE expr
    (73) expr -> . expr LT expr
    (74) expr -> . expr NE expr
    (75) expr -> . expr EQ expr
    (76) expr -> . expr AND expr
    (77) expr -> . expr OR expr
    (78) expr -> . IDENT
    (79) expr -> . IDENT ( args_list )
    (80) expr -> . IDENT [ expr ]
    (81) expr -> . IDENT [ expr ] = expr
    (82) expr -> . IDENT = expr
    (83) expr -> . STRINGLIT
    (84) expr -> . BOOLIT
    (85) expr -> . FLOATLIT
    (86) expr -> . INTLIT
  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for ! resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for STRINGLIT resolved as shift
  ! shift/reduce conflict for BOOLIT resolved as shift
  ! shift/reduce conflict for FLOATLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
    PUBLIC          shift and go to state 105
    PRIVATE         shift and go to state 106
    THIS            shift and go to state 107
    IDENT           shift and go to state 91
    PRINTF          shift and go to state 108
    CONTINUE        shift and go to state 109
    BREAK           shift and go to state 110
    WHILE           shift and go to state 111
    RETURN          shift and go to state 112
    IF              shift and go to state 113
    {               shift and go to state 57
    STRING          reduce using rule 87 (empty -> .)
    BOOL            reduce using rule 87 (empty -> .)
    FLOAT           reduce using rule 87 (empty -> .)
    INT             reduce using rule 87 (empty -> .)
    VOID            reduce using rule 87 (empty -> .)
    }               reduce using rule 87 (empty -> .)
    (               shift and go to state 23
    +               shift and go to state 24
    !               shift and go to state 25
    -               shift and go to state 26
    STRINGLIT       shift and go to state 27
    BOOLIT          shift and go to state 28
    FLOATLIT        shift and go to state 29
    INTLIT          shift and go to state 30

    expr                           shift and go to state 92
    stmt                           shift and go to state 164
    local_decls                    shift and go to state 80
    public_stmt                    shift and go to state 93
    private_stmt                   shift and go to state 94
    this_stmt                      shift and go to state 95
    new_stmt                       shift and go to state 96
    print_stmt                     shift and go to state 97
    continue_stmt                  shift and go to state 98
    break_stmt                     shift and go to state 99
    while_stmt                     shift and go to state 100
    return_stmt                    shift and go to state 101
    if_stmt                        shift and go to state 102
    compound_stmt                  shift and go to state 103
    expr_stmt                      shift and go to state 104
    empty                          shift and go to state 81

state 162

    (35) if_stmt -> IF ( expr ) { stmt } ELSE stmt .
    }               reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    PUBLIC          reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    PRIVATE         reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    THIS            reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    IDENT           reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    PRINTF          reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    CONTINUE        reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    BREAK           reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    WHILE           reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    RETURN          reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    IF              reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    {               reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    (               reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    +               reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    !               reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    -               reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    STRINGLIT       reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    BOOLIT          reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    FLOATLIT        reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    INTLIT          reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    )               reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)
    ELSE            reduce using rule 35 (if_stmt -> IF ( expr ) { stmt } ELSE stmt .)


state 163

    (34) if_stmt -> IF ( expr ) stmt ELSE { stmt } .
    }               reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    PUBLIC          reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    PRIVATE         reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    THIS            reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    IDENT           reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    PRINTF          reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    CONTINUE        reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    BREAK           reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    WHILE           reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    RETURN          reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    IF              reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    {               reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    (               reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    +               reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    !               reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    -               reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    STRINGLIT       reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    BOOLIT          reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    FLOATLIT        reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    INTLIT          reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    )               reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)
    ELSE            reduce using rule 34 (if_stmt -> IF ( expr ) stmt ELSE { stmt } .)


state 164

    (33) if_stmt -> IF ( expr ) { stmt } ELSE { stmt . }
    }               shift and go to state 165


state 165

    (33) if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .
    }               reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    PUBLIC          reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    PRIVATE         reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    THIS            reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    IDENT           reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    PRINTF          reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    CONTINUE        reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    BREAK           reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    WHILE           reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    RETURN          reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    IF              reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    {               reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    (               reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    +               reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    !               reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    -               reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    STRINGLIT       reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    BOOLIT          reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    FLOATLIT        reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    INTLIT          reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    )               reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)
    ELSE            reduce using rule 33 (if_stmt -> IF ( expr ) { stmt } ELSE { stmt } .)


Conflicts:

shift/reduce conflict for ) in state 18 resolved as shift
shift/reduce conflict for , in state 18 resolved as shift
shift/reduce conflict for ( in state 21 resolved as shift
shift/reduce conflict for ) in state 62 resolved as shift
shift/reduce conflict for , in state 62 resolved as shift
shift/reduce conflict for STRING in state 80 resolved as shift
shift/reduce conflict for BOOL in state 80 resolved as shift
shift/reduce conflict for FLOAT in state 80 resolved as shift
shift/reduce conflict for INT in state 80 resolved as shift
shift/reduce conflict for VOID in state 80 resolved as shift
shift/reduce conflict for PUBLIC in state 80 resolved as shift
shift/reduce conflict for PRIVATE in state 80 resolved as shift
shift/reduce conflict for THIS in state 80 resolved as shift
shift/reduce conflict for IDENT in state 80 resolved as shift
shift/reduce conflict for PRINTF in state 80 resolved as shift
shift/reduce conflict for CONTINUE in state 80 resolved as shift
shift/reduce conflict for BREAK in state 80 resolved as shift
shift/reduce conflict for WHILE in state 80 resolved as shift
shift/reduce conflict for RETURN in state 80 resolved as shift
shift/reduce conflict for IF in state 80 resolved as shift
shift/reduce conflict for { in state 80 resolved as shift
shift/reduce conflict for ( in state 80 resolved as shift
shift/reduce conflict for + in state 80 resolved as shift
shift/reduce conflict for ! in state 80 resolved as shift
shift/reduce conflict for - in state 80 resolved as shift
shift/reduce conflict for STRINGLIT in state 80 resolved as shift
shift/reduce conflict for BOOLIT in state 80 resolved as shift
shift/reduce conflict for FLOATLIT in state 80 resolved as shift
shift/reduce conflict for INTLIT in state 80 resolved as shift
shift/reduce conflict for } in state 86 resolved as shift
shift/reduce conflict for PUBLIC in state 86 resolved as shift
shift/reduce conflict for PRIVATE in state 86 resolved as shift
shift/reduce conflict for THIS in state 86 resolved as shift
shift/reduce conflict for IDENT in state 86 resolved as shift
shift/reduce conflict for PRINTF in state 86 resolved as shift
shift/reduce conflict for CONTINUE in state 86 resolved as shift
shift/reduce conflict for BREAK in state 86 resolved as shift
shift/reduce conflict for WHILE in state 86 resolved as shift
shift/reduce conflict for RETURN in state 86 resolved as shift
shift/reduce conflict for IF in state 86 resolved as shift
shift/reduce conflict for { in state 86 resolved as shift
shift/reduce conflict for ( in state 86 resolved as shift
shift/reduce conflict for + in state 86 resolved as shift
shift/reduce conflict for ! in state 86 resolved as shift
shift/reduce conflict for - in state 86 resolved as shift
shift/reduce conflict for STRINGLIT in state 86 resolved as shift
shift/reduce conflict for BOOLIT in state 86 resolved as shift
shift/reduce conflict for FLOATLIT in state 86 resolved as shift
shift/reduce conflict for INTLIT in state 86 resolved as shift
shift/reduce conflict for - in state 148 resolved as shift
shift/reduce conflict for + in state 148 resolved as shift
shift/reduce conflict for PUBLIC in state 149 resolved as shift
shift/reduce conflict for PRIVATE in state 149 resolved as shift
shift/reduce conflict for THIS in state 149 resolved as shift
shift/reduce conflict for IDENT in state 149 resolved as shift
shift/reduce conflict for PRINTF in state 149 resolved as shift
shift/reduce conflict for CONTINUE in state 149 resolved as shift
shift/reduce conflict for BREAK in state 149 resolved as shift
shift/reduce conflict for WHILE in state 149 resolved as shift
shift/reduce conflict for RETURN in state 149 resolved as shift
shift/reduce conflict for IF in state 149 resolved as shift
shift/reduce conflict for { in state 149 resolved as shift
shift/reduce conflict for ( in state 149 resolved as shift
shift/reduce conflict for + in state 149 resolved as shift
shift/reduce conflict for ! in state 149 resolved as shift
shift/reduce conflict for - in state 149 resolved as shift
shift/reduce conflict for STRINGLIT in state 149 resolved as shift
shift/reduce conflict for BOOLIT in state 149 resolved as shift
shift/reduce conflict for FLOATLIT in state 149 resolved as shift
shift/reduce conflict for INTLIT in state 149 resolved as shift
shift/reduce conflict for ELSE in state 150 resolved as shift
shift/reduce conflict for ) in state 151 resolved as shift
shift/reduce conflict for , in state 151 resolved as shift
shift/reduce conflict for ELSE in state 155 resolved as shift
shift/reduce conflict for PUBLIC in state 157 resolved as shift
shift/reduce conflict for PRIVATE in state 157 resolved as shift
shift/reduce conflict for THIS in state 157 resolved as shift
shift/reduce conflict for IDENT in state 157 resolved as shift
shift/reduce conflict for PRINTF in state 157 resolved as shift
shift/reduce conflict for CONTINUE in state 157 resolved as shift
shift/reduce conflict for BREAK in state 157 resolved as shift
shift/reduce conflict for WHILE in state 157 resolved as shift
shift/reduce conflict for RETURN in state 157 resolved as shift
shift/reduce conflict for IF in state 157 resolved as shift
shift/reduce conflict for { in state 157 resolved as shift
shift/reduce conflict for ( in state 157 resolved as shift
shift/reduce conflict for + in state 157 resolved as shift
shift/reduce conflict for ! in state 157 resolved as shift
shift/reduce conflict for - in state 157 resolved as shift
shift/reduce conflict for STRINGLIT in state 157 resolved as shift
shift/reduce conflict for BOOLIT in state 157 resolved as shift
shift/reduce conflict for FLOATLIT in state 157 resolved as shift
shift/reduce conflict for INTLIT in state 157 resolved as shift
shift/reduce conflict for PUBLIC in state 161 resolved as shift
shift/reduce conflict for PRIVATE in state 161 resolved as shift
shift/reduce conflict for THIS in state 161 resolved as shift
shift/reduce conflict for IDENT in state 161 resolved as shift
shift/reduce conflict for PRINTF in state 161 resolved as shift
shift/reduce conflict for CONTINUE in state 161 resolved as shift
shift/reduce conflict for BREAK in state 161 resolved as shift
shift/reduce conflict for WHILE in state 161 resolved as shift
shift/reduce conflict for RETURN in state 161 resolved as shift
shift/reduce conflict for IF in state 161 resolved as shift
shift/reduce conflict for { in state 161 resolved as shift
shift/reduce conflict for ( in state 161 resolved as shift
shift/reduce conflict for + in state 161 resolved as shift
shift/reduce conflict for ! in state 161 resolved as shift
shift/reduce conflict for - in state 161 resolved as shift
shift/reduce conflict for STRINGLIT in state 161 resolved as shift
shift/reduce conflict for BOOLIT in state 161 resolved as shift
shift/reduce conflict for FLOATLIT in state 161 resolved as shift
shift/reduce conflict for INTLIT in state 161 resolved as shift
reduce/reduce conflict in state 80 resolved using rule local_decls -> local_decls
rejected rule (empty -> <empty>) in state 80