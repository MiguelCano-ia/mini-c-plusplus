Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> object_decl
Rule 5     decl -> class_decl
Rule 6     decl -> func_decl
Rule 7     decl -> var_decl
Rule 8     class_decl -> CLASS IDENT { class_body } ;
Rule 9     class_body -> empty
Rule 10    class_body -> class_member class_body
Rule 11    class_body -> access_specifier class_body
Rule 12    access_specifier -> PUBLIC :
Rule 13    access_specifier -> PRIVATE :
Rule 14    class_member -> constructor_decl
Rule 15    class_member -> method_decl
Rule 16    class_member -> var_decl
Rule 17    method_decl -> type_spec IDENT ( param_list ) compound_stmt
Rule 18    constructor_decl -> IDENT ( param_list ) compound_stmt
Rule 19    func_decl -> type_spec IDENT ( param_list ) compound_stmt
Rule 20    param_list -> param
Rule 21    param_list -> param_list , param
Rule 22    param_list -> empty
Rule 23    param -> type_spec IDENT [ INTLIT ]
Rule 24    param -> type_spec IDENT
Rule 25    compound_stmt -> { local_decls stmt_list }
Rule 26    local_decls -> empty
Rule 27    local_decls -> var_decl local_decls
Rule 28    stmt_list -> stmt stmt_list
Rule 29    stmt_list -> stmt local_decls stmt_list
Rule 30    stmt_list -> empty
Rule 31    stmt -> sprintf_stmt
Rule 32    stmt -> this_stmt
Rule 33    stmt -> for_stmt
Rule 34    stmt -> object_decl
Rule 35    stmt -> super_stmt
Rule 36    stmt -> print_stmt
Rule 37    stmt -> continue_stmt
Rule 38    stmt -> break_stmt
Rule 39    stmt -> while_stmt
Rule 40    stmt -> return_stmt
Rule 41    stmt -> if_stmt
Rule 42    stmt -> compound_stmt
Rule 43    stmt -> expr_stmt
Rule 44    for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt
Rule 45    for_init -> empty
Rule 46    for_init -> assignment_expr
Rule 47    for_init -> var_decl_no_semi
Rule 48    var_decl_no_semi -> type_spec IDENT [ expr ]
Rule 49    var_decl_no_semi -> type_spec IDENT = assignment_expr
Rule 50    var_decl_no_semi -> type_spec IDENT
Rule 51    for_cond -> empty
Rule 52    for_cond -> expr
Rule 53    for_incr -> empty
Rule 54    for_incr -> assignment_expr
Rule 55    super_stmt -> SUPER ( args_list ) ;
Rule 56    expr_stmt -> assignment_expr ;
Rule 57    assignment_expr -> IDENT [ expr ] = assignment_expr
Rule 58    assignment_expr -> expr
Rule 59    assignment_expr -> IDENT DIV_ASSIGN assignment_expr  [precedence=left, level=6]
Rule 60    assignment_expr -> IDENT MULT_ASSIGN assignment_expr  [precedence=left, level=6]
Rule 61    assignment_expr -> IDENT MINUS_ASSIGN assignment_expr  [precedence=left, level=6]
Rule 62    assignment_expr -> IDENT PLUS_ASSIGN assignment_expr  [precedence=left, level=6]
Rule 63    assignment_expr -> IDENT = assignment_expr
Rule 64    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=nonassoc, level=4]
Rule 65    if_stmt -> IF ( expr ) stmt  [precedence=nonassoc, level=3]
Rule 66    return_stmt -> RETURN expr ;
Rule 67    return_stmt -> RETURN ;
Rule 68    while_stmt -> WHILE ( expr ) stmt
Rule 69    break_stmt -> BREAK ;
Rule 70    continue_stmt -> CONTINUE ;
Rule 71    args_list -> expr
Rule 72    args_list -> args_list , expr
Rule 73    args_list -> empty
Rule 74    print_stmt -> PRINTF ( expr , args_list ) ;
Rule 75    sprintf_stmt -> SPRINTF ( expr , args_list ) ;
Rule 76    this_stmt -> THIS ;
Rule 77    var_decl -> type_spec IDENT [ expr ] ;
Rule 78    var_decl -> type_spec IDENT = assignment_expr ;
Rule 79    var_decl -> type_spec IDENT ;
Rule 80    object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ;
Rule 81    object_decl -> IDENT IDENT ;
Rule 82    type_spec -> STRING
Rule 83    type_spec -> BOOL
Rule 84    type_spec -> FLOAT
Rule 85    type_spec -> INT
Rule 86    type_spec -> VOID
Rule 87    expr -> logical_or_expr
Rule 88    logical_or_expr -> logical_and_expr
Rule 89    logical_or_expr -> logical_or_expr OR logical_and_expr
Rule 90    logical_and_expr -> equality_expr
Rule 91    logical_and_expr -> logical_and_expr AND equality_expr
Rule 92    equality_expr -> relational_expr
Rule 93    equality_expr -> equality_expr NE relational_expr
Rule 94    equality_expr -> equality_expr EQ relational_expr
Rule 95    relational_expr -> additive_expr
Rule 96    relational_expr -> relational_expr GE additive_expr
Rule 97    relational_expr -> relational_expr GT additive_expr
Rule 98    relational_expr -> relational_expr LE additive_expr
Rule 99    relational_expr -> relational_expr LT additive_expr
Rule 100   additive_expr -> multiplicative_expr
Rule 101   additive_expr -> additive_expr - multiplicative_expr  [precedence=right, level=5]
Rule 102   additive_expr -> additive_expr + multiplicative_expr  [precedence=right, level=5]
Rule 103   multiplicative_expr -> unary_expr
Rule 104   multiplicative_expr -> multiplicative_expr % unary_expr
Rule 105   multiplicative_expr -> multiplicative_expr / unary_expr
Rule 106   multiplicative_expr -> multiplicative_expr * unary_expr
Rule 107   unary_expr -> ( type_spec ) unary_expr  [precedence=right, level=2]
Rule 108   unary_expr -> postfix_expr
Rule 109   unary_expr -> NOT unary_expr  [precedence=right, level=5]
Rule 110   unary_expr -> ! unary_expr  [precedence=right, level=5]
Rule 111   unary_expr -> - unary_expr  [precedence=right, level=5]
Rule 112   unary_expr -> + unary_expr  [precedence=right, level=5]
Rule 113   unary_expr -> DECREMENT unary_expr  [precedence=right, level=1]
Rule 114   unary_expr -> INCREMENT unary_expr  [precedence=right, level=1]
Rule 115   postfix_expr -> primary_expr
Rule 116   postfix_expr -> postfix_expr DECREMENT  [precedence=right, level=1]
Rule 117   postfix_expr -> postfix_expr INCREMENT  [precedence=right, level=1]
Rule 118   primary_expr -> IDENT . SIZE
Rule 119   primary_expr -> IDENT
Rule 120   primary_expr -> IDENT [ expr ]
Rule 121   primary_expr -> IDENT . IDENT ( args_list )
Rule 122   primary_expr -> IDENT ( args_list )
Rule 123   primary_expr -> FALSE
Rule 124   primary_expr -> TRUE
Rule 125   primary_expr -> STRINGLIT
Rule 126   primary_expr -> BOOLIT
Rule 127   primary_expr -> FLOATLIT
Rule 128   primary_expr -> INTLIT
Rule 129   primary_expr -> ( expr )
Rule 130   empty -> <empty>

Terminals, with rules where they appear:

!                    : 110
%                    : 104
(                    : 17 18 19 44 55 64 65 68 74 75 80 107 121 122 129
)                    : 17 18 19 44 55 64 65 68 74 75 80 107 121 122 129
*                    : 106
+                    : 102 112
,                    : 21 72 74 75
-                    : 101 111
.                    : 118 121
/                    : 105
:                    : 12 13
;                    : 8 44 44 55 56 66 67 69 70 74 75 76 77 78 79 80 81
=                    : 49 57 63 78 80
AND                  : 91
BOOL                 : 83
BOOLIT               : 126
BREAK                : 69
CLASS                : 8
CONTINUE             : 70
DECREMENT            : 113 116
DIV_ASSIGN           : 59
ELSE                 : 64
EQ                   : 94
FALSE                : 123
FLOAT                : 84
FLOATLIT             : 127
FOR                  : 44
GE                   : 96
GT                   : 97
IDENT                : 8 17 18 19 23 24 48 49 50 57 59 60 61 62 63 77 78 79 80 80 80 81 81 118 119 120 121 121 122
IF                   : 64 65
INCREMENT            : 114 117
INT                  : 85
INTLIT               : 23 128
LE                   : 98
LT                   : 99
MINUS_ASSIGN         : 61
MULT_ASSIGN          : 60
NE                   : 93
NEW                  : 80
NOT                  : 109
OR                   : 89
PLUS_ASSIGN          : 62
PRINTF               : 74
PRIVATE              : 13
PUBLIC               : 12
RETURN               : 66 67
SIZE                 : 118
SPRINTF              : 75
STRING               : 82
STRINGLIT            : 125
SUPER                : 55
THIS                 : 76
TRUE                 : 124
VOID                 : 86
WHILE                : 68
[                    : 23 48 57 77 120
]                    : 23 48 57 77 120
error                : 
{                    : 8 25
}                    : 8 25

Nonterminals, with rules where they appear:

access_specifier     : 11
additive_expr        : 95 96 97 98 99 101 102
args_list            : 55 72 74 75 80 121 122
assignment_expr      : 46 49 54 56 57 59 60 61 62 63 78
break_stmt           : 38
class_body           : 8 10 11
class_decl           : 5
class_member         : 10
compound_stmt        : 17 18 19 42 44
constructor_decl     : 14
continue_stmt        : 37
decl                 : 2 3
decl_list            : 1 3
empty                : 9 22 26 30 45 51 53 73
equality_expr        : 90 91 93 94
expr                 : 48 52 57 58 64 65 66 68 71 72 74 75 77 120 129
expr_stmt            : 43
for_cond             : 44
for_incr             : 44
for_init             : 44
for_stmt             : 33
func_decl            : 6
if_stmt              : 41
local_decls          : 25 27 29
logical_and_expr     : 88 89 91
logical_or_expr      : 87 89
method_decl          : 15
multiplicative_expr  : 100 101 102 104 105 106
object_decl          : 4 34
param                : 20 21
param_list           : 17 18 19 21
postfix_expr         : 108 116 117
primary_expr         : 115
print_stmt           : 36
program              : 0
relational_expr      : 92 93 94 96 97 98 99
return_stmt          : 40
sprintf_stmt         : 31
stmt                 : 28 29 64 64 65 68
stmt_list            : 25 28 29
super_stmt           : 35
this_stmt            : 32
type_spec            : 17 19 23 24 48 49 50 77 78 79 107
unary_expr           : 103 104 105 106 107 109 110 111 112 113 114
var_decl             : 7 16 27
var_decl_no_semi     : 47
while_stmt           : 39


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . object_decl
    (5) decl -> . class_decl
    (6) decl -> . func_decl
    (7) decl -> . var_decl
    (80) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (81) object_decl -> . IDENT IDENT ;
    (8) class_decl -> . CLASS IDENT { class_body } ;
    (19) func_decl -> . type_spec IDENT ( param_list ) compound_stmt
    (77) var_decl -> . type_spec IDENT [ expr ] ;
    (78) var_decl -> . type_spec IDENT = assignment_expr ;
    (79) var_decl -> . type_spec IDENT ;
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    IDENT           shift and go to state 8
    CLASS           shift and go to state 9
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    object_decl                    shift and go to state 4
    class_decl                     shift and go to state 5
    func_decl                      shift and go to state 6
    var_decl                       shift and go to state 7
    type_spec                      shift and go to state 10

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . object_decl
    (5) decl -> . class_decl
    (6) decl -> . func_decl
    (7) decl -> . var_decl
    (80) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (81) object_decl -> . IDENT IDENT ;
    (8) class_decl -> . CLASS IDENT { class_body } ;
    (19) func_decl -> . type_spec IDENT ( param_list ) compound_stmt
    (77) var_decl -> . type_spec IDENT [ expr ] ;
    (78) var_decl -> . type_spec IDENT = assignment_expr ;
    (79) var_decl -> . type_spec IDENT ;
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    $end            reduce using rule 1 (program -> decl_list .)
    IDENT           shift and go to state 8
    CLASS           shift and go to state 9
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    decl                           shift and go to state 16
    object_decl                    shift and go to state 4
    class_decl                     shift and go to state 5
    func_decl                      shift and go to state 6
    var_decl                       shift and go to state 7
    type_spec                      shift and go to state 10

state 3

    (2) decl_list -> decl .
    IDENT           reduce using rule 2 (decl_list -> decl .)
    CLASS           reduce using rule 2 (decl_list -> decl .)
    STRING          reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> object_decl .
    IDENT           reduce using rule 4 (decl -> object_decl .)
    CLASS           reduce using rule 4 (decl -> object_decl .)
    STRING          reduce using rule 4 (decl -> object_decl .)
    BOOL            reduce using rule 4 (decl -> object_decl .)
    FLOAT           reduce using rule 4 (decl -> object_decl .)
    INT             reduce using rule 4 (decl -> object_decl .)
    VOID            reduce using rule 4 (decl -> object_decl .)
    $end            reduce using rule 4 (decl -> object_decl .)


state 5

    (5) decl -> class_decl .
    IDENT           reduce using rule 5 (decl -> class_decl .)
    CLASS           reduce using rule 5 (decl -> class_decl .)
    STRING          reduce using rule 5 (decl -> class_decl .)
    BOOL            reduce using rule 5 (decl -> class_decl .)
    FLOAT           reduce using rule 5 (decl -> class_decl .)
    INT             reduce using rule 5 (decl -> class_decl .)
    VOID            reduce using rule 5 (decl -> class_decl .)
    $end            reduce using rule 5 (decl -> class_decl .)


state 6

    (6) decl -> func_decl .
    IDENT           reduce using rule 6 (decl -> func_decl .)
    CLASS           reduce using rule 6 (decl -> func_decl .)
    STRING          reduce using rule 6 (decl -> func_decl .)
    BOOL            reduce using rule 6 (decl -> func_decl .)
    FLOAT           reduce using rule 6 (decl -> func_decl .)
    INT             reduce using rule 6 (decl -> func_decl .)
    VOID            reduce using rule 6 (decl -> func_decl .)
    $end            reduce using rule 6 (decl -> func_decl .)


state 7

    (7) decl -> var_decl .
    IDENT           reduce using rule 7 (decl -> var_decl .)
    CLASS           reduce using rule 7 (decl -> var_decl .)
    STRING          reduce using rule 7 (decl -> var_decl .)
    BOOL            reduce using rule 7 (decl -> var_decl .)
    FLOAT           reduce using rule 7 (decl -> var_decl .)
    INT             reduce using rule 7 (decl -> var_decl .)
    VOID            reduce using rule 7 (decl -> var_decl .)
    $end            reduce using rule 7 (decl -> var_decl .)


state 8

    (80) object_decl -> IDENT . IDENT = NEW IDENT ( args_list ) ;
    (81) object_decl -> IDENT . IDENT ;
    IDENT           shift and go to state 17


state 9

    (8) class_decl -> CLASS . IDENT { class_body } ;
    IDENT           shift and go to state 18


state 10

    (19) func_decl -> type_spec . IDENT ( param_list ) compound_stmt
    (77) var_decl -> type_spec . IDENT [ expr ] ;
    (78) var_decl -> type_spec . IDENT = assignment_expr ;
    (79) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 19


state 11

    (82) type_spec -> STRING .
    IDENT           reduce using rule 82 (type_spec -> STRING .)
    )               reduce using rule 82 (type_spec -> STRING .)


state 12

    (83) type_spec -> BOOL .
    IDENT           reduce using rule 83 (type_spec -> BOOL .)
    )               reduce using rule 83 (type_spec -> BOOL .)


state 13

    (84) type_spec -> FLOAT .
    IDENT           reduce using rule 84 (type_spec -> FLOAT .)
    )               reduce using rule 84 (type_spec -> FLOAT .)


state 14

    (85) type_spec -> INT .
    IDENT           reduce using rule 85 (type_spec -> INT .)
    )               reduce using rule 85 (type_spec -> INT .)


state 15

    (86) type_spec -> VOID .
    IDENT           reduce using rule 86 (type_spec -> VOID .)
    )               reduce using rule 86 (type_spec -> VOID .)


state 16

    (3) decl_list -> decl_list decl .
    IDENT           reduce using rule 3 (decl_list -> decl_list decl .)
    CLASS           reduce using rule 3 (decl_list -> decl_list decl .)
    STRING          reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 17

    (80) object_decl -> IDENT IDENT . = NEW IDENT ( args_list ) ;
    (81) object_decl -> IDENT IDENT . ;
    =               shift and go to state 20
    ;               shift and go to state 21


state 18

    (8) class_decl -> CLASS IDENT . { class_body } ;
    {               shift and go to state 22


state 19

    (19) func_decl -> type_spec IDENT . ( param_list ) compound_stmt
    (77) var_decl -> type_spec IDENT . [ expr ] ;
    (78) var_decl -> type_spec IDENT . = assignment_expr ;
    (79) var_decl -> type_spec IDENT . ;
    (               shift and go to state 23
    [               shift and go to state 24
    =               shift and go to state 26
    ;               shift and go to state 25


state 20

    (80) object_decl -> IDENT IDENT = . NEW IDENT ( args_list ) ;
    NEW             shift and go to state 27


state 21

    (81) object_decl -> IDENT IDENT ; .
    IDENT           reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    CLASS           reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    STRING          reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    BOOL            reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    FLOAT           reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    INT             reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    VOID            reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    $end            reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    SPRINTF         reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    THIS            reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    FOR             reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    SUPER           reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    PRINTF          reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    CONTINUE        reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    BREAK           reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    WHILE           reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    RETURN          reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    IF              reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    {               reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    (               reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    NOT             reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    !               reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    -               reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    +               reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    DECREMENT       reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    INCREMENT       reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    FALSE           reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    TRUE            reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    STRINGLIT       reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    BOOLIT          reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    FLOATLIT        reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    INTLIT          reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    }               reduce using rule 81 (object_decl -> IDENT IDENT ; .)
    ELSE            reduce using rule 81 (object_decl -> IDENT IDENT ; .)


state 22

    (8) class_decl -> CLASS IDENT { . class_body } ;
    (9) class_body -> . empty
    (10) class_body -> . class_member class_body
    (11) class_body -> . access_specifier class_body
    (130) empty -> .
    (14) class_member -> . constructor_decl
    (15) class_member -> . method_decl
    (16) class_member -> . var_decl
    (12) access_specifier -> . PUBLIC :
    (13) access_specifier -> . PRIVATE :
    (18) constructor_decl -> . IDENT ( param_list ) compound_stmt
    (17) method_decl -> . type_spec IDENT ( param_list ) compound_stmt
    (77) var_decl -> . type_spec IDENT [ expr ] ;
    (78) var_decl -> . type_spec IDENT = assignment_expr ;
    (79) var_decl -> . type_spec IDENT ;
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    }               reduce using rule 130 (empty -> .)
    PUBLIC          shift and go to state 36
    PRIVATE         shift and go to state 37
    IDENT           shift and go to state 28
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    class_body                     shift and go to state 29
    empty                          shift and go to state 30
    class_member                   shift and go to state 31
    access_specifier               shift and go to state 32
    constructor_decl               shift and go to state 33
    method_decl                    shift and go to state 34
    var_decl                       shift and go to state 35
    type_spec                      shift and go to state 38

state 23

    (19) func_decl -> type_spec IDENT ( . param_list ) compound_stmt
    (20) param_list -> . param
    (21) param_list -> . param_list , param
    (22) param_list -> . empty
    (23) param -> . type_spec IDENT [ INTLIT ]
    (24) param -> . type_spec IDENT
    (130) empty -> .
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    )               reduce using rule 130 (empty -> .)
    ,               reduce using rule 130 (empty -> .)
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    type_spec                      shift and go to state 39
    param_list                     shift and go to state 40
    param                          shift and go to state 41
    empty                          shift and go to state 42

state 24

    (77) var_decl -> type_spec IDENT [ . expr ] ;
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 44
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 25

    (79) var_decl -> type_spec IDENT ; .
    IDENT           reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    CLASS           reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    STRING          reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    PUBLIC          reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    PRIVATE         reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    }               reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    SPRINTF         reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    THIS            reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    FOR             reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    SUPER           reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    PRINTF          reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    CONTINUE        reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    IF              reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    {               reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    (               reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    NOT             reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    !               reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    -               reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    +               reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    DECREMENT       reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    INCREMENT       reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    FALSE           reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    TRUE            reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    STRINGLIT       reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    BOOLIT          reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    FLOATLIT        reduce using rule 79 (var_decl -> type_spec IDENT ; .)
    INTLIT          reduce using rule 79 (var_decl -> type_spec IDENT ; .)


state 26

    (78) var_decl -> type_spec IDENT = . assignment_expr ;
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    IDENT           shift and go to state 67
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    assignment_expr                shift and go to state 68
    expr                           shift and go to state 69
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 27

    (80) object_decl -> IDENT IDENT = NEW . IDENT ( args_list ) ;
    IDENT           shift and go to state 70


state 28

    (18) constructor_decl -> IDENT . ( param_list ) compound_stmt
    (               shift and go to state 71


state 29

    (8) class_decl -> CLASS IDENT { class_body . } ;
    }               shift and go to state 72


state 30

    (9) class_body -> empty .
    }               reduce using rule 9 (class_body -> empty .)


state 31

    (10) class_body -> class_member . class_body
    (9) class_body -> . empty
    (10) class_body -> . class_member class_body
    (11) class_body -> . access_specifier class_body
    (130) empty -> .
    (14) class_member -> . constructor_decl
    (15) class_member -> . method_decl
    (16) class_member -> . var_decl
    (12) access_specifier -> . PUBLIC :
    (13) access_specifier -> . PRIVATE :
    (18) constructor_decl -> . IDENT ( param_list ) compound_stmt
    (17) method_decl -> . type_spec IDENT ( param_list ) compound_stmt
    (77) var_decl -> . type_spec IDENT [ expr ] ;
    (78) var_decl -> . type_spec IDENT = assignment_expr ;
    (79) var_decl -> . type_spec IDENT ;
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    }               reduce using rule 130 (empty -> .)
    PUBLIC          shift and go to state 36
    PRIVATE         shift and go to state 37
    IDENT           shift and go to state 28
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    class_member                   shift and go to state 31
    class_body                     shift and go to state 73
    empty                          shift and go to state 30
    access_specifier               shift and go to state 32
    constructor_decl               shift and go to state 33
    method_decl                    shift and go to state 34
    var_decl                       shift and go to state 35
    type_spec                      shift and go to state 38

state 32

    (11) class_body -> access_specifier . class_body
    (9) class_body -> . empty
    (10) class_body -> . class_member class_body
    (11) class_body -> . access_specifier class_body
    (130) empty -> .
    (14) class_member -> . constructor_decl
    (15) class_member -> . method_decl
    (16) class_member -> . var_decl
    (12) access_specifier -> . PUBLIC :
    (13) access_specifier -> . PRIVATE :
    (18) constructor_decl -> . IDENT ( param_list ) compound_stmt
    (17) method_decl -> . type_spec IDENT ( param_list ) compound_stmt
    (77) var_decl -> . type_spec IDENT [ expr ] ;
    (78) var_decl -> . type_spec IDENT = assignment_expr ;
    (79) var_decl -> . type_spec IDENT ;
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    }               reduce using rule 130 (empty -> .)
    PUBLIC          shift and go to state 36
    PRIVATE         shift and go to state 37
    IDENT           shift and go to state 28
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    access_specifier               shift and go to state 32
    class_body                     shift and go to state 74
    empty                          shift and go to state 30
    class_member                   shift and go to state 31
    constructor_decl               shift and go to state 33
    method_decl                    shift and go to state 34
    var_decl                       shift and go to state 35
    type_spec                      shift and go to state 38

state 33

    (14) class_member -> constructor_decl .
    PUBLIC          reduce using rule 14 (class_member -> constructor_decl .)
    PRIVATE         reduce using rule 14 (class_member -> constructor_decl .)
    IDENT           reduce using rule 14 (class_member -> constructor_decl .)
    STRING          reduce using rule 14 (class_member -> constructor_decl .)
    BOOL            reduce using rule 14 (class_member -> constructor_decl .)
    FLOAT           reduce using rule 14 (class_member -> constructor_decl .)
    INT             reduce using rule 14 (class_member -> constructor_decl .)
    VOID            reduce using rule 14 (class_member -> constructor_decl .)
    }               reduce using rule 14 (class_member -> constructor_decl .)


state 34

    (15) class_member -> method_decl .
    PUBLIC          reduce using rule 15 (class_member -> method_decl .)
    PRIVATE         reduce using rule 15 (class_member -> method_decl .)
    IDENT           reduce using rule 15 (class_member -> method_decl .)
    STRING          reduce using rule 15 (class_member -> method_decl .)
    BOOL            reduce using rule 15 (class_member -> method_decl .)
    FLOAT           reduce using rule 15 (class_member -> method_decl .)
    INT             reduce using rule 15 (class_member -> method_decl .)
    VOID            reduce using rule 15 (class_member -> method_decl .)
    }               reduce using rule 15 (class_member -> method_decl .)


state 35

    (16) class_member -> var_decl .
    PUBLIC          reduce using rule 16 (class_member -> var_decl .)
    PRIVATE         reduce using rule 16 (class_member -> var_decl .)
    IDENT           reduce using rule 16 (class_member -> var_decl .)
    STRING          reduce using rule 16 (class_member -> var_decl .)
    BOOL            reduce using rule 16 (class_member -> var_decl .)
    FLOAT           reduce using rule 16 (class_member -> var_decl .)
    INT             reduce using rule 16 (class_member -> var_decl .)
    VOID            reduce using rule 16 (class_member -> var_decl .)
    }               reduce using rule 16 (class_member -> var_decl .)


state 36

    (12) access_specifier -> PUBLIC . :
    :               shift and go to state 75


state 37

    (13) access_specifier -> PRIVATE . :
    :               shift and go to state 76


state 38

    (17) method_decl -> type_spec . IDENT ( param_list ) compound_stmt
    (77) var_decl -> type_spec . IDENT [ expr ] ;
    (78) var_decl -> type_spec . IDENT = assignment_expr ;
    (79) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 77


state 39

    (23) param -> type_spec . IDENT [ INTLIT ]
    (24) param -> type_spec . IDENT
    IDENT           shift and go to state 78


state 40

    (19) func_decl -> type_spec IDENT ( param_list . ) compound_stmt
    (21) param_list -> param_list . , param
    )               shift and go to state 79
    ,               shift and go to state 80


state 41

    (20) param_list -> param .
    )               reduce using rule 20 (param_list -> param .)
    ,               reduce using rule 20 (param_list -> param .)


state 42

    (22) param_list -> empty .
    )               reduce using rule 22 (param_list -> empty .)
    ,               reduce using rule 22 (param_list -> empty .)


state 43

    (118) primary_expr -> IDENT . . SIZE
    (119) primary_expr -> IDENT .
    (120) primary_expr -> IDENT . [ expr ]
    (121) primary_expr -> IDENT . . IDENT ( args_list )
    (122) primary_expr -> IDENT . ( args_list )
    .               shift and go to state 81
    DECREMENT       reduce using rule 119 (primary_expr -> IDENT .)
    INCREMENT       reduce using rule 119 (primary_expr -> IDENT .)
    %               reduce using rule 119 (primary_expr -> IDENT .)
    /               reduce using rule 119 (primary_expr -> IDENT .)
    *               reduce using rule 119 (primary_expr -> IDENT .)
    -               reduce using rule 119 (primary_expr -> IDENT .)
    +               reduce using rule 119 (primary_expr -> IDENT .)
    GE              reduce using rule 119 (primary_expr -> IDENT .)
    GT              reduce using rule 119 (primary_expr -> IDENT .)
    LE              reduce using rule 119 (primary_expr -> IDENT .)
    LT              reduce using rule 119 (primary_expr -> IDENT .)
    NE              reduce using rule 119 (primary_expr -> IDENT .)
    EQ              reduce using rule 119 (primary_expr -> IDENT .)
    AND             reduce using rule 119 (primary_expr -> IDENT .)
    OR              reduce using rule 119 (primary_expr -> IDENT .)
    ]               reduce using rule 119 (primary_expr -> IDENT .)
    ;               reduce using rule 119 (primary_expr -> IDENT .)
    )               reduce using rule 119 (primary_expr -> IDENT .)
    ,               reduce using rule 119 (primary_expr -> IDENT .)
    [               shift and go to state 82
    (               shift and go to state 83


state 44

    (77) var_decl -> type_spec IDENT [ expr . ] ;
    ]               shift and go to state 84


state 45

    (87) expr -> logical_or_expr .
    (89) logical_or_expr -> logical_or_expr . OR logical_and_expr
    ]               reduce using rule 87 (expr -> logical_or_expr .)
    ;               reduce using rule 87 (expr -> logical_or_expr .)
    )               reduce using rule 87 (expr -> logical_or_expr .)
    ,               reduce using rule 87 (expr -> logical_or_expr .)
    OR              shift and go to state 85


state 46

    (88) logical_or_expr -> logical_and_expr .
    (91) logical_and_expr -> logical_and_expr . AND equality_expr
    OR              reduce using rule 88 (logical_or_expr -> logical_and_expr .)
    ]               reduce using rule 88 (logical_or_expr -> logical_and_expr .)
    ;               reduce using rule 88 (logical_or_expr -> logical_and_expr .)
    )               reduce using rule 88 (logical_or_expr -> logical_and_expr .)
    ,               reduce using rule 88 (logical_or_expr -> logical_and_expr .)
    AND             shift and go to state 86


state 47

    (90) logical_and_expr -> equality_expr .
    (93) equality_expr -> equality_expr . NE relational_expr
    (94) equality_expr -> equality_expr . EQ relational_expr
    AND             reduce using rule 90 (logical_and_expr -> equality_expr .)
    OR              reduce using rule 90 (logical_and_expr -> equality_expr .)
    ]               reduce using rule 90 (logical_and_expr -> equality_expr .)
    ;               reduce using rule 90 (logical_and_expr -> equality_expr .)
    )               reduce using rule 90 (logical_and_expr -> equality_expr .)
    ,               reduce using rule 90 (logical_and_expr -> equality_expr .)
    NE              shift and go to state 87
    EQ              shift and go to state 88


state 48

    (92) equality_expr -> relational_expr .
    (96) relational_expr -> relational_expr . GE additive_expr
    (97) relational_expr -> relational_expr . GT additive_expr
    (98) relational_expr -> relational_expr . LE additive_expr
    (99) relational_expr -> relational_expr . LT additive_expr
    NE              reduce using rule 92 (equality_expr -> relational_expr .)
    EQ              reduce using rule 92 (equality_expr -> relational_expr .)
    AND             reduce using rule 92 (equality_expr -> relational_expr .)
    OR              reduce using rule 92 (equality_expr -> relational_expr .)
    ]               reduce using rule 92 (equality_expr -> relational_expr .)
    ;               reduce using rule 92 (equality_expr -> relational_expr .)
    )               reduce using rule 92 (equality_expr -> relational_expr .)
    ,               reduce using rule 92 (equality_expr -> relational_expr .)
    GE              shift and go to state 89
    GT              shift and go to state 90
    LE              shift and go to state 91
    LT              shift and go to state 92


state 49

    (95) relational_expr -> additive_expr .
    (101) additive_expr -> additive_expr . - multiplicative_expr
    (102) additive_expr -> additive_expr . + multiplicative_expr
    GE              reduce using rule 95 (relational_expr -> additive_expr .)
    GT              reduce using rule 95 (relational_expr -> additive_expr .)
    LE              reduce using rule 95 (relational_expr -> additive_expr .)
    LT              reduce using rule 95 (relational_expr -> additive_expr .)
    NE              reduce using rule 95 (relational_expr -> additive_expr .)
    EQ              reduce using rule 95 (relational_expr -> additive_expr .)
    AND             reduce using rule 95 (relational_expr -> additive_expr .)
    OR              reduce using rule 95 (relational_expr -> additive_expr .)
    ]               reduce using rule 95 (relational_expr -> additive_expr .)
    ;               reduce using rule 95 (relational_expr -> additive_expr .)
    )               reduce using rule 95 (relational_expr -> additive_expr .)
    ,               reduce using rule 95 (relational_expr -> additive_expr .)
    -               shift and go to state 93
    +               shift and go to state 94


state 50

    (100) additive_expr -> multiplicative_expr .
    (104) multiplicative_expr -> multiplicative_expr . % unary_expr
    (105) multiplicative_expr -> multiplicative_expr . / unary_expr
    (106) multiplicative_expr -> multiplicative_expr . * unary_expr
    -               reduce using rule 100 (additive_expr -> multiplicative_expr .)
    +               reduce using rule 100 (additive_expr -> multiplicative_expr .)
    GE              reduce using rule 100 (additive_expr -> multiplicative_expr .)
    GT              reduce using rule 100 (additive_expr -> multiplicative_expr .)
    LE              reduce using rule 100 (additive_expr -> multiplicative_expr .)
    LT              reduce using rule 100 (additive_expr -> multiplicative_expr .)
    NE              reduce using rule 100 (additive_expr -> multiplicative_expr .)
    EQ              reduce using rule 100 (additive_expr -> multiplicative_expr .)
    AND             reduce using rule 100 (additive_expr -> multiplicative_expr .)
    OR              reduce using rule 100 (additive_expr -> multiplicative_expr .)
    ]               reduce using rule 100 (additive_expr -> multiplicative_expr .)
    ;               reduce using rule 100 (additive_expr -> multiplicative_expr .)
    )               reduce using rule 100 (additive_expr -> multiplicative_expr .)
    ,               reduce using rule 100 (additive_expr -> multiplicative_expr .)
    %               shift and go to state 95
    /               shift and go to state 96
    *               shift and go to state 97


state 51

    (111) unary_expr -> - . unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    unary_expr                     shift and go to state 98
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 52

    (112) unary_expr -> + . unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    unary_expr                     shift and go to state 99
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 53

    (103) multiplicative_expr -> unary_expr .
    %               reduce using rule 103 (multiplicative_expr -> unary_expr .)
    /               reduce using rule 103 (multiplicative_expr -> unary_expr .)
    *               reduce using rule 103 (multiplicative_expr -> unary_expr .)
    -               reduce using rule 103 (multiplicative_expr -> unary_expr .)
    +               reduce using rule 103 (multiplicative_expr -> unary_expr .)
    GE              reduce using rule 103 (multiplicative_expr -> unary_expr .)
    GT              reduce using rule 103 (multiplicative_expr -> unary_expr .)
    LE              reduce using rule 103 (multiplicative_expr -> unary_expr .)
    LT              reduce using rule 103 (multiplicative_expr -> unary_expr .)
    NE              reduce using rule 103 (multiplicative_expr -> unary_expr .)
    EQ              reduce using rule 103 (multiplicative_expr -> unary_expr .)
    AND             reduce using rule 103 (multiplicative_expr -> unary_expr .)
    OR              reduce using rule 103 (multiplicative_expr -> unary_expr .)
    ]               reduce using rule 103 (multiplicative_expr -> unary_expr .)
    ;               reduce using rule 103 (multiplicative_expr -> unary_expr .)
    )               reduce using rule 103 (multiplicative_expr -> unary_expr .)
    ,               reduce using rule 103 (multiplicative_expr -> unary_expr .)


state 54

    (107) unary_expr -> ( . type_spec ) unary_expr
    (129) primary_expr -> ( . expr )
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    type_spec                      shift and go to state 100
    unary_expr                     shift and go to state 53
    expr                           shift and go to state 101
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 55

    (108) unary_expr -> postfix_expr .
    (116) postfix_expr -> postfix_expr . DECREMENT
    (117) postfix_expr -> postfix_expr . INCREMENT
    %               reduce using rule 108 (unary_expr -> postfix_expr .)
    /               reduce using rule 108 (unary_expr -> postfix_expr .)
    *               reduce using rule 108 (unary_expr -> postfix_expr .)
    -               reduce using rule 108 (unary_expr -> postfix_expr .)
    +               reduce using rule 108 (unary_expr -> postfix_expr .)
    GE              reduce using rule 108 (unary_expr -> postfix_expr .)
    GT              reduce using rule 108 (unary_expr -> postfix_expr .)
    LE              reduce using rule 108 (unary_expr -> postfix_expr .)
    LT              reduce using rule 108 (unary_expr -> postfix_expr .)
    NE              reduce using rule 108 (unary_expr -> postfix_expr .)
    EQ              reduce using rule 108 (unary_expr -> postfix_expr .)
    AND             reduce using rule 108 (unary_expr -> postfix_expr .)
    OR              reduce using rule 108 (unary_expr -> postfix_expr .)
    ]               reduce using rule 108 (unary_expr -> postfix_expr .)
    ;               reduce using rule 108 (unary_expr -> postfix_expr .)
    )               reduce using rule 108 (unary_expr -> postfix_expr .)
    ,               reduce using rule 108 (unary_expr -> postfix_expr .)
    DECREMENT       shift and go to state 102
    INCREMENT       shift and go to state 103


state 56

    (109) unary_expr -> NOT . unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    unary_expr                     shift and go to state 104
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 57

    (110) unary_expr -> ! . unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    unary_expr                     shift and go to state 105
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 58

    (113) unary_expr -> DECREMENT . unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    unary_expr                     shift and go to state 106
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 59

    (114) unary_expr -> INCREMENT . unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    unary_expr                     shift and go to state 107
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 60

    (115) postfix_expr -> primary_expr .
    DECREMENT       reduce using rule 115 (postfix_expr -> primary_expr .)
    INCREMENT       reduce using rule 115 (postfix_expr -> primary_expr .)
    %               reduce using rule 115 (postfix_expr -> primary_expr .)
    /               reduce using rule 115 (postfix_expr -> primary_expr .)
    *               reduce using rule 115 (postfix_expr -> primary_expr .)
    -               reduce using rule 115 (postfix_expr -> primary_expr .)
    +               reduce using rule 115 (postfix_expr -> primary_expr .)
    GE              reduce using rule 115 (postfix_expr -> primary_expr .)
    GT              reduce using rule 115 (postfix_expr -> primary_expr .)
    LE              reduce using rule 115 (postfix_expr -> primary_expr .)
    LT              reduce using rule 115 (postfix_expr -> primary_expr .)
    NE              reduce using rule 115 (postfix_expr -> primary_expr .)
    EQ              reduce using rule 115 (postfix_expr -> primary_expr .)
    AND             reduce using rule 115 (postfix_expr -> primary_expr .)
    OR              reduce using rule 115 (postfix_expr -> primary_expr .)
    ]               reduce using rule 115 (postfix_expr -> primary_expr .)
    ;               reduce using rule 115 (postfix_expr -> primary_expr .)
    )               reduce using rule 115 (postfix_expr -> primary_expr .)
    ,               reduce using rule 115 (postfix_expr -> primary_expr .)


state 61

    (123) primary_expr -> FALSE .
    DECREMENT       reduce using rule 123 (primary_expr -> FALSE .)
    INCREMENT       reduce using rule 123 (primary_expr -> FALSE .)
    %               reduce using rule 123 (primary_expr -> FALSE .)
    /               reduce using rule 123 (primary_expr -> FALSE .)
    *               reduce using rule 123 (primary_expr -> FALSE .)
    -               reduce using rule 123 (primary_expr -> FALSE .)
    +               reduce using rule 123 (primary_expr -> FALSE .)
    GE              reduce using rule 123 (primary_expr -> FALSE .)
    GT              reduce using rule 123 (primary_expr -> FALSE .)
    LE              reduce using rule 123 (primary_expr -> FALSE .)
    LT              reduce using rule 123 (primary_expr -> FALSE .)
    NE              reduce using rule 123 (primary_expr -> FALSE .)
    EQ              reduce using rule 123 (primary_expr -> FALSE .)
    AND             reduce using rule 123 (primary_expr -> FALSE .)
    OR              reduce using rule 123 (primary_expr -> FALSE .)
    ]               reduce using rule 123 (primary_expr -> FALSE .)
    ;               reduce using rule 123 (primary_expr -> FALSE .)
    )               reduce using rule 123 (primary_expr -> FALSE .)
    ,               reduce using rule 123 (primary_expr -> FALSE .)


state 62

    (124) primary_expr -> TRUE .
    DECREMENT       reduce using rule 124 (primary_expr -> TRUE .)
    INCREMENT       reduce using rule 124 (primary_expr -> TRUE .)
    %               reduce using rule 124 (primary_expr -> TRUE .)
    /               reduce using rule 124 (primary_expr -> TRUE .)
    *               reduce using rule 124 (primary_expr -> TRUE .)
    -               reduce using rule 124 (primary_expr -> TRUE .)
    +               reduce using rule 124 (primary_expr -> TRUE .)
    GE              reduce using rule 124 (primary_expr -> TRUE .)
    GT              reduce using rule 124 (primary_expr -> TRUE .)
    LE              reduce using rule 124 (primary_expr -> TRUE .)
    LT              reduce using rule 124 (primary_expr -> TRUE .)
    NE              reduce using rule 124 (primary_expr -> TRUE .)
    EQ              reduce using rule 124 (primary_expr -> TRUE .)
    AND             reduce using rule 124 (primary_expr -> TRUE .)
    OR              reduce using rule 124 (primary_expr -> TRUE .)
    ]               reduce using rule 124 (primary_expr -> TRUE .)
    ;               reduce using rule 124 (primary_expr -> TRUE .)
    )               reduce using rule 124 (primary_expr -> TRUE .)
    ,               reduce using rule 124 (primary_expr -> TRUE .)


state 63

    (125) primary_expr -> STRINGLIT .
    DECREMENT       reduce using rule 125 (primary_expr -> STRINGLIT .)
    INCREMENT       reduce using rule 125 (primary_expr -> STRINGLIT .)
    %               reduce using rule 125 (primary_expr -> STRINGLIT .)
    /               reduce using rule 125 (primary_expr -> STRINGLIT .)
    *               reduce using rule 125 (primary_expr -> STRINGLIT .)
    -               reduce using rule 125 (primary_expr -> STRINGLIT .)
    +               reduce using rule 125 (primary_expr -> STRINGLIT .)
    GE              reduce using rule 125 (primary_expr -> STRINGLIT .)
    GT              reduce using rule 125 (primary_expr -> STRINGLIT .)
    LE              reduce using rule 125 (primary_expr -> STRINGLIT .)
    LT              reduce using rule 125 (primary_expr -> STRINGLIT .)
    NE              reduce using rule 125 (primary_expr -> STRINGLIT .)
    EQ              reduce using rule 125 (primary_expr -> STRINGLIT .)
    AND             reduce using rule 125 (primary_expr -> STRINGLIT .)
    OR              reduce using rule 125 (primary_expr -> STRINGLIT .)
    ]               reduce using rule 125 (primary_expr -> STRINGLIT .)
    ;               reduce using rule 125 (primary_expr -> STRINGLIT .)
    )               reduce using rule 125 (primary_expr -> STRINGLIT .)
    ,               reduce using rule 125 (primary_expr -> STRINGLIT .)


state 64

    (126) primary_expr -> BOOLIT .
    DECREMENT       reduce using rule 126 (primary_expr -> BOOLIT .)
    INCREMENT       reduce using rule 126 (primary_expr -> BOOLIT .)
    %               reduce using rule 126 (primary_expr -> BOOLIT .)
    /               reduce using rule 126 (primary_expr -> BOOLIT .)
    *               reduce using rule 126 (primary_expr -> BOOLIT .)
    -               reduce using rule 126 (primary_expr -> BOOLIT .)
    +               reduce using rule 126 (primary_expr -> BOOLIT .)
    GE              reduce using rule 126 (primary_expr -> BOOLIT .)
    GT              reduce using rule 126 (primary_expr -> BOOLIT .)
    LE              reduce using rule 126 (primary_expr -> BOOLIT .)
    LT              reduce using rule 126 (primary_expr -> BOOLIT .)
    NE              reduce using rule 126 (primary_expr -> BOOLIT .)
    EQ              reduce using rule 126 (primary_expr -> BOOLIT .)
    AND             reduce using rule 126 (primary_expr -> BOOLIT .)
    OR              reduce using rule 126 (primary_expr -> BOOLIT .)
    ]               reduce using rule 126 (primary_expr -> BOOLIT .)
    ;               reduce using rule 126 (primary_expr -> BOOLIT .)
    )               reduce using rule 126 (primary_expr -> BOOLIT .)
    ,               reduce using rule 126 (primary_expr -> BOOLIT .)


state 65

    (127) primary_expr -> FLOATLIT .
    DECREMENT       reduce using rule 127 (primary_expr -> FLOATLIT .)
    INCREMENT       reduce using rule 127 (primary_expr -> FLOATLIT .)
    %               reduce using rule 127 (primary_expr -> FLOATLIT .)
    /               reduce using rule 127 (primary_expr -> FLOATLIT .)
    *               reduce using rule 127 (primary_expr -> FLOATLIT .)
    -               reduce using rule 127 (primary_expr -> FLOATLIT .)
    +               reduce using rule 127 (primary_expr -> FLOATLIT .)
    GE              reduce using rule 127 (primary_expr -> FLOATLIT .)
    GT              reduce using rule 127 (primary_expr -> FLOATLIT .)
    LE              reduce using rule 127 (primary_expr -> FLOATLIT .)
    LT              reduce using rule 127 (primary_expr -> FLOATLIT .)
    NE              reduce using rule 127 (primary_expr -> FLOATLIT .)
    EQ              reduce using rule 127 (primary_expr -> FLOATLIT .)
    AND             reduce using rule 127 (primary_expr -> FLOATLIT .)
    OR              reduce using rule 127 (primary_expr -> FLOATLIT .)
    ]               reduce using rule 127 (primary_expr -> FLOATLIT .)
    ;               reduce using rule 127 (primary_expr -> FLOATLIT .)
    )               reduce using rule 127 (primary_expr -> FLOATLIT .)
    ,               reduce using rule 127 (primary_expr -> FLOATLIT .)


state 66

    (128) primary_expr -> INTLIT .
    DECREMENT       reduce using rule 128 (primary_expr -> INTLIT .)
    INCREMENT       reduce using rule 128 (primary_expr -> INTLIT .)
    %               reduce using rule 128 (primary_expr -> INTLIT .)
    /               reduce using rule 128 (primary_expr -> INTLIT .)
    *               reduce using rule 128 (primary_expr -> INTLIT .)
    -               reduce using rule 128 (primary_expr -> INTLIT .)
    +               reduce using rule 128 (primary_expr -> INTLIT .)
    GE              reduce using rule 128 (primary_expr -> INTLIT .)
    GT              reduce using rule 128 (primary_expr -> INTLIT .)
    LE              reduce using rule 128 (primary_expr -> INTLIT .)
    LT              reduce using rule 128 (primary_expr -> INTLIT .)
    NE              reduce using rule 128 (primary_expr -> INTLIT .)
    EQ              reduce using rule 128 (primary_expr -> INTLIT .)
    AND             reduce using rule 128 (primary_expr -> INTLIT .)
    OR              reduce using rule 128 (primary_expr -> INTLIT .)
    ]               reduce using rule 128 (primary_expr -> INTLIT .)
    ;               reduce using rule 128 (primary_expr -> INTLIT .)
    )               reduce using rule 128 (primary_expr -> INTLIT .)
    ,               reduce using rule 128 (primary_expr -> INTLIT .)


state 67

    (57) assignment_expr -> IDENT . [ expr ] = assignment_expr
    (59) assignment_expr -> IDENT . DIV_ASSIGN assignment_expr
    (60) assignment_expr -> IDENT . MULT_ASSIGN assignment_expr
    (61) assignment_expr -> IDENT . MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> IDENT . PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> IDENT . = assignment_expr
    (118) primary_expr -> IDENT . . SIZE
    (119) primary_expr -> IDENT .
    (120) primary_expr -> IDENT . [ expr ]
    (121) primary_expr -> IDENT . . IDENT ( args_list )
    (122) primary_expr -> IDENT . ( args_list )
    [               shift and go to state 108
    DIV_ASSIGN      shift and go to state 110
    MULT_ASSIGN     shift and go to state 111
    MINUS_ASSIGN    shift and go to state 112
    PLUS_ASSIGN     shift and go to state 113
    =               shift and go to state 109
    .               shift and go to state 81
    DECREMENT       reduce using rule 119 (primary_expr -> IDENT .)
    INCREMENT       reduce using rule 119 (primary_expr -> IDENT .)
    %               reduce using rule 119 (primary_expr -> IDENT .)
    /               reduce using rule 119 (primary_expr -> IDENT .)
    *               reduce using rule 119 (primary_expr -> IDENT .)
    -               reduce using rule 119 (primary_expr -> IDENT .)
    +               reduce using rule 119 (primary_expr -> IDENT .)
    GE              reduce using rule 119 (primary_expr -> IDENT .)
    GT              reduce using rule 119 (primary_expr -> IDENT .)
    LE              reduce using rule 119 (primary_expr -> IDENT .)
    LT              reduce using rule 119 (primary_expr -> IDENT .)
    NE              reduce using rule 119 (primary_expr -> IDENT .)
    EQ              reduce using rule 119 (primary_expr -> IDENT .)
    AND             reduce using rule 119 (primary_expr -> IDENT .)
    OR              reduce using rule 119 (primary_expr -> IDENT .)
    ;               reduce using rule 119 (primary_expr -> IDENT .)
    )               reduce using rule 119 (primary_expr -> IDENT .)
    (               shift and go to state 83


state 68

    (78) var_decl -> type_spec IDENT = assignment_expr . ;
    ;               shift and go to state 114


state 69

    (58) assignment_expr -> expr .
    ;               reduce using rule 58 (assignment_expr -> expr .)
    )               reduce using rule 58 (assignment_expr -> expr .)


state 70

    (80) object_decl -> IDENT IDENT = NEW IDENT . ( args_list ) ;
    (               shift and go to state 115


state 71

    (18) constructor_decl -> IDENT ( . param_list ) compound_stmt
    (20) param_list -> . param
    (21) param_list -> . param_list , param
    (22) param_list -> . empty
    (23) param -> . type_spec IDENT [ INTLIT ]
    (24) param -> . type_spec IDENT
    (130) empty -> .
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    )               reduce using rule 130 (empty -> .)
    ,               reduce using rule 130 (empty -> .)
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    param_list                     shift and go to state 116
    param                          shift and go to state 41
    empty                          shift and go to state 42
    type_spec                      shift and go to state 39

state 72

    (8) class_decl -> CLASS IDENT { class_body } . ;
    ;               shift and go to state 117


state 73

    (10) class_body -> class_member class_body .
    }               reduce using rule 10 (class_body -> class_member class_body .)


state 74

    (11) class_body -> access_specifier class_body .
    }               reduce using rule 11 (class_body -> access_specifier class_body .)


state 75

    (12) access_specifier -> PUBLIC : .
    PUBLIC          reduce using rule 12 (access_specifier -> PUBLIC : .)
    PRIVATE         reduce using rule 12 (access_specifier -> PUBLIC : .)
    IDENT           reduce using rule 12 (access_specifier -> PUBLIC : .)
    STRING          reduce using rule 12 (access_specifier -> PUBLIC : .)
    BOOL            reduce using rule 12 (access_specifier -> PUBLIC : .)
    FLOAT           reduce using rule 12 (access_specifier -> PUBLIC : .)
    INT             reduce using rule 12 (access_specifier -> PUBLIC : .)
    VOID            reduce using rule 12 (access_specifier -> PUBLIC : .)
    }               reduce using rule 12 (access_specifier -> PUBLIC : .)


state 76

    (13) access_specifier -> PRIVATE : .
    PUBLIC          reduce using rule 13 (access_specifier -> PRIVATE : .)
    PRIVATE         reduce using rule 13 (access_specifier -> PRIVATE : .)
    IDENT           reduce using rule 13 (access_specifier -> PRIVATE : .)
    STRING          reduce using rule 13 (access_specifier -> PRIVATE : .)
    BOOL            reduce using rule 13 (access_specifier -> PRIVATE : .)
    FLOAT           reduce using rule 13 (access_specifier -> PRIVATE : .)
    INT             reduce using rule 13 (access_specifier -> PRIVATE : .)
    VOID            reduce using rule 13 (access_specifier -> PRIVATE : .)
    }               reduce using rule 13 (access_specifier -> PRIVATE : .)


state 77

    (17) method_decl -> type_spec IDENT . ( param_list ) compound_stmt
    (77) var_decl -> type_spec IDENT . [ expr ] ;
    (78) var_decl -> type_spec IDENT . = assignment_expr ;
    (79) var_decl -> type_spec IDENT . ;
    (               shift and go to state 118
    [               shift and go to state 24
    =               shift and go to state 26
    ;               shift and go to state 25


state 78

    (23) param -> type_spec IDENT . [ INTLIT ]
    (24) param -> type_spec IDENT .
    [               shift and go to state 119
    )               reduce using rule 24 (param -> type_spec IDENT .)
    ,               reduce using rule 24 (param -> type_spec IDENT .)


state 79

    (19) func_decl -> type_spec IDENT ( param_list ) . compound_stmt
    (25) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 121

    compound_stmt                  shift and go to state 120

state 80

    (21) param_list -> param_list , . param
    (23) param -> . type_spec IDENT [ INTLIT ]
    (24) param -> . type_spec IDENT
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    param                          shift and go to state 122
    type_spec                      shift and go to state 39

state 81

    (118) primary_expr -> IDENT . . SIZE
    (121) primary_expr -> IDENT . . IDENT ( args_list )
    SIZE            shift and go to state 124
    IDENT           shift and go to state 123


state 82

    (120) primary_expr -> IDENT [ . expr ]
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 125
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 83

    (122) primary_expr -> IDENT ( . args_list )
    (71) args_list -> . expr
    (72) args_list -> . args_list , expr
    (73) args_list -> . empty
    (87) expr -> . logical_or_expr
    (130) empty -> .
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    )               reduce using rule 130 (empty -> .)
    ,               reduce using rule 130 (empty -> .)
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    args_list                      shift and go to state 126
    expr                           shift and go to state 127
    empty                          shift and go to state 128
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 84

    (77) var_decl -> type_spec IDENT [ expr ] . ;
    ;               shift and go to state 129


state 85

    (89) logical_or_expr -> logical_or_expr OR . logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    logical_and_expr               shift and go to state 130
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 86

    (91) logical_and_expr -> logical_and_expr AND . equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    equality_expr                  shift and go to state 131
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 87

    (93) equality_expr -> equality_expr NE . relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    relational_expr                shift and go to state 132
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 88

    (94) equality_expr -> equality_expr EQ . relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    relational_expr                shift and go to state 133
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 89

    (96) relational_expr -> relational_expr GE . additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    additive_expr                  shift and go to state 134
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 90

    (97) relational_expr -> relational_expr GT . additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    additive_expr                  shift and go to state 135
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 91

    (98) relational_expr -> relational_expr LE . additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    additive_expr                  shift and go to state 136
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 92

    (99) relational_expr -> relational_expr LT . additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    additive_expr                  shift and go to state 137
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 93

    (101) additive_expr -> additive_expr - . multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    multiplicative_expr            shift and go to state 138
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 94

    (102) additive_expr -> additive_expr + . multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    multiplicative_expr            shift and go to state 139
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 95

    (104) multiplicative_expr -> multiplicative_expr % . unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    unary_expr                     shift and go to state 140
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 96

    (105) multiplicative_expr -> multiplicative_expr / . unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    unary_expr                     shift and go to state 141
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 97

    (106) multiplicative_expr -> multiplicative_expr * . unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    unary_expr                     shift and go to state 142
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 98

    (111) unary_expr -> - unary_expr .
    %               reduce using rule 111 (unary_expr -> - unary_expr .)
    /               reduce using rule 111 (unary_expr -> - unary_expr .)
    *               reduce using rule 111 (unary_expr -> - unary_expr .)
    -               reduce using rule 111 (unary_expr -> - unary_expr .)
    +               reduce using rule 111 (unary_expr -> - unary_expr .)
    GE              reduce using rule 111 (unary_expr -> - unary_expr .)
    GT              reduce using rule 111 (unary_expr -> - unary_expr .)
    LE              reduce using rule 111 (unary_expr -> - unary_expr .)
    LT              reduce using rule 111 (unary_expr -> - unary_expr .)
    NE              reduce using rule 111 (unary_expr -> - unary_expr .)
    EQ              reduce using rule 111 (unary_expr -> - unary_expr .)
    AND             reduce using rule 111 (unary_expr -> - unary_expr .)
    OR              reduce using rule 111 (unary_expr -> - unary_expr .)
    ]               reduce using rule 111 (unary_expr -> - unary_expr .)
    ;               reduce using rule 111 (unary_expr -> - unary_expr .)
    )               reduce using rule 111 (unary_expr -> - unary_expr .)
    ,               reduce using rule 111 (unary_expr -> - unary_expr .)


state 99

    (112) unary_expr -> + unary_expr .
    %               reduce using rule 112 (unary_expr -> + unary_expr .)
    /               reduce using rule 112 (unary_expr -> + unary_expr .)
    *               reduce using rule 112 (unary_expr -> + unary_expr .)
    -               reduce using rule 112 (unary_expr -> + unary_expr .)
    +               reduce using rule 112 (unary_expr -> + unary_expr .)
    GE              reduce using rule 112 (unary_expr -> + unary_expr .)
    GT              reduce using rule 112 (unary_expr -> + unary_expr .)
    LE              reduce using rule 112 (unary_expr -> + unary_expr .)
    LT              reduce using rule 112 (unary_expr -> + unary_expr .)
    NE              reduce using rule 112 (unary_expr -> + unary_expr .)
    EQ              reduce using rule 112 (unary_expr -> + unary_expr .)
    AND             reduce using rule 112 (unary_expr -> + unary_expr .)
    OR              reduce using rule 112 (unary_expr -> + unary_expr .)
    ]               reduce using rule 112 (unary_expr -> + unary_expr .)
    ;               reduce using rule 112 (unary_expr -> + unary_expr .)
    )               reduce using rule 112 (unary_expr -> + unary_expr .)
    ,               reduce using rule 112 (unary_expr -> + unary_expr .)


state 100

    (107) unary_expr -> ( type_spec . ) unary_expr
    )               shift and go to state 143


state 101

    (129) primary_expr -> ( expr . )
    )               shift and go to state 144


state 102

    (116) postfix_expr -> postfix_expr DECREMENT .
    DECREMENT       reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    INCREMENT       reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    %               reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    /               reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    *               reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    -               reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    +               reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    GE              reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    GT              reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    LE              reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    LT              reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    NE              reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    EQ              reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    AND             reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    OR              reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    ]               reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    ;               reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    )               reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)
    ,               reduce using rule 116 (postfix_expr -> postfix_expr DECREMENT .)


state 103

    (117) postfix_expr -> postfix_expr INCREMENT .
    DECREMENT       reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    INCREMENT       reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    %               reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    /               reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    *               reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    -               reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    +               reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    GE              reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    GT              reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    LE              reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    LT              reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    NE              reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    EQ              reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    AND             reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    OR              reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    ]               reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    ;               reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    )               reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)
    ,               reduce using rule 117 (postfix_expr -> postfix_expr INCREMENT .)


state 104

    (109) unary_expr -> NOT unary_expr .
    %               reduce using rule 109 (unary_expr -> NOT unary_expr .)
    /               reduce using rule 109 (unary_expr -> NOT unary_expr .)
    *               reduce using rule 109 (unary_expr -> NOT unary_expr .)
    -               reduce using rule 109 (unary_expr -> NOT unary_expr .)
    +               reduce using rule 109 (unary_expr -> NOT unary_expr .)
    GE              reduce using rule 109 (unary_expr -> NOT unary_expr .)
    GT              reduce using rule 109 (unary_expr -> NOT unary_expr .)
    LE              reduce using rule 109 (unary_expr -> NOT unary_expr .)
    LT              reduce using rule 109 (unary_expr -> NOT unary_expr .)
    NE              reduce using rule 109 (unary_expr -> NOT unary_expr .)
    EQ              reduce using rule 109 (unary_expr -> NOT unary_expr .)
    AND             reduce using rule 109 (unary_expr -> NOT unary_expr .)
    OR              reduce using rule 109 (unary_expr -> NOT unary_expr .)
    ]               reduce using rule 109 (unary_expr -> NOT unary_expr .)
    ;               reduce using rule 109 (unary_expr -> NOT unary_expr .)
    )               reduce using rule 109 (unary_expr -> NOT unary_expr .)
    ,               reduce using rule 109 (unary_expr -> NOT unary_expr .)


state 105

    (110) unary_expr -> ! unary_expr .
    %               reduce using rule 110 (unary_expr -> ! unary_expr .)
    /               reduce using rule 110 (unary_expr -> ! unary_expr .)
    *               reduce using rule 110 (unary_expr -> ! unary_expr .)
    -               reduce using rule 110 (unary_expr -> ! unary_expr .)
    +               reduce using rule 110 (unary_expr -> ! unary_expr .)
    GE              reduce using rule 110 (unary_expr -> ! unary_expr .)
    GT              reduce using rule 110 (unary_expr -> ! unary_expr .)
    LE              reduce using rule 110 (unary_expr -> ! unary_expr .)
    LT              reduce using rule 110 (unary_expr -> ! unary_expr .)
    NE              reduce using rule 110 (unary_expr -> ! unary_expr .)
    EQ              reduce using rule 110 (unary_expr -> ! unary_expr .)
    AND             reduce using rule 110 (unary_expr -> ! unary_expr .)
    OR              reduce using rule 110 (unary_expr -> ! unary_expr .)
    ]               reduce using rule 110 (unary_expr -> ! unary_expr .)
    ;               reduce using rule 110 (unary_expr -> ! unary_expr .)
    )               reduce using rule 110 (unary_expr -> ! unary_expr .)
    ,               reduce using rule 110 (unary_expr -> ! unary_expr .)


state 106

    (113) unary_expr -> DECREMENT unary_expr .
    %               reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    /               reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    *               reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    -               reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    +               reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    GE              reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    GT              reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    LE              reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    LT              reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    NE              reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    EQ              reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    AND             reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    OR              reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    ]               reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    ;               reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    )               reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)
    ,               reduce using rule 113 (unary_expr -> DECREMENT unary_expr .)


state 107

    (114) unary_expr -> INCREMENT unary_expr .
    %               reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    /               reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    *               reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    -               reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    +               reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    GE              reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    GT              reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    LE              reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    LT              reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    NE              reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    EQ              reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    AND             reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    OR              reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    ]               reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    ;               reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    )               reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)
    ,               reduce using rule 114 (unary_expr -> INCREMENT unary_expr .)


state 108

    (57) assignment_expr -> IDENT [ . expr ] = assignment_expr
    (120) primary_expr -> IDENT [ . expr ]
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 145
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 109

    (63) assignment_expr -> IDENT = . assignment_expr
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    IDENT           shift and go to state 67
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    assignment_expr                shift and go to state 146
    expr                           shift and go to state 69
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 110

    (59) assignment_expr -> IDENT DIV_ASSIGN . assignment_expr
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    IDENT           shift and go to state 67
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    assignment_expr                shift and go to state 147
    expr                           shift and go to state 69
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 111

    (60) assignment_expr -> IDENT MULT_ASSIGN . assignment_expr
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    IDENT           shift and go to state 67
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    assignment_expr                shift and go to state 148
    expr                           shift and go to state 69
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 112

    (61) assignment_expr -> IDENT MINUS_ASSIGN . assignment_expr
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    IDENT           shift and go to state 67
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    assignment_expr                shift and go to state 149
    expr                           shift and go to state 69
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 113

    (62) assignment_expr -> IDENT PLUS_ASSIGN . assignment_expr
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    IDENT           shift and go to state 67
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    assignment_expr                shift and go to state 150
    expr                           shift and go to state 69
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 114

    (78) var_decl -> type_spec IDENT = assignment_expr ; .
    IDENT           reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    CLASS           reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    STRING          reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    BOOL            reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    FLOAT           reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    INT             reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    VOID            reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    $end            reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    PUBLIC          reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    PRIVATE         reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    }               reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    SPRINTF         reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    THIS            reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    FOR             reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    SUPER           reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    PRINTF          reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    CONTINUE        reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    BREAK           reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    WHILE           reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    RETURN          reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    IF              reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    {               reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    (               reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    NOT             reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    !               reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    -               reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    +               reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    DECREMENT       reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    INCREMENT       reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    FALSE           reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    TRUE            reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    STRINGLIT       reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    BOOLIT          reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    FLOATLIT        reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)
    INTLIT          reduce using rule 78 (var_decl -> type_spec IDENT = assignment_expr ; .)


state 115

    (80) object_decl -> IDENT IDENT = NEW IDENT ( . args_list ) ;
    (71) args_list -> . expr
    (72) args_list -> . args_list , expr
    (73) args_list -> . empty
    (87) expr -> . logical_or_expr
    (130) empty -> .
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    )               reduce using rule 130 (empty -> .)
    ,               reduce using rule 130 (empty -> .)
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    args_list                      shift and go to state 151
    expr                           shift and go to state 127
    empty                          shift and go to state 128
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 116

    (18) constructor_decl -> IDENT ( param_list . ) compound_stmt
    (21) param_list -> param_list . , param
    )               shift and go to state 152
    ,               shift and go to state 80


state 117

    (8) class_decl -> CLASS IDENT { class_body } ; .
    IDENT           reduce using rule 8 (class_decl -> CLASS IDENT { class_body } ; .)
    CLASS           reduce using rule 8 (class_decl -> CLASS IDENT { class_body } ; .)
    STRING          reduce using rule 8 (class_decl -> CLASS IDENT { class_body } ; .)
    BOOL            reduce using rule 8 (class_decl -> CLASS IDENT { class_body } ; .)
    FLOAT           reduce using rule 8 (class_decl -> CLASS IDENT { class_body } ; .)
    INT             reduce using rule 8 (class_decl -> CLASS IDENT { class_body } ; .)
    VOID            reduce using rule 8 (class_decl -> CLASS IDENT { class_body } ; .)
    $end            reduce using rule 8 (class_decl -> CLASS IDENT { class_body } ; .)


state 118

    (17) method_decl -> type_spec IDENT ( . param_list ) compound_stmt
    (20) param_list -> . param
    (21) param_list -> . param_list , param
    (22) param_list -> . empty
    (23) param -> . type_spec IDENT [ INTLIT ]
    (24) param -> . type_spec IDENT
    (130) empty -> .
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    )               reduce using rule 130 (empty -> .)
    ,               reduce using rule 130 (empty -> .)
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    type_spec                      shift and go to state 39
    param_list                     shift and go to state 153
    param                          shift and go to state 41
    empty                          shift and go to state 42

state 119

    (23) param -> type_spec IDENT [ . INTLIT ]
    INTLIT          shift and go to state 154


state 120

    (19) func_decl -> type_spec IDENT ( param_list ) compound_stmt .
    IDENT           reduce using rule 19 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    CLASS           reduce using rule 19 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    STRING          reduce using rule 19 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    BOOL            reduce using rule 19 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    FLOAT           reduce using rule 19 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    INT             reduce using rule 19 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    VOID            reduce using rule 19 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    $end            reduce using rule 19 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)


state 121

    (25) compound_stmt -> { . local_decls stmt_list }
    (26) local_decls -> . empty
    (27) local_decls -> . var_decl local_decls
    (130) empty -> .
    (77) var_decl -> . type_spec IDENT [ expr ] ;
    (78) var_decl -> . type_spec IDENT = assignment_expr ;
    (79) var_decl -> . type_spec IDENT ;
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    SPRINTF         reduce using rule 130 (empty -> .)
    THIS            reduce using rule 130 (empty -> .)
    FOR             reduce using rule 130 (empty -> .)
    IDENT           reduce using rule 130 (empty -> .)
    SUPER           reduce using rule 130 (empty -> .)
    PRINTF          reduce using rule 130 (empty -> .)
    CONTINUE        reduce using rule 130 (empty -> .)
    BREAK           reduce using rule 130 (empty -> .)
    WHILE           reduce using rule 130 (empty -> .)
    RETURN          reduce using rule 130 (empty -> .)
    IF              reduce using rule 130 (empty -> .)
    {               reduce using rule 130 (empty -> .)
    (               reduce using rule 130 (empty -> .)
    NOT             reduce using rule 130 (empty -> .)
    !               reduce using rule 130 (empty -> .)
    -               reduce using rule 130 (empty -> .)
    +               reduce using rule 130 (empty -> .)
    DECREMENT       reduce using rule 130 (empty -> .)
    INCREMENT       reduce using rule 130 (empty -> .)
    FALSE           reduce using rule 130 (empty -> .)
    TRUE            reduce using rule 130 (empty -> .)
    STRINGLIT       reduce using rule 130 (empty -> .)
    BOOLIT          reduce using rule 130 (empty -> .)
    FLOATLIT        reduce using rule 130 (empty -> .)
    INTLIT          reduce using rule 130 (empty -> .)
    }               reduce using rule 130 (empty -> .)
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    local_decls                    shift and go to state 155
    empty                          shift and go to state 156
    var_decl                       shift and go to state 157
    type_spec                      shift and go to state 158

state 122

    (21) param_list -> param_list , param .
    )               reduce using rule 21 (param_list -> param_list , param .)
    ,               reduce using rule 21 (param_list -> param_list , param .)


state 123

    (121) primary_expr -> IDENT . IDENT . ( args_list )
    (               shift and go to state 159


state 124

    (118) primary_expr -> IDENT . SIZE .
    DECREMENT       reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    INCREMENT       reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    %               reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    /               reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    *               reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    -               reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    +               reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    GE              reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    GT              reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    LE              reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    LT              reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    NE              reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    EQ              reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    AND             reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    OR              reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    ]               reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    ;               reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    )               reduce using rule 118 (primary_expr -> IDENT . SIZE .)
    ,               reduce using rule 118 (primary_expr -> IDENT . SIZE .)


state 125

    (120) primary_expr -> IDENT [ expr . ]
    ]               shift and go to state 160


state 126

    (122) primary_expr -> IDENT ( args_list . )
    (72) args_list -> args_list . , expr
    )               shift and go to state 161
    ,               shift and go to state 162


state 127

    (71) args_list -> expr .
    )               reduce using rule 71 (args_list -> expr .)
    ,               reduce using rule 71 (args_list -> expr .)


state 128

    (73) args_list -> empty .
    )               reduce using rule 73 (args_list -> empty .)
    ,               reduce using rule 73 (args_list -> empty .)


state 129

    (77) var_decl -> type_spec IDENT [ expr ] ; .
    IDENT           reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    CLASS           reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    STRING          reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    BOOL            reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    FLOAT           reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    INT             reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    VOID            reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    $end            reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    PUBLIC          reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    PRIVATE         reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    }               reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    SPRINTF         reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    THIS            reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    FOR             reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    SUPER           reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    PRINTF          reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    CONTINUE        reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    BREAK           reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    WHILE           reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    RETURN          reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    IF              reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    {               reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    (               reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    NOT             reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    !               reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    -               reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    +               reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    DECREMENT       reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    INCREMENT       reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    FALSE           reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    TRUE            reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    STRINGLIT       reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    BOOLIT          reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    FLOATLIT        reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)
    INTLIT          reduce using rule 77 (var_decl -> type_spec IDENT [ expr ] ; .)


state 130

    (89) logical_or_expr -> logical_or_expr OR logical_and_expr .
    (91) logical_and_expr -> logical_and_expr . AND equality_expr
    OR              reduce using rule 89 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    ]               reduce using rule 89 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    ;               reduce using rule 89 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    )               reduce using rule 89 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    ,               reduce using rule 89 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    AND             shift and go to state 86


state 131

    (91) logical_and_expr -> logical_and_expr AND equality_expr .
    (93) equality_expr -> equality_expr . NE relational_expr
    (94) equality_expr -> equality_expr . EQ relational_expr
    AND             reduce using rule 91 (logical_and_expr -> logical_and_expr AND equality_expr .)
    OR              reduce using rule 91 (logical_and_expr -> logical_and_expr AND equality_expr .)
    ]               reduce using rule 91 (logical_and_expr -> logical_and_expr AND equality_expr .)
    ;               reduce using rule 91 (logical_and_expr -> logical_and_expr AND equality_expr .)
    )               reduce using rule 91 (logical_and_expr -> logical_and_expr AND equality_expr .)
    ,               reduce using rule 91 (logical_and_expr -> logical_and_expr AND equality_expr .)
    NE              shift and go to state 87
    EQ              shift and go to state 88


state 132

    (93) equality_expr -> equality_expr NE relational_expr .
    (96) relational_expr -> relational_expr . GE additive_expr
    (97) relational_expr -> relational_expr . GT additive_expr
    (98) relational_expr -> relational_expr . LE additive_expr
    (99) relational_expr -> relational_expr . LT additive_expr
    NE              reduce using rule 93 (equality_expr -> equality_expr NE relational_expr .)
    EQ              reduce using rule 93 (equality_expr -> equality_expr NE relational_expr .)
    AND             reduce using rule 93 (equality_expr -> equality_expr NE relational_expr .)
    OR              reduce using rule 93 (equality_expr -> equality_expr NE relational_expr .)
    ]               reduce using rule 93 (equality_expr -> equality_expr NE relational_expr .)
    ;               reduce using rule 93 (equality_expr -> equality_expr NE relational_expr .)
    )               reduce using rule 93 (equality_expr -> equality_expr NE relational_expr .)
    ,               reduce using rule 93 (equality_expr -> equality_expr NE relational_expr .)
    GE              shift and go to state 89
    GT              shift and go to state 90
    LE              shift and go to state 91
    LT              shift and go to state 92


state 133

    (94) equality_expr -> equality_expr EQ relational_expr .
    (96) relational_expr -> relational_expr . GE additive_expr
    (97) relational_expr -> relational_expr . GT additive_expr
    (98) relational_expr -> relational_expr . LE additive_expr
    (99) relational_expr -> relational_expr . LT additive_expr
    NE              reduce using rule 94 (equality_expr -> equality_expr EQ relational_expr .)
    EQ              reduce using rule 94 (equality_expr -> equality_expr EQ relational_expr .)
    AND             reduce using rule 94 (equality_expr -> equality_expr EQ relational_expr .)
    OR              reduce using rule 94 (equality_expr -> equality_expr EQ relational_expr .)
    ]               reduce using rule 94 (equality_expr -> equality_expr EQ relational_expr .)
    ;               reduce using rule 94 (equality_expr -> equality_expr EQ relational_expr .)
    )               reduce using rule 94 (equality_expr -> equality_expr EQ relational_expr .)
    ,               reduce using rule 94 (equality_expr -> equality_expr EQ relational_expr .)
    GE              shift and go to state 89
    GT              shift and go to state 90
    LE              shift and go to state 91
    LT              shift and go to state 92


state 134

    (96) relational_expr -> relational_expr GE additive_expr .
    (101) additive_expr -> additive_expr . - multiplicative_expr
    (102) additive_expr -> additive_expr . + multiplicative_expr
    GE              reduce using rule 96 (relational_expr -> relational_expr GE additive_expr .)
    GT              reduce using rule 96 (relational_expr -> relational_expr GE additive_expr .)
    LE              reduce using rule 96 (relational_expr -> relational_expr GE additive_expr .)
    LT              reduce using rule 96 (relational_expr -> relational_expr GE additive_expr .)
    NE              reduce using rule 96 (relational_expr -> relational_expr GE additive_expr .)
    EQ              reduce using rule 96 (relational_expr -> relational_expr GE additive_expr .)
    AND             reduce using rule 96 (relational_expr -> relational_expr GE additive_expr .)
    OR              reduce using rule 96 (relational_expr -> relational_expr GE additive_expr .)
    ]               reduce using rule 96 (relational_expr -> relational_expr GE additive_expr .)
    ;               reduce using rule 96 (relational_expr -> relational_expr GE additive_expr .)
    )               reduce using rule 96 (relational_expr -> relational_expr GE additive_expr .)
    ,               reduce using rule 96 (relational_expr -> relational_expr GE additive_expr .)
    -               shift and go to state 93
    +               shift and go to state 94


state 135

    (97) relational_expr -> relational_expr GT additive_expr .
    (101) additive_expr -> additive_expr . - multiplicative_expr
    (102) additive_expr -> additive_expr . + multiplicative_expr
    GE              reduce using rule 97 (relational_expr -> relational_expr GT additive_expr .)
    GT              reduce using rule 97 (relational_expr -> relational_expr GT additive_expr .)
    LE              reduce using rule 97 (relational_expr -> relational_expr GT additive_expr .)
    LT              reduce using rule 97 (relational_expr -> relational_expr GT additive_expr .)
    NE              reduce using rule 97 (relational_expr -> relational_expr GT additive_expr .)
    EQ              reduce using rule 97 (relational_expr -> relational_expr GT additive_expr .)
    AND             reduce using rule 97 (relational_expr -> relational_expr GT additive_expr .)
    OR              reduce using rule 97 (relational_expr -> relational_expr GT additive_expr .)
    ]               reduce using rule 97 (relational_expr -> relational_expr GT additive_expr .)
    ;               reduce using rule 97 (relational_expr -> relational_expr GT additive_expr .)
    )               reduce using rule 97 (relational_expr -> relational_expr GT additive_expr .)
    ,               reduce using rule 97 (relational_expr -> relational_expr GT additive_expr .)
    -               shift and go to state 93
    +               shift and go to state 94


state 136

    (98) relational_expr -> relational_expr LE additive_expr .
    (101) additive_expr -> additive_expr . - multiplicative_expr
    (102) additive_expr -> additive_expr . + multiplicative_expr
    GE              reduce using rule 98 (relational_expr -> relational_expr LE additive_expr .)
    GT              reduce using rule 98 (relational_expr -> relational_expr LE additive_expr .)
    LE              reduce using rule 98 (relational_expr -> relational_expr LE additive_expr .)
    LT              reduce using rule 98 (relational_expr -> relational_expr LE additive_expr .)
    NE              reduce using rule 98 (relational_expr -> relational_expr LE additive_expr .)
    EQ              reduce using rule 98 (relational_expr -> relational_expr LE additive_expr .)
    AND             reduce using rule 98 (relational_expr -> relational_expr LE additive_expr .)
    OR              reduce using rule 98 (relational_expr -> relational_expr LE additive_expr .)
    ]               reduce using rule 98 (relational_expr -> relational_expr LE additive_expr .)
    ;               reduce using rule 98 (relational_expr -> relational_expr LE additive_expr .)
    )               reduce using rule 98 (relational_expr -> relational_expr LE additive_expr .)
    ,               reduce using rule 98 (relational_expr -> relational_expr LE additive_expr .)
    -               shift and go to state 93
    +               shift and go to state 94


state 137

    (99) relational_expr -> relational_expr LT additive_expr .
    (101) additive_expr -> additive_expr . - multiplicative_expr
    (102) additive_expr -> additive_expr . + multiplicative_expr
    GE              reduce using rule 99 (relational_expr -> relational_expr LT additive_expr .)
    GT              reduce using rule 99 (relational_expr -> relational_expr LT additive_expr .)
    LE              reduce using rule 99 (relational_expr -> relational_expr LT additive_expr .)
    LT              reduce using rule 99 (relational_expr -> relational_expr LT additive_expr .)
    NE              reduce using rule 99 (relational_expr -> relational_expr LT additive_expr .)
    EQ              reduce using rule 99 (relational_expr -> relational_expr LT additive_expr .)
    AND             reduce using rule 99 (relational_expr -> relational_expr LT additive_expr .)
    OR              reduce using rule 99 (relational_expr -> relational_expr LT additive_expr .)
    ]               reduce using rule 99 (relational_expr -> relational_expr LT additive_expr .)
    ;               reduce using rule 99 (relational_expr -> relational_expr LT additive_expr .)
    )               reduce using rule 99 (relational_expr -> relational_expr LT additive_expr .)
    ,               reduce using rule 99 (relational_expr -> relational_expr LT additive_expr .)
    -               shift and go to state 93
    +               shift and go to state 94


state 138

    (101) additive_expr -> additive_expr - multiplicative_expr .
    (104) multiplicative_expr -> multiplicative_expr . % unary_expr
    (105) multiplicative_expr -> multiplicative_expr . / unary_expr
    (106) multiplicative_expr -> multiplicative_expr . * unary_expr
    -               reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    +               reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    GE              reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    GT              reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    LE              reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    LT              reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    NE              reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    EQ              reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    AND             reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    OR              reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    ]               reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    ;               reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    )               reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    ,               reduce using rule 101 (additive_expr -> additive_expr - multiplicative_expr .)
    %               shift and go to state 95
    /               shift and go to state 96
    *               shift and go to state 97


state 139

    (102) additive_expr -> additive_expr + multiplicative_expr .
    (104) multiplicative_expr -> multiplicative_expr . % unary_expr
    (105) multiplicative_expr -> multiplicative_expr . / unary_expr
    (106) multiplicative_expr -> multiplicative_expr . * unary_expr
    -               reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    +               reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    GE              reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    GT              reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    LE              reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    LT              reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    NE              reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    EQ              reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    AND             reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    OR              reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    ]               reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    ;               reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    )               reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    ,               reduce using rule 102 (additive_expr -> additive_expr + multiplicative_expr .)
    %               shift and go to state 95
    /               shift and go to state 96
    *               shift and go to state 97


state 140

    (104) multiplicative_expr -> multiplicative_expr % unary_expr .
    %               reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    /               reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    *               reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    -               reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    +               reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    GE              reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    GT              reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    LE              reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    LT              reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    NE              reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    EQ              reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    AND             reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    OR              reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    ]               reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    ;               reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    )               reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    ,               reduce using rule 104 (multiplicative_expr -> multiplicative_expr % unary_expr .)


state 141

    (105) multiplicative_expr -> multiplicative_expr / unary_expr .
    %               reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    /               reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    *               reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    -               reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    +               reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    GE              reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    GT              reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    LE              reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    LT              reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    NE              reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    EQ              reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    AND             reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    OR              reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    ]               reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    ;               reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    )               reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    ,               reduce using rule 105 (multiplicative_expr -> multiplicative_expr / unary_expr .)


state 142

    (106) multiplicative_expr -> multiplicative_expr * unary_expr .
    %               reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    /               reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    *               reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    -               reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    +               reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    GE              reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    GT              reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    LE              reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    LT              reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    NE              reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    EQ              reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    AND             reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    OR              reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    ]               reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    ;               reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    )               reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    ,               reduce using rule 106 (multiplicative_expr -> multiplicative_expr * unary_expr .)


state 143

    (107) unary_expr -> ( type_spec ) . unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    unary_expr                     shift and go to state 163
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 144

    (129) primary_expr -> ( expr ) .
    DECREMENT       reduce using rule 129 (primary_expr -> ( expr ) .)
    INCREMENT       reduce using rule 129 (primary_expr -> ( expr ) .)
    %               reduce using rule 129 (primary_expr -> ( expr ) .)
    /               reduce using rule 129 (primary_expr -> ( expr ) .)
    *               reduce using rule 129 (primary_expr -> ( expr ) .)
    -               reduce using rule 129 (primary_expr -> ( expr ) .)
    +               reduce using rule 129 (primary_expr -> ( expr ) .)
    GE              reduce using rule 129 (primary_expr -> ( expr ) .)
    GT              reduce using rule 129 (primary_expr -> ( expr ) .)
    LE              reduce using rule 129 (primary_expr -> ( expr ) .)
    LT              reduce using rule 129 (primary_expr -> ( expr ) .)
    NE              reduce using rule 129 (primary_expr -> ( expr ) .)
    EQ              reduce using rule 129 (primary_expr -> ( expr ) .)
    AND             reduce using rule 129 (primary_expr -> ( expr ) .)
    OR              reduce using rule 129 (primary_expr -> ( expr ) .)
    ]               reduce using rule 129 (primary_expr -> ( expr ) .)
    ;               reduce using rule 129 (primary_expr -> ( expr ) .)
    )               reduce using rule 129 (primary_expr -> ( expr ) .)
    ,               reduce using rule 129 (primary_expr -> ( expr ) .)


state 145

    (57) assignment_expr -> IDENT [ expr . ] = assignment_expr
    (120) primary_expr -> IDENT [ expr . ]
    ]               shift and go to state 164


state 146

    (63) assignment_expr -> IDENT = assignment_expr .
    ;               reduce using rule 63 (assignment_expr -> IDENT = assignment_expr .)
    )               reduce using rule 63 (assignment_expr -> IDENT = assignment_expr .)


state 147

    (59) assignment_expr -> IDENT DIV_ASSIGN assignment_expr .
    ;               reduce using rule 59 (assignment_expr -> IDENT DIV_ASSIGN assignment_expr .)
    )               reduce using rule 59 (assignment_expr -> IDENT DIV_ASSIGN assignment_expr .)


state 148

    (60) assignment_expr -> IDENT MULT_ASSIGN assignment_expr .
    ;               reduce using rule 60 (assignment_expr -> IDENT MULT_ASSIGN assignment_expr .)
    )               reduce using rule 60 (assignment_expr -> IDENT MULT_ASSIGN assignment_expr .)


state 149

    (61) assignment_expr -> IDENT MINUS_ASSIGN assignment_expr .
    ;               reduce using rule 61 (assignment_expr -> IDENT MINUS_ASSIGN assignment_expr .)
    )               reduce using rule 61 (assignment_expr -> IDENT MINUS_ASSIGN assignment_expr .)


state 150

    (62) assignment_expr -> IDENT PLUS_ASSIGN assignment_expr .
    ;               reduce using rule 62 (assignment_expr -> IDENT PLUS_ASSIGN assignment_expr .)
    )               reduce using rule 62 (assignment_expr -> IDENT PLUS_ASSIGN assignment_expr .)


state 151

    (80) object_decl -> IDENT IDENT = NEW IDENT ( args_list . ) ;
    (72) args_list -> args_list . , expr
    )               shift and go to state 165
    ,               shift and go to state 162


state 152

    (18) constructor_decl -> IDENT ( param_list ) . compound_stmt
    (25) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 121

    compound_stmt                  shift and go to state 166

state 153

    (17) method_decl -> type_spec IDENT ( param_list . ) compound_stmt
    (21) param_list -> param_list . , param
    )               shift and go to state 167
    ,               shift and go to state 80


state 154

    (23) param -> type_spec IDENT [ INTLIT . ]
    ]               shift and go to state 168


state 155

    (25) compound_stmt -> { local_decls . stmt_list }
    (28) stmt_list -> . stmt stmt_list
    (29) stmt_list -> . stmt local_decls stmt_list
    (30) stmt_list -> . empty
    (31) stmt -> . sprintf_stmt
    (32) stmt -> . this_stmt
    (33) stmt -> . for_stmt
    (34) stmt -> . object_decl
    (35) stmt -> . super_stmt
    (36) stmt -> . print_stmt
    (37) stmt -> . continue_stmt
    (38) stmt -> . break_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . return_stmt
    (41) stmt -> . if_stmt
    (42) stmt -> . compound_stmt
    (43) stmt -> . expr_stmt
    (130) empty -> .
    (75) sprintf_stmt -> . SPRINTF ( expr , args_list ) ;
    (76) this_stmt -> . THIS ;
    (44) for_stmt -> . FOR ( for_init ; for_cond ; for_incr ) compound_stmt
    (80) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (81) object_decl -> . IDENT IDENT ;
    (55) super_stmt -> . SUPER ( args_list ) ;
    (74) print_stmt -> . PRINTF ( expr , args_list ) ;
    (70) continue_stmt -> . CONTINUE ;
    (69) break_stmt -> . BREAK ;
    (68) while_stmt -> . WHILE ( expr ) stmt
    (66) return_stmt -> . RETURN expr ;
    (67) return_stmt -> . RETURN ;
    (64) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (65) if_stmt -> . IF ( expr ) stmt
    (25) compound_stmt -> . { local_decls stmt_list }
    (56) expr_stmt -> . assignment_expr ;
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    }               reduce using rule 130 (empty -> .)
    SPRINTF         shift and go to state 185
    THIS            shift and go to state 186
    FOR             shift and go to state 187
    IDENT           shift and go to state 188
    SUPER           shift and go to state 189
    PRINTF          shift and go to state 190
    CONTINUE        shift and go to state 191
    BREAK           shift and go to state 192
    WHILE           shift and go to state 193
    RETURN          shift and go to state 194
    IF              shift and go to state 195
    {               shift and go to state 121
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    stmt_list                      shift and go to state 169
    stmt                           shift and go to state 170
    empty                          shift and go to state 171
    sprintf_stmt                   shift and go to state 172
    this_stmt                      shift and go to state 173
    for_stmt                       shift and go to state 174
    object_decl                    shift and go to state 175
    super_stmt                     shift and go to state 176
    print_stmt                     shift and go to state 177
    continue_stmt                  shift and go to state 178
    break_stmt                     shift and go to state 179
    while_stmt                     shift and go to state 180
    return_stmt                    shift and go to state 181
    if_stmt                        shift and go to state 182
    compound_stmt                  shift and go to state 183
    expr_stmt                      shift and go to state 184
    expr                           shift and go to state 69
    assignment_expr                shift and go to state 196
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 156

    (26) local_decls -> empty .
    SPRINTF         reduce using rule 26 (local_decls -> empty .)
    THIS            reduce using rule 26 (local_decls -> empty .)
    FOR             reduce using rule 26 (local_decls -> empty .)
    IDENT           reduce using rule 26 (local_decls -> empty .)
    SUPER           reduce using rule 26 (local_decls -> empty .)
    PRINTF          reduce using rule 26 (local_decls -> empty .)
    CONTINUE        reduce using rule 26 (local_decls -> empty .)
    BREAK           reduce using rule 26 (local_decls -> empty .)
    WHILE           reduce using rule 26 (local_decls -> empty .)
    RETURN          reduce using rule 26 (local_decls -> empty .)
    IF              reduce using rule 26 (local_decls -> empty .)
    {               reduce using rule 26 (local_decls -> empty .)
    (               reduce using rule 26 (local_decls -> empty .)
    NOT             reduce using rule 26 (local_decls -> empty .)
    !               reduce using rule 26 (local_decls -> empty .)
    -               reduce using rule 26 (local_decls -> empty .)
    +               reduce using rule 26 (local_decls -> empty .)
    DECREMENT       reduce using rule 26 (local_decls -> empty .)
    INCREMENT       reduce using rule 26 (local_decls -> empty .)
    FALSE           reduce using rule 26 (local_decls -> empty .)
    TRUE            reduce using rule 26 (local_decls -> empty .)
    STRINGLIT       reduce using rule 26 (local_decls -> empty .)
    BOOLIT          reduce using rule 26 (local_decls -> empty .)
    FLOATLIT        reduce using rule 26 (local_decls -> empty .)
    INTLIT          reduce using rule 26 (local_decls -> empty .)
    }               reduce using rule 26 (local_decls -> empty .)


state 157

    (27) local_decls -> var_decl . local_decls
    (26) local_decls -> . empty
    (27) local_decls -> . var_decl local_decls
    (130) empty -> .
    (77) var_decl -> . type_spec IDENT [ expr ] ;
    (78) var_decl -> . type_spec IDENT = assignment_expr ;
    (79) var_decl -> . type_spec IDENT ;
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    SPRINTF         reduce using rule 130 (empty -> .)
    THIS            reduce using rule 130 (empty -> .)
    FOR             reduce using rule 130 (empty -> .)
    IDENT           reduce using rule 130 (empty -> .)
    SUPER           reduce using rule 130 (empty -> .)
    PRINTF          reduce using rule 130 (empty -> .)
    CONTINUE        reduce using rule 130 (empty -> .)
    BREAK           reduce using rule 130 (empty -> .)
    WHILE           reduce using rule 130 (empty -> .)
    RETURN          reduce using rule 130 (empty -> .)
    IF              reduce using rule 130 (empty -> .)
    {               reduce using rule 130 (empty -> .)
    (               reduce using rule 130 (empty -> .)
    NOT             reduce using rule 130 (empty -> .)
    !               reduce using rule 130 (empty -> .)
    -               reduce using rule 130 (empty -> .)
    +               reduce using rule 130 (empty -> .)
    DECREMENT       reduce using rule 130 (empty -> .)
    INCREMENT       reduce using rule 130 (empty -> .)
    FALSE           reduce using rule 130 (empty -> .)
    TRUE            reduce using rule 130 (empty -> .)
    STRINGLIT       reduce using rule 130 (empty -> .)
    BOOLIT          reduce using rule 130 (empty -> .)
    FLOATLIT        reduce using rule 130 (empty -> .)
    INTLIT          reduce using rule 130 (empty -> .)
    }               reduce using rule 130 (empty -> .)
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    var_decl                       shift and go to state 157
    local_decls                    shift and go to state 197
    empty                          shift and go to state 156
    type_spec                      shift and go to state 158

state 158

    (77) var_decl -> type_spec . IDENT [ expr ] ;
    (78) var_decl -> type_spec . IDENT = assignment_expr ;
    (79) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 198


state 159

    (121) primary_expr -> IDENT . IDENT ( . args_list )
    (71) args_list -> . expr
    (72) args_list -> . args_list , expr
    (73) args_list -> . empty
    (87) expr -> . logical_or_expr
    (130) empty -> .
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    )               reduce using rule 130 (empty -> .)
    ,               reduce using rule 130 (empty -> .)
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    args_list                      shift and go to state 199
    expr                           shift and go to state 127
    empty                          shift and go to state 128
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 160

    (120) primary_expr -> IDENT [ expr ] .
    DECREMENT       reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    INCREMENT       reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    %               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    /               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    *               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    -               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    +               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    GE              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    GT              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    LE              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    LT              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    NE              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    EQ              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    AND             reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    OR              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    ]               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    ;               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    )               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    ,               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)


state 161

    (122) primary_expr -> IDENT ( args_list ) .
    DECREMENT       reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    INCREMENT       reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    %               reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    /               reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    *               reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    -               reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    +               reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    GE              reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    GT              reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    LE              reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    LT              reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    NE              reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    EQ              reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    AND             reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    OR              reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    ]               reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    ;               reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    )               reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)
    ,               reduce using rule 122 (primary_expr -> IDENT ( args_list ) .)


state 162

    (72) args_list -> args_list , . expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 200
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 163

    (107) unary_expr -> ( type_spec ) unary_expr .
    %               reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    /               reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    *               reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    -               reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    +               reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    GE              reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    GT              reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    LE              reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    LT              reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    NE              reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    EQ              reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    AND             reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    OR              reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    ]               reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    ;               reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    )               reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)
    ,               reduce using rule 107 (unary_expr -> ( type_spec ) unary_expr .)


state 164

    (57) assignment_expr -> IDENT [ expr ] . = assignment_expr
    (120) primary_expr -> IDENT [ expr ] .
    =               shift and go to state 201
    DECREMENT       reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    INCREMENT       reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    %               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    /               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    *               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    -               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    +               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    GE              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    GT              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    LE              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    LT              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    NE              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    EQ              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    AND             reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    OR              reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    ;               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)
    )               reduce using rule 120 (primary_expr -> IDENT [ expr ] .)


state 165

    (80) object_decl -> IDENT IDENT = NEW IDENT ( args_list ) . ;
    ;               shift and go to state 202


state 166

    (18) constructor_decl -> IDENT ( param_list ) compound_stmt .
    PUBLIC          reduce using rule 18 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    PRIVATE         reduce using rule 18 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    IDENT           reduce using rule 18 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    STRING          reduce using rule 18 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    BOOL            reduce using rule 18 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    FLOAT           reduce using rule 18 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    INT             reduce using rule 18 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    VOID            reduce using rule 18 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    }               reduce using rule 18 (constructor_decl -> IDENT ( param_list ) compound_stmt .)


state 167

    (17) method_decl -> type_spec IDENT ( param_list ) . compound_stmt
    (25) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 121

    compound_stmt                  shift and go to state 203

state 168

    (23) param -> type_spec IDENT [ INTLIT ] .
    )               reduce using rule 23 (param -> type_spec IDENT [ INTLIT ] .)
    ,               reduce using rule 23 (param -> type_spec IDENT [ INTLIT ] .)


state 169

    (25) compound_stmt -> { local_decls stmt_list . }
    }               shift and go to state 204


state 170

    (28) stmt_list -> stmt . stmt_list
    (29) stmt_list -> stmt . local_decls stmt_list
    (28) stmt_list -> . stmt stmt_list
    (29) stmt_list -> . stmt local_decls stmt_list
    (30) stmt_list -> . empty
    (26) local_decls -> . empty
    (27) local_decls -> . var_decl local_decls
    (31) stmt -> . sprintf_stmt
    (32) stmt -> . this_stmt
    (33) stmt -> . for_stmt
    (34) stmt -> . object_decl
    (35) stmt -> . super_stmt
    (36) stmt -> . print_stmt
    (37) stmt -> . continue_stmt
    (38) stmt -> . break_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . return_stmt
    (41) stmt -> . if_stmt
    (42) stmt -> . compound_stmt
    (43) stmt -> . expr_stmt
    (130) empty -> .
    (77) var_decl -> . type_spec IDENT [ expr ] ;
    (78) var_decl -> . type_spec IDENT = assignment_expr ;
    (79) var_decl -> . type_spec IDENT ;
    (75) sprintf_stmt -> . SPRINTF ( expr , args_list ) ;
    (76) this_stmt -> . THIS ;
    (44) for_stmt -> . FOR ( for_init ; for_cond ; for_incr ) compound_stmt
    (80) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (81) object_decl -> . IDENT IDENT ;
    (55) super_stmt -> . SUPER ( args_list ) ;
    (74) print_stmt -> . PRINTF ( expr , args_list ) ;
    (70) continue_stmt -> . CONTINUE ;
    (69) break_stmt -> . BREAK ;
    (68) while_stmt -> . WHILE ( expr ) stmt
    (66) return_stmt -> . RETURN expr ;
    (67) return_stmt -> . RETURN ;
    (64) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (65) if_stmt -> . IF ( expr ) stmt
    (25) compound_stmt -> . { local_decls stmt_list }
    (56) expr_stmt -> . assignment_expr ;
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
  ! shift/reduce conflict for SPRINTF resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for ! resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for DECREMENT resolved as shift
  ! shift/reduce conflict for INCREMENT resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for STRINGLIT resolved as shift
  ! shift/reduce conflict for BOOLIT resolved as shift
  ! shift/reduce conflict for FLOATLIT resolved as shift
  ! shift/reduce conflict for INTLIT resolved as shift
    }               reduce using rule 130 (empty -> .)
    SPRINTF         shift and go to state 185
    THIS            shift and go to state 186
    FOR             shift and go to state 187
    IDENT           shift and go to state 188
    SUPER           shift and go to state 189
    PRINTF          shift and go to state 190
    CONTINUE        shift and go to state 191
    BREAK           shift and go to state 192
    WHILE           shift and go to state 193
    RETURN          shift and go to state 194
    IF              shift and go to state 195
    {               shift and go to state 121
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    stmt                           shift and go to state 170
    stmt_list                      shift and go to state 205
    local_decls                    shift and go to state 206
    empty                          shift and go to state 207
    var_decl                       shift and go to state 157
    sprintf_stmt                   shift and go to state 172
    this_stmt                      shift and go to state 173
    for_stmt                       shift and go to state 174
    object_decl                    shift and go to state 175
    super_stmt                     shift and go to state 176
    print_stmt                     shift and go to state 177
    continue_stmt                  shift and go to state 178
    break_stmt                     shift and go to state 179
    while_stmt                     shift and go to state 180
    return_stmt                    shift and go to state 181
    if_stmt                        shift and go to state 182
    compound_stmt                  shift and go to state 183
    expr_stmt                      shift and go to state 184
    type_spec                      shift and go to state 158
    expr                           shift and go to state 69
    assignment_expr                shift and go to state 196
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 171

    (30) stmt_list -> empty .
    }               reduce using rule 30 (stmt_list -> empty .)


state 172

    (31) stmt -> sprintf_stmt .
    SPRINTF         reduce using rule 31 (stmt -> sprintf_stmt .)
    THIS            reduce using rule 31 (stmt -> sprintf_stmt .)
    FOR             reduce using rule 31 (stmt -> sprintf_stmt .)
    IDENT           reduce using rule 31 (stmt -> sprintf_stmt .)
    SUPER           reduce using rule 31 (stmt -> sprintf_stmt .)
    PRINTF          reduce using rule 31 (stmt -> sprintf_stmt .)
    CONTINUE        reduce using rule 31 (stmt -> sprintf_stmt .)
    BREAK           reduce using rule 31 (stmt -> sprintf_stmt .)
    WHILE           reduce using rule 31 (stmt -> sprintf_stmt .)
    RETURN          reduce using rule 31 (stmt -> sprintf_stmt .)
    IF              reduce using rule 31 (stmt -> sprintf_stmt .)
    {               reduce using rule 31 (stmt -> sprintf_stmt .)
    STRING          reduce using rule 31 (stmt -> sprintf_stmt .)
    BOOL            reduce using rule 31 (stmt -> sprintf_stmt .)
    FLOAT           reduce using rule 31 (stmt -> sprintf_stmt .)
    INT             reduce using rule 31 (stmt -> sprintf_stmt .)
    VOID            reduce using rule 31 (stmt -> sprintf_stmt .)
    (               reduce using rule 31 (stmt -> sprintf_stmt .)
    NOT             reduce using rule 31 (stmt -> sprintf_stmt .)
    !               reduce using rule 31 (stmt -> sprintf_stmt .)
    -               reduce using rule 31 (stmt -> sprintf_stmt .)
    +               reduce using rule 31 (stmt -> sprintf_stmt .)
    DECREMENT       reduce using rule 31 (stmt -> sprintf_stmt .)
    INCREMENT       reduce using rule 31 (stmt -> sprintf_stmt .)
    FALSE           reduce using rule 31 (stmt -> sprintf_stmt .)
    TRUE            reduce using rule 31 (stmt -> sprintf_stmt .)
    STRINGLIT       reduce using rule 31 (stmt -> sprintf_stmt .)
    BOOLIT          reduce using rule 31 (stmt -> sprintf_stmt .)
    FLOATLIT        reduce using rule 31 (stmt -> sprintf_stmt .)
    INTLIT          reduce using rule 31 (stmt -> sprintf_stmt .)
    }               reduce using rule 31 (stmt -> sprintf_stmt .)
    ELSE            reduce using rule 31 (stmt -> sprintf_stmt .)


state 173

    (32) stmt -> this_stmt .
    SPRINTF         reduce using rule 32 (stmt -> this_stmt .)
    THIS            reduce using rule 32 (stmt -> this_stmt .)
    FOR             reduce using rule 32 (stmt -> this_stmt .)
    IDENT           reduce using rule 32 (stmt -> this_stmt .)
    SUPER           reduce using rule 32 (stmt -> this_stmt .)
    PRINTF          reduce using rule 32 (stmt -> this_stmt .)
    CONTINUE        reduce using rule 32 (stmt -> this_stmt .)
    BREAK           reduce using rule 32 (stmt -> this_stmt .)
    WHILE           reduce using rule 32 (stmt -> this_stmt .)
    RETURN          reduce using rule 32 (stmt -> this_stmt .)
    IF              reduce using rule 32 (stmt -> this_stmt .)
    {               reduce using rule 32 (stmt -> this_stmt .)
    STRING          reduce using rule 32 (stmt -> this_stmt .)
    BOOL            reduce using rule 32 (stmt -> this_stmt .)
    FLOAT           reduce using rule 32 (stmt -> this_stmt .)
    INT             reduce using rule 32 (stmt -> this_stmt .)
    VOID            reduce using rule 32 (stmt -> this_stmt .)
    (               reduce using rule 32 (stmt -> this_stmt .)
    NOT             reduce using rule 32 (stmt -> this_stmt .)
    !               reduce using rule 32 (stmt -> this_stmt .)
    -               reduce using rule 32 (stmt -> this_stmt .)
    +               reduce using rule 32 (stmt -> this_stmt .)
    DECREMENT       reduce using rule 32 (stmt -> this_stmt .)
    INCREMENT       reduce using rule 32 (stmt -> this_stmt .)
    FALSE           reduce using rule 32 (stmt -> this_stmt .)
    TRUE            reduce using rule 32 (stmt -> this_stmt .)
    STRINGLIT       reduce using rule 32 (stmt -> this_stmt .)
    BOOLIT          reduce using rule 32 (stmt -> this_stmt .)
    FLOATLIT        reduce using rule 32 (stmt -> this_stmt .)
    INTLIT          reduce using rule 32 (stmt -> this_stmt .)
    }               reduce using rule 32 (stmt -> this_stmt .)
    ELSE            reduce using rule 32 (stmt -> this_stmt .)


state 174

    (33) stmt -> for_stmt .
    SPRINTF         reduce using rule 33 (stmt -> for_stmt .)
    THIS            reduce using rule 33 (stmt -> for_stmt .)
    FOR             reduce using rule 33 (stmt -> for_stmt .)
    IDENT           reduce using rule 33 (stmt -> for_stmt .)
    SUPER           reduce using rule 33 (stmt -> for_stmt .)
    PRINTF          reduce using rule 33 (stmt -> for_stmt .)
    CONTINUE        reduce using rule 33 (stmt -> for_stmt .)
    BREAK           reduce using rule 33 (stmt -> for_stmt .)
    WHILE           reduce using rule 33 (stmt -> for_stmt .)
    RETURN          reduce using rule 33 (stmt -> for_stmt .)
    IF              reduce using rule 33 (stmt -> for_stmt .)
    {               reduce using rule 33 (stmt -> for_stmt .)
    STRING          reduce using rule 33 (stmt -> for_stmt .)
    BOOL            reduce using rule 33 (stmt -> for_stmt .)
    FLOAT           reduce using rule 33 (stmt -> for_stmt .)
    INT             reduce using rule 33 (stmt -> for_stmt .)
    VOID            reduce using rule 33 (stmt -> for_stmt .)
    (               reduce using rule 33 (stmt -> for_stmt .)
    NOT             reduce using rule 33 (stmt -> for_stmt .)
    !               reduce using rule 33 (stmt -> for_stmt .)
    -               reduce using rule 33 (stmt -> for_stmt .)
    +               reduce using rule 33 (stmt -> for_stmt .)
    DECREMENT       reduce using rule 33 (stmt -> for_stmt .)
    INCREMENT       reduce using rule 33 (stmt -> for_stmt .)
    FALSE           reduce using rule 33 (stmt -> for_stmt .)
    TRUE            reduce using rule 33 (stmt -> for_stmt .)
    STRINGLIT       reduce using rule 33 (stmt -> for_stmt .)
    BOOLIT          reduce using rule 33 (stmt -> for_stmt .)
    FLOATLIT        reduce using rule 33 (stmt -> for_stmt .)
    INTLIT          reduce using rule 33 (stmt -> for_stmt .)
    }               reduce using rule 33 (stmt -> for_stmt .)
    ELSE            reduce using rule 33 (stmt -> for_stmt .)


state 175

    (34) stmt -> object_decl .
    SPRINTF         reduce using rule 34 (stmt -> object_decl .)
    THIS            reduce using rule 34 (stmt -> object_decl .)
    FOR             reduce using rule 34 (stmt -> object_decl .)
    IDENT           reduce using rule 34 (stmt -> object_decl .)
    SUPER           reduce using rule 34 (stmt -> object_decl .)
    PRINTF          reduce using rule 34 (stmt -> object_decl .)
    CONTINUE        reduce using rule 34 (stmt -> object_decl .)
    BREAK           reduce using rule 34 (stmt -> object_decl .)
    WHILE           reduce using rule 34 (stmt -> object_decl .)
    RETURN          reduce using rule 34 (stmt -> object_decl .)
    IF              reduce using rule 34 (stmt -> object_decl .)
    {               reduce using rule 34 (stmt -> object_decl .)
    STRING          reduce using rule 34 (stmt -> object_decl .)
    BOOL            reduce using rule 34 (stmt -> object_decl .)
    FLOAT           reduce using rule 34 (stmt -> object_decl .)
    INT             reduce using rule 34 (stmt -> object_decl .)
    VOID            reduce using rule 34 (stmt -> object_decl .)
    (               reduce using rule 34 (stmt -> object_decl .)
    NOT             reduce using rule 34 (stmt -> object_decl .)
    !               reduce using rule 34 (stmt -> object_decl .)
    -               reduce using rule 34 (stmt -> object_decl .)
    +               reduce using rule 34 (stmt -> object_decl .)
    DECREMENT       reduce using rule 34 (stmt -> object_decl .)
    INCREMENT       reduce using rule 34 (stmt -> object_decl .)
    FALSE           reduce using rule 34 (stmt -> object_decl .)
    TRUE            reduce using rule 34 (stmt -> object_decl .)
    STRINGLIT       reduce using rule 34 (stmt -> object_decl .)
    BOOLIT          reduce using rule 34 (stmt -> object_decl .)
    FLOATLIT        reduce using rule 34 (stmt -> object_decl .)
    INTLIT          reduce using rule 34 (stmt -> object_decl .)
    }               reduce using rule 34 (stmt -> object_decl .)
    ELSE            reduce using rule 34 (stmt -> object_decl .)


state 176

    (35) stmt -> super_stmt .
    SPRINTF         reduce using rule 35 (stmt -> super_stmt .)
    THIS            reduce using rule 35 (stmt -> super_stmt .)
    FOR             reduce using rule 35 (stmt -> super_stmt .)
    IDENT           reduce using rule 35 (stmt -> super_stmt .)
    SUPER           reduce using rule 35 (stmt -> super_stmt .)
    PRINTF          reduce using rule 35 (stmt -> super_stmt .)
    CONTINUE        reduce using rule 35 (stmt -> super_stmt .)
    BREAK           reduce using rule 35 (stmt -> super_stmt .)
    WHILE           reduce using rule 35 (stmt -> super_stmt .)
    RETURN          reduce using rule 35 (stmt -> super_stmt .)
    IF              reduce using rule 35 (stmt -> super_stmt .)
    {               reduce using rule 35 (stmt -> super_stmt .)
    STRING          reduce using rule 35 (stmt -> super_stmt .)
    BOOL            reduce using rule 35 (stmt -> super_stmt .)
    FLOAT           reduce using rule 35 (stmt -> super_stmt .)
    INT             reduce using rule 35 (stmt -> super_stmt .)
    VOID            reduce using rule 35 (stmt -> super_stmt .)
    (               reduce using rule 35 (stmt -> super_stmt .)
    NOT             reduce using rule 35 (stmt -> super_stmt .)
    !               reduce using rule 35 (stmt -> super_stmt .)
    -               reduce using rule 35 (stmt -> super_stmt .)
    +               reduce using rule 35 (stmt -> super_stmt .)
    DECREMENT       reduce using rule 35 (stmt -> super_stmt .)
    INCREMENT       reduce using rule 35 (stmt -> super_stmt .)
    FALSE           reduce using rule 35 (stmt -> super_stmt .)
    TRUE            reduce using rule 35 (stmt -> super_stmt .)
    STRINGLIT       reduce using rule 35 (stmt -> super_stmt .)
    BOOLIT          reduce using rule 35 (stmt -> super_stmt .)
    FLOATLIT        reduce using rule 35 (stmt -> super_stmt .)
    INTLIT          reduce using rule 35 (stmt -> super_stmt .)
    }               reduce using rule 35 (stmt -> super_stmt .)
    ELSE            reduce using rule 35 (stmt -> super_stmt .)


state 177

    (36) stmt -> print_stmt .
    SPRINTF         reduce using rule 36 (stmt -> print_stmt .)
    THIS            reduce using rule 36 (stmt -> print_stmt .)
    FOR             reduce using rule 36 (stmt -> print_stmt .)
    IDENT           reduce using rule 36 (stmt -> print_stmt .)
    SUPER           reduce using rule 36 (stmt -> print_stmt .)
    PRINTF          reduce using rule 36 (stmt -> print_stmt .)
    CONTINUE        reduce using rule 36 (stmt -> print_stmt .)
    BREAK           reduce using rule 36 (stmt -> print_stmt .)
    WHILE           reduce using rule 36 (stmt -> print_stmt .)
    RETURN          reduce using rule 36 (stmt -> print_stmt .)
    IF              reduce using rule 36 (stmt -> print_stmt .)
    {               reduce using rule 36 (stmt -> print_stmt .)
    STRING          reduce using rule 36 (stmt -> print_stmt .)
    BOOL            reduce using rule 36 (stmt -> print_stmt .)
    FLOAT           reduce using rule 36 (stmt -> print_stmt .)
    INT             reduce using rule 36 (stmt -> print_stmt .)
    VOID            reduce using rule 36 (stmt -> print_stmt .)
    (               reduce using rule 36 (stmt -> print_stmt .)
    NOT             reduce using rule 36 (stmt -> print_stmt .)
    !               reduce using rule 36 (stmt -> print_stmt .)
    -               reduce using rule 36 (stmt -> print_stmt .)
    +               reduce using rule 36 (stmt -> print_stmt .)
    DECREMENT       reduce using rule 36 (stmt -> print_stmt .)
    INCREMENT       reduce using rule 36 (stmt -> print_stmt .)
    FALSE           reduce using rule 36 (stmt -> print_stmt .)
    TRUE            reduce using rule 36 (stmt -> print_stmt .)
    STRINGLIT       reduce using rule 36 (stmt -> print_stmt .)
    BOOLIT          reduce using rule 36 (stmt -> print_stmt .)
    FLOATLIT        reduce using rule 36 (stmt -> print_stmt .)
    INTLIT          reduce using rule 36 (stmt -> print_stmt .)
    }               reduce using rule 36 (stmt -> print_stmt .)
    ELSE            reduce using rule 36 (stmt -> print_stmt .)


state 178

    (37) stmt -> continue_stmt .
    SPRINTF         reduce using rule 37 (stmt -> continue_stmt .)
    THIS            reduce using rule 37 (stmt -> continue_stmt .)
    FOR             reduce using rule 37 (stmt -> continue_stmt .)
    IDENT           reduce using rule 37 (stmt -> continue_stmt .)
    SUPER           reduce using rule 37 (stmt -> continue_stmt .)
    PRINTF          reduce using rule 37 (stmt -> continue_stmt .)
    CONTINUE        reduce using rule 37 (stmt -> continue_stmt .)
    BREAK           reduce using rule 37 (stmt -> continue_stmt .)
    WHILE           reduce using rule 37 (stmt -> continue_stmt .)
    RETURN          reduce using rule 37 (stmt -> continue_stmt .)
    IF              reduce using rule 37 (stmt -> continue_stmt .)
    {               reduce using rule 37 (stmt -> continue_stmt .)
    STRING          reduce using rule 37 (stmt -> continue_stmt .)
    BOOL            reduce using rule 37 (stmt -> continue_stmt .)
    FLOAT           reduce using rule 37 (stmt -> continue_stmt .)
    INT             reduce using rule 37 (stmt -> continue_stmt .)
    VOID            reduce using rule 37 (stmt -> continue_stmt .)
    (               reduce using rule 37 (stmt -> continue_stmt .)
    NOT             reduce using rule 37 (stmt -> continue_stmt .)
    !               reduce using rule 37 (stmt -> continue_stmt .)
    -               reduce using rule 37 (stmt -> continue_stmt .)
    +               reduce using rule 37 (stmt -> continue_stmt .)
    DECREMENT       reduce using rule 37 (stmt -> continue_stmt .)
    INCREMENT       reduce using rule 37 (stmt -> continue_stmt .)
    FALSE           reduce using rule 37 (stmt -> continue_stmt .)
    TRUE            reduce using rule 37 (stmt -> continue_stmt .)
    STRINGLIT       reduce using rule 37 (stmt -> continue_stmt .)
    BOOLIT          reduce using rule 37 (stmt -> continue_stmt .)
    FLOATLIT        reduce using rule 37 (stmt -> continue_stmt .)
    INTLIT          reduce using rule 37 (stmt -> continue_stmt .)
    }               reduce using rule 37 (stmt -> continue_stmt .)
    ELSE            reduce using rule 37 (stmt -> continue_stmt .)


state 179

    (38) stmt -> break_stmt .
    SPRINTF         reduce using rule 38 (stmt -> break_stmt .)
    THIS            reduce using rule 38 (stmt -> break_stmt .)
    FOR             reduce using rule 38 (stmt -> break_stmt .)
    IDENT           reduce using rule 38 (stmt -> break_stmt .)
    SUPER           reduce using rule 38 (stmt -> break_stmt .)
    PRINTF          reduce using rule 38 (stmt -> break_stmt .)
    CONTINUE        reduce using rule 38 (stmt -> break_stmt .)
    BREAK           reduce using rule 38 (stmt -> break_stmt .)
    WHILE           reduce using rule 38 (stmt -> break_stmt .)
    RETURN          reduce using rule 38 (stmt -> break_stmt .)
    IF              reduce using rule 38 (stmt -> break_stmt .)
    {               reduce using rule 38 (stmt -> break_stmt .)
    STRING          reduce using rule 38 (stmt -> break_stmt .)
    BOOL            reduce using rule 38 (stmt -> break_stmt .)
    FLOAT           reduce using rule 38 (stmt -> break_stmt .)
    INT             reduce using rule 38 (stmt -> break_stmt .)
    VOID            reduce using rule 38 (stmt -> break_stmt .)
    (               reduce using rule 38 (stmt -> break_stmt .)
    NOT             reduce using rule 38 (stmt -> break_stmt .)
    !               reduce using rule 38 (stmt -> break_stmt .)
    -               reduce using rule 38 (stmt -> break_stmt .)
    +               reduce using rule 38 (stmt -> break_stmt .)
    DECREMENT       reduce using rule 38 (stmt -> break_stmt .)
    INCREMENT       reduce using rule 38 (stmt -> break_stmt .)
    FALSE           reduce using rule 38 (stmt -> break_stmt .)
    TRUE            reduce using rule 38 (stmt -> break_stmt .)
    STRINGLIT       reduce using rule 38 (stmt -> break_stmt .)
    BOOLIT          reduce using rule 38 (stmt -> break_stmt .)
    FLOATLIT        reduce using rule 38 (stmt -> break_stmt .)
    INTLIT          reduce using rule 38 (stmt -> break_stmt .)
    }               reduce using rule 38 (stmt -> break_stmt .)
    ELSE            reduce using rule 38 (stmt -> break_stmt .)


state 180

    (39) stmt -> while_stmt .
    SPRINTF         reduce using rule 39 (stmt -> while_stmt .)
    THIS            reduce using rule 39 (stmt -> while_stmt .)
    FOR             reduce using rule 39 (stmt -> while_stmt .)
    IDENT           reduce using rule 39 (stmt -> while_stmt .)
    SUPER           reduce using rule 39 (stmt -> while_stmt .)
    PRINTF          reduce using rule 39 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 39 (stmt -> while_stmt .)
    BREAK           reduce using rule 39 (stmt -> while_stmt .)
    WHILE           reduce using rule 39 (stmt -> while_stmt .)
    RETURN          reduce using rule 39 (stmt -> while_stmt .)
    IF              reduce using rule 39 (stmt -> while_stmt .)
    {               reduce using rule 39 (stmt -> while_stmt .)
    STRING          reduce using rule 39 (stmt -> while_stmt .)
    BOOL            reduce using rule 39 (stmt -> while_stmt .)
    FLOAT           reduce using rule 39 (stmt -> while_stmt .)
    INT             reduce using rule 39 (stmt -> while_stmt .)
    VOID            reduce using rule 39 (stmt -> while_stmt .)
    (               reduce using rule 39 (stmt -> while_stmt .)
    NOT             reduce using rule 39 (stmt -> while_stmt .)
    !               reduce using rule 39 (stmt -> while_stmt .)
    -               reduce using rule 39 (stmt -> while_stmt .)
    +               reduce using rule 39 (stmt -> while_stmt .)
    DECREMENT       reduce using rule 39 (stmt -> while_stmt .)
    INCREMENT       reduce using rule 39 (stmt -> while_stmt .)
    FALSE           reduce using rule 39 (stmt -> while_stmt .)
    TRUE            reduce using rule 39 (stmt -> while_stmt .)
    STRINGLIT       reduce using rule 39 (stmt -> while_stmt .)
    BOOLIT          reduce using rule 39 (stmt -> while_stmt .)
    FLOATLIT        reduce using rule 39 (stmt -> while_stmt .)
    INTLIT          reduce using rule 39 (stmt -> while_stmt .)
    }               reduce using rule 39 (stmt -> while_stmt .)
    ELSE            reduce using rule 39 (stmt -> while_stmt .)


state 181

    (40) stmt -> return_stmt .
    SPRINTF         reduce using rule 40 (stmt -> return_stmt .)
    THIS            reduce using rule 40 (stmt -> return_stmt .)
    FOR             reduce using rule 40 (stmt -> return_stmt .)
    IDENT           reduce using rule 40 (stmt -> return_stmt .)
    SUPER           reduce using rule 40 (stmt -> return_stmt .)
    PRINTF          reduce using rule 40 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 40 (stmt -> return_stmt .)
    BREAK           reduce using rule 40 (stmt -> return_stmt .)
    WHILE           reduce using rule 40 (stmt -> return_stmt .)
    RETURN          reduce using rule 40 (stmt -> return_stmt .)
    IF              reduce using rule 40 (stmt -> return_stmt .)
    {               reduce using rule 40 (stmt -> return_stmt .)
    STRING          reduce using rule 40 (stmt -> return_stmt .)
    BOOL            reduce using rule 40 (stmt -> return_stmt .)
    FLOAT           reduce using rule 40 (stmt -> return_stmt .)
    INT             reduce using rule 40 (stmt -> return_stmt .)
    VOID            reduce using rule 40 (stmt -> return_stmt .)
    (               reduce using rule 40 (stmt -> return_stmt .)
    NOT             reduce using rule 40 (stmt -> return_stmt .)
    !               reduce using rule 40 (stmt -> return_stmt .)
    -               reduce using rule 40 (stmt -> return_stmt .)
    +               reduce using rule 40 (stmt -> return_stmt .)
    DECREMENT       reduce using rule 40 (stmt -> return_stmt .)
    INCREMENT       reduce using rule 40 (stmt -> return_stmt .)
    FALSE           reduce using rule 40 (stmt -> return_stmt .)
    TRUE            reduce using rule 40 (stmt -> return_stmt .)
    STRINGLIT       reduce using rule 40 (stmt -> return_stmt .)
    BOOLIT          reduce using rule 40 (stmt -> return_stmt .)
    FLOATLIT        reduce using rule 40 (stmt -> return_stmt .)
    INTLIT          reduce using rule 40 (stmt -> return_stmt .)
    }               reduce using rule 40 (stmt -> return_stmt .)
    ELSE            reduce using rule 40 (stmt -> return_stmt .)


state 182

    (41) stmt -> if_stmt .
    SPRINTF         reduce using rule 41 (stmt -> if_stmt .)
    THIS            reduce using rule 41 (stmt -> if_stmt .)
    FOR             reduce using rule 41 (stmt -> if_stmt .)
    IDENT           reduce using rule 41 (stmt -> if_stmt .)
    SUPER           reduce using rule 41 (stmt -> if_stmt .)
    PRINTF          reduce using rule 41 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 41 (stmt -> if_stmt .)
    BREAK           reduce using rule 41 (stmt -> if_stmt .)
    WHILE           reduce using rule 41 (stmt -> if_stmt .)
    RETURN          reduce using rule 41 (stmt -> if_stmt .)
    IF              reduce using rule 41 (stmt -> if_stmt .)
    {               reduce using rule 41 (stmt -> if_stmt .)
    STRING          reduce using rule 41 (stmt -> if_stmt .)
    BOOL            reduce using rule 41 (stmt -> if_stmt .)
    FLOAT           reduce using rule 41 (stmt -> if_stmt .)
    INT             reduce using rule 41 (stmt -> if_stmt .)
    VOID            reduce using rule 41 (stmt -> if_stmt .)
    (               reduce using rule 41 (stmt -> if_stmt .)
    NOT             reduce using rule 41 (stmt -> if_stmt .)
    !               reduce using rule 41 (stmt -> if_stmt .)
    -               reduce using rule 41 (stmt -> if_stmt .)
    +               reduce using rule 41 (stmt -> if_stmt .)
    DECREMENT       reduce using rule 41 (stmt -> if_stmt .)
    INCREMENT       reduce using rule 41 (stmt -> if_stmt .)
    FALSE           reduce using rule 41 (stmt -> if_stmt .)
    TRUE            reduce using rule 41 (stmt -> if_stmt .)
    STRINGLIT       reduce using rule 41 (stmt -> if_stmt .)
    BOOLIT          reduce using rule 41 (stmt -> if_stmt .)
    FLOATLIT        reduce using rule 41 (stmt -> if_stmt .)
    INTLIT          reduce using rule 41 (stmt -> if_stmt .)
    }               reduce using rule 41 (stmt -> if_stmt .)
    ELSE            reduce using rule 41 (stmt -> if_stmt .)


state 183

    (42) stmt -> compound_stmt .
    SPRINTF         reduce using rule 42 (stmt -> compound_stmt .)
    THIS            reduce using rule 42 (stmt -> compound_stmt .)
    FOR             reduce using rule 42 (stmt -> compound_stmt .)
    IDENT           reduce using rule 42 (stmt -> compound_stmt .)
    SUPER           reduce using rule 42 (stmt -> compound_stmt .)
    PRINTF          reduce using rule 42 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 42 (stmt -> compound_stmt .)
    BREAK           reduce using rule 42 (stmt -> compound_stmt .)
    WHILE           reduce using rule 42 (stmt -> compound_stmt .)
    RETURN          reduce using rule 42 (stmt -> compound_stmt .)
    IF              reduce using rule 42 (stmt -> compound_stmt .)
    {               reduce using rule 42 (stmt -> compound_stmt .)
    STRING          reduce using rule 42 (stmt -> compound_stmt .)
    BOOL            reduce using rule 42 (stmt -> compound_stmt .)
    FLOAT           reduce using rule 42 (stmt -> compound_stmt .)
    INT             reduce using rule 42 (stmt -> compound_stmt .)
    VOID            reduce using rule 42 (stmt -> compound_stmt .)
    (               reduce using rule 42 (stmt -> compound_stmt .)
    NOT             reduce using rule 42 (stmt -> compound_stmt .)
    !               reduce using rule 42 (stmt -> compound_stmt .)
    -               reduce using rule 42 (stmt -> compound_stmt .)
    +               reduce using rule 42 (stmt -> compound_stmt .)
    DECREMENT       reduce using rule 42 (stmt -> compound_stmt .)
    INCREMENT       reduce using rule 42 (stmt -> compound_stmt .)
    FALSE           reduce using rule 42 (stmt -> compound_stmt .)
    TRUE            reduce using rule 42 (stmt -> compound_stmt .)
    STRINGLIT       reduce using rule 42 (stmt -> compound_stmt .)
    BOOLIT          reduce using rule 42 (stmt -> compound_stmt .)
    FLOATLIT        reduce using rule 42 (stmt -> compound_stmt .)
    INTLIT          reduce using rule 42 (stmt -> compound_stmt .)
    }               reduce using rule 42 (stmt -> compound_stmt .)
    ELSE            reduce using rule 42 (stmt -> compound_stmt .)


state 184

    (43) stmt -> expr_stmt .
    SPRINTF         reduce using rule 43 (stmt -> expr_stmt .)
    THIS            reduce using rule 43 (stmt -> expr_stmt .)
    FOR             reduce using rule 43 (stmt -> expr_stmt .)
    IDENT           reduce using rule 43 (stmt -> expr_stmt .)
    SUPER           reduce using rule 43 (stmt -> expr_stmt .)
    PRINTF          reduce using rule 43 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 43 (stmt -> expr_stmt .)
    BREAK           reduce using rule 43 (stmt -> expr_stmt .)
    WHILE           reduce using rule 43 (stmt -> expr_stmt .)
    RETURN          reduce using rule 43 (stmt -> expr_stmt .)
    IF              reduce using rule 43 (stmt -> expr_stmt .)
    {               reduce using rule 43 (stmt -> expr_stmt .)
    STRING          reduce using rule 43 (stmt -> expr_stmt .)
    BOOL            reduce using rule 43 (stmt -> expr_stmt .)
    FLOAT           reduce using rule 43 (stmt -> expr_stmt .)
    INT             reduce using rule 43 (stmt -> expr_stmt .)
    VOID            reduce using rule 43 (stmt -> expr_stmt .)
    (               reduce using rule 43 (stmt -> expr_stmt .)
    NOT             reduce using rule 43 (stmt -> expr_stmt .)
    !               reduce using rule 43 (stmt -> expr_stmt .)
    -               reduce using rule 43 (stmt -> expr_stmt .)
    +               reduce using rule 43 (stmt -> expr_stmt .)
    DECREMENT       reduce using rule 43 (stmt -> expr_stmt .)
    INCREMENT       reduce using rule 43 (stmt -> expr_stmt .)
    FALSE           reduce using rule 43 (stmt -> expr_stmt .)
    TRUE            reduce using rule 43 (stmt -> expr_stmt .)
    STRINGLIT       reduce using rule 43 (stmt -> expr_stmt .)
    BOOLIT          reduce using rule 43 (stmt -> expr_stmt .)
    FLOATLIT        reduce using rule 43 (stmt -> expr_stmt .)
    INTLIT          reduce using rule 43 (stmt -> expr_stmt .)
    }               reduce using rule 43 (stmt -> expr_stmt .)
    ELSE            reduce using rule 43 (stmt -> expr_stmt .)


state 185

    (75) sprintf_stmt -> SPRINTF . ( expr , args_list ) ;
    (               shift and go to state 208


state 186

    (76) this_stmt -> THIS . ;
    ;               shift and go to state 209


state 187

    (44) for_stmt -> FOR . ( for_init ; for_cond ; for_incr ) compound_stmt
    (               shift and go to state 210


state 188

    (80) object_decl -> IDENT . IDENT = NEW IDENT ( args_list ) ;
    (81) object_decl -> IDENT . IDENT ;
    (57) assignment_expr -> IDENT . [ expr ] = assignment_expr
    (59) assignment_expr -> IDENT . DIV_ASSIGN assignment_expr
    (60) assignment_expr -> IDENT . MULT_ASSIGN assignment_expr
    (61) assignment_expr -> IDENT . MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> IDENT . PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> IDENT . = assignment_expr
    (118) primary_expr -> IDENT . . SIZE
    (119) primary_expr -> IDENT .
    (120) primary_expr -> IDENT . [ expr ]
    (121) primary_expr -> IDENT . . IDENT ( args_list )
    (122) primary_expr -> IDENT . ( args_list )
    IDENT           shift and go to state 17
    [               shift and go to state 108
    DIV_ASSIGN      shift and go to state 110
    MULT_ASSIGN     shift and go to state 111
    MINUS_ASSIGN    shift and go to state 112
    PLUS_ASSIGN     shift and go to state 113
    =               shift and go to state 109
    .               shift and go to state 81
    DECREMENT       reduce using rule 119 (primary_expr -> IDENT .)
    INCREMENT       reduce using rule 119 (primary_expr -> IDENT .)
    %               reduce using rule 119 (primary_expr -> IDENT .)
    /               reduce using rule 119 (primary_expr -> IDENT .)
    *               reduce using rule 119 (primary_expr -> IDENT .)
    -               reduce using rule 119 (primary_expr -> IDENT .)
    +               reduce using rule 119 (primary_expr -> IDENT .)
    GE              reduce using rule 119 (primary_expr -> IDENT .)
    GT              reduce using rule 119 (primary_expr -> IDENT .)
    LE              reduce using rule 119 (primary_expr -> IDENT .)
    LT              reduce using rule 119 (primary_expr -> IDENT .)
    NE              reduce using rule 119 (primary_expr -> IDENT .)
    EQ              reduce using rule 119 (primary_expr -> IDENT .)
    AND             reduce using rule 119 (primary_expr -> IDENT .)
    OR              reduce using rule 119 (primary_expr -> IDENT .)
    ;               reduce using rule 119 (primary_expr -> IDENT .)
    (               shift and go to state 83


state 189

    (55) super_stmt -> SUPER . ( args_list ) ;
    (               shift and go to state 211


state 190

    (74) print_stmt -> PRINTF . ( expr , args_list ) ;
    (               shift and go to state 212


state 191

    (70) continue_stmt -> CONTINUE . ;
    ;               shift and go to state 213


state 192

    (69) break_stmt -> BREAK . ;
    ;               shift and go to state 214


state 193

    (68) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 215


state 194

    (66) return_stmt -> RETURN . expr ;
    (67) return_stmt -> RETURN . ;
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    ;               shift and go to state 217
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 216
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 195

    (64) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (65) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 218


state 196

    (56) expr_stmt -> assignment_expr . ;
    ;               shift and go to state 219


state 197

    (27) local_decls -> var_decl local_decls .
    SPRINTF         reduce using rule 27 (local_decls -> var_decl local_decls .)
    THIS            reduce using rule 27 (local_decls -> var_decl local_decls .)
    FOR             reduce using rule 27 (local_decls -> var_decl local_decls .)
    IDENT           reduce using rule 27 (local_decls -> var_decl local_decls .)
    SUPER           reduce using rule 27 (local_decls -> var_decl local_decls .)
    PRINTF          reduce using rule 27 (local_decls -> var_decl local_decls .)
    CONTINUE        reduce using rule 27 (local_decls -> var_decl local_decls .)
    BREAK           reduce using rule 27 (local_decls -> var_decl local_decls .)
    WHILE           reduce using rule 27 (local_decls -> var_decl local_decls .)
    RETURN          reduce using rule 27 (local_decls -> var_decl local_decls .)
    IF              reduce using rule 27 (local_decls -> var_decl local_decls .)
    {               reduce using rule 27 (local_decls -> var_decl local_decls .)
    (               reduce using rule 27 (local_decls -> var_decl local_decls .)
    NOT             reduce using rule 27 (local_decls -> var_decl local_decls .)
    !               reduce using rule 27 (local_decls -> var_decl local_decls .)
    -               reduce using rule 27 (local_decls -> var_decl local_decls .)
    +               reduce using rule 27 (local_decls -> var_decl local_decls .)
    DECREMENT       reduce using rule 27 (local_decls -> var_decl local_decls .)
    INCREMENT       reduce using rule 27 (local_decls -> var_decl local_decls .)
    FALSE           reduce using rule 27 (local_decls -> var_decl local_decls .)
    TRUE            reduce using rule 27 (local_decls -> var_decl local_decls .)
    STRINGLIT       reduce using rule 27 (local_decls -> var_decl local_decls .)
    BOOLIT          reduce using rule 27 (local_decls -> var_decl local_decls .)
    FLOATLIT        reduce using rule 27 (local_decls -> var_decl local_decls .)
    INTLIT          reduce using rule 27 (local_decls -> var_decl local_decls .)
    }               reduce using rule 27 (local_decls -> var_decl local_decls .)


state 198

    (77) var_decl -> type_spec IDENT . [ expr ] ;
    (78) var_decl -> type_spec IDENT . = assignment_expr ;
    (79) var_decl -> type_spec IDENT . ;
    [               shift and go to state 24
    =               shift and go to state 26
    ;               shift and go to state 25


state 199

    (121) primary_expr -> IDENT . IDENT ( args_list . )
    (72) args_list -> args_list . , expr
    )               shift and go to state 220
    ,               shift and go to state 162


state 200

    (72) args_list -> args_list , expr .
    )               reduce using rule 72 (args_list -> args_list , expr .)
    ,               reduce using rule 72 (args_list -> args_list , expr .)


state 201

    (57) assignment_expr -> IDENT [ expr ] = . assignment_expr
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    IDENT           shift and go to state 67
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 69
    assignment_expr                shift and go to state 221
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 202

    (80) object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .
    IDENT           reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    CLASS           reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    STRING          reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    BOOL            reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    FLOAT           reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    INT             reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    VOID            reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    $end            reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    SPRINTF         reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    THIS            reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    FOR             reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    SUPER           reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    PRINTF          reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    CONTINUE        reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    BREAK           reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    WHILE           reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    RETURN          reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    IF              reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    {               reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    (               reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    NOT             reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    !               reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    -               reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    +               reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    DECREMENT       reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    INCREMENT       reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    FALSE           reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    TRUE            reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    STRINGLIT       reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    BOOLIT          reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    FLOATLIT        reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    INTLIT          reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    }               reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    ELSE            reduce using rule 80 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)


state 203

    (17) method_decl -> type_spec IDENT ( param_list ) compound_stmt .
    PUBLIC          reduce using rule 17 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    PRIVATE         reduce using rule 17 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    IDENT           reduce using rule 17 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    STRING          reduce using rule 17 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    BOOL            reduce using rule 17 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    FLOAT           reduce using rule 17 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    INT             reduce using rule 17 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    VOID            reduce using rule 17 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    }               reduce using rule 17 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)


state 204

    (25) compound_stmt -> { local_decls stmt_list } .
    IDENT           reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    CLASS           reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    STRING          reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    BOOL            reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    FLOAT           reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    INT             reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    VOID            reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    $end            reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    PUBLIC          reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    PRIVATE         reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    }               reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    SPRINTF         reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    THIS            reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    FOR             reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    SUPER           reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    PRINTF          reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    CONTINUE        reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    BREAK           reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    WHILE           reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    RETURN          reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    IF              reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    {               reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    (               reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    NOT             reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    !               reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    -               reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    +               reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    DECREMENT       reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    INCREMENT       reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    FALSE           reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    TRUE            reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    STRINGLIT       reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    BOOLIT          reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    FLOATLIT        reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    INTLIT          reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)
    ELSE            reduce using rule 25 (compound_stmt -> { local_decls stmt_list } .)


state 205

    (28) stmt_list -> stmt stmt_list .
    }               reduce using rule 28 (stmt_list -> stmt stmt_list .)


state 206

    (29) stmt_list -> stmt local_decls . stmt_list
    (28) stmt_list -> . stmt stmt_list
    (29) stmt_list -> . stmt local_decls stmt_list
    (30) stmt_list -> . empty
    (31) stmt -> . sprintf_stmt
    (32) stmt -> . this_stmt
    (33) stmt -> . for_stmt
    (34) stmt -> . object_decl
    (35) stmt -> . super_stmt
    (36) stmt -> . print_stmt
    (37) stmt -> . continue_stmt
    (38) stmt -> . break_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . return_stmt
    (41) stmt -> . if_stmt
    (42) stmt -> . compound_stmt
    (43) stmt -> . expr_stmt
    (130) empty -> .
    (75) sprintf_stmt -> . SPRINTF ( expr , args_list ) ;
    (76) this_stmt -> . THIS ;
    (44) for_stmt -> . FOR ( for_init ; for_cond ; for_incr ) compound_stmt
    (80) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (81) object_decl -> . IDENT IDENT ;
    (55) super_stmt -> . SUPER ( args_list ) ;
    (74) print_stmt -> . PRINTF ( expr , args_list ) ;
    (70) continue_stmt -> . CONTINUE ;
    (69) break_stmt -> . BREAK ;
    (68) while_stmt -> . WHILE ( expr ) stmt
    (66) return_stmt -> . RETURN expr ;
    (67) return_stmt -> . RETURN ;
    (64) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (65) if_stmt -> . IF ( expr ) stmt
    (25) compound_stmt -> . { local_decls stmt_list }
    (56) expr_stmt -> . assignment_expr ;
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    }               reduce using rule 130 (empty -> .)
    SPRINTF         shift and go to state 185
    THIS            shift and go to state 186
    FOR             shift and go to state 187
    IDENT           shift and go to state 188
    SUPER           shift and go to state 189
    PRINTF          shift and go to state 190
    CONTINUE        shift and go to state 191
    BREAK           shift and go to state 192
    WHILE           shift and go to state 193
    RETURN          shift and go to state 194
    IF              shift and go to state 195
    {               shift and go to state 121
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    stmt                           shift and go to state 170
    stmt_list                      shift and go to state 222
    empty                          shift and go to state 171
    sprintf_stmt                   shift and go to state 172
    this_stmt                      shift and go to state 173
    for_stmt                       shift and go to state 174
    object_decl                    shift and go to state 175
    super_stmt                     shift and go to state 176
    print_stmt                     shift and go to state 177
    continue_stmt                  shift and go to state 178
    break_stmt                     shift and go to state 179
    while_stmt                     shift and go to state 180
    return_stmt                    shift and go to state 181
    if_stmt                        shift and go to state 182
    compound_stmt                  shift and go to state 183
    expr_stmt                      shift and go to state 184
    expr                           shift and go to state 69
    assignment_expr                shift and go to state 196
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 207

    (30) stmt_list -> empty .
    (26) local_decls -> empty .
  ! reduce/reduce conflict for } resolved using rule 26 (local_decls -> empty .)
    SPRINTF         reduce using rule 26 (local_decls -> empty .)
    THIS            reduce using rule 26 (local_decls -> empty .)
    FOR             reduce using rule 26 (local_decls -> empty .)
    IDENT           reduce using rule 26 (local_decls -> empty .)
    SUPER           reduce using rule 26 (local_decls -> empty .)
    PRINTF          reduce using rule 26 (local_decls -> empty .)
    CONTINUE        reduce using rule 26 (local_decls -> empty .)
    BREAK           reduce using rule 26 (local_decls -> empty .)
    WHILE           reduce using rule 26 (local_decls -> empty .)
    RETURN          reduce using rule 26 (local_decls -> empty .)
    IF              reduce using rule 26 (local_decls -> empty .)
    {               reduce using rule 26 (local_decls -> empty .)
    (               reduce using rule 26 (local_decls -> empty .)
    NOT             reduce using rule 26 (local_decls -> empty .)
    !               reduce using rule 26 (local_decls -> empty .)
    -               reduce using rule 26 (local_decls -> empty .)
    +               reduce using rule 26 (local_decls -> empty .)
    DECREMENT       reduce using rule 26 (local_decls -> empty .)
    INCREMENT       reduce using rule 26 (local_decls -> empty .)
    FALSE           reduce using rule 26 (local_decls -> empty .)
    TRUE            reduce using rule 26 (local_decls -> empty .)
    STRINGLIT       reduce using rule 26 (local_decls -> empty .)
    BOOLIT          reduce using rule 26 (local_decls -> empty .)
    FLOATLIT        reduce using rule 26 (local_decls -> empty .)
    INTLIT          reduce using rule 26 (local_decls -> empty .)
    }               reduce using rule 26 (local_decls -> empty .)


state 208

    (75) sprintf_stmt -> SPRINTF ( . expr , args_list ) ;
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 223
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 209

    (76) this_stmt -> THIS ; .
    SPRINTF         reduce using rule 76 (this_stmt -> THIS ; .)
    THIS            reduce using rule 76 (this_stmt -> THIS ; .)
    FOR             reduce using rule 76 (this_stmt -> THIS ; .)
    IDENT           reduce using rule 76 (this_stmt -> THIS ; .)
    SUPER           reduce using rule 76 (this_stmt -> THIS ; .)
    PRINTF          reduce using rule 76 (this_stmt -> THIS ; .)
    CONTINUE        reduce using rule 76 (this_stmt -> THIS ; .)
    BREAK           reduce using rule 76 (this_stmt -> THIS ; .)
    WHILE           reduce using rule 76 (this_stmt -> THIS ; .)
    RETURN          reduce using rule 76 (this_stmt -> THIS ; .)
    IF              reduce using rule 76 (this_stmt -> THIS ; .)
    {               reduce using rule 76 (this_stmt -> THIS ; .)
    STRING          reduce using rule 76 (this_stmt -> THIS ; .)
    BOOL            reduce using rule 76 (this_stmt -> THIS ; .)
    FLOAT           reduce using rule 76 (this_stmt -> THIS ; .)
    INT             reduce using rule 76 (this_stmt -> THIS ; .)
    VOID            reduce using rule 76 (this_stmt -> THIS ; .)
    (               reduce using rule 76 (this_stmt -> THIS ; .)
    NOT             reduce using rule 76 (this_stmt -> THIS ; .)
    !               reduce using rule 76 (this_stmt -> THIS ; .)
    -               reduce using rule 76 (this_stmt -> THIS ; .)
    +               reduce using rule 76 (this_stmt -> THIS ; .)
    DECREMENT       reduce using rule 76 (this_stmt -> THIS ; .)
    INCREMENT       reduce using rule 76 (this_stmt -> THIS ; .)
    FALSE           reduce using rule 76 (this_stmt -> THIS ; .)
    TRUE            reduce using rule 76 (this_stmt -> THIS ; .)
    STRINGLIT       reduce using rule 76 (this_stmt -> THIS ; .)
    BOOLIT          reduce using rule 76 (this_stmt -> THIS ; .)
    FLOATLIT        reduce using rule 76 (this_stmt -> THIS ; .)
    INTLIT          reduce using rule 76 (this_stmt -> THIS ; .)
    }               reduce using rule 76 (this_stmt -> THIS ; .)
    ELSE            reduce using rule 76 (this_stmt -> THIS ; .)


state 210

    (44) for_stmt -> FOR ( . for_init ; for_cond ; for_incr ) compound_stmt
    (45) for_init -> . empty
    (46) for_init -> . assignment_expr
    (47) for_init -> . var_decl_no_semi
    (130) empty -> .
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (48) var_decl_no_semi -> . type_spec IDENT [ expr ]
    (49) var_decl_no_semi -> . type_spec IDENT = assignment_expr
    (50) var_decl_no_semi -> . type_spec IDENT
    (87) expr -> . logical_or_expr
    (82) type_spec -> . STRING
    (83) type_spec -> . BOOL
    (84) type_spec -> . FLOAT
    (85) type_spec -> . INT
    (86) type_spec -> . VOID
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    ;               reduce using rule 130 (empty -> .)
    IDENT           shift and go to state 67
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    for_init                       shift and go to state 224
    empty                          shift and go to state 225
    assignment_expr                shift and go to state 226
    var_decl_no_semi               shift and go to state 227
    expr                           shift and go to state 69
    type_spec                      shift and go to state 228
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 211

    (55) super_stmt -> SUPER ( . args_list ) ;
    (71) args_list -> . expr
    (72) args_list -> . args_list , expr
    (73) args_list -> . empty
    (87) expr -> . logical_or_expr
    (130) empty -> .
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    )               reduce using rule 130 (empty -> .)
    ,               reduce using rule 130 (empty -> .)
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    args_list                      shift and go to state 229
    expr                           shift and go to state 127
    empty                          shift and go to state 128
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 212

    (74) print_stmt -> PRINTF ( . expr , args_list ) ;
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 230
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 213

    (70) continue_stmt -> CONTINUE ; .
    SPRINTF         reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    THIS            reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    FOR             reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    IDENT           reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    SUPER           reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    PRINTF          reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    IF              reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    {               reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    STRING          reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    BOOL            reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    FLOAT           reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    INT             reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    VOID            reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    (               reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    NOT             reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    !               reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    -               reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    +               reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    DECREMENT       reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    INCREMENT       reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    FALSE           reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    TRUE            reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    STRINGLIT       reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    BOOLIT          reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    FLOATLIT        reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    INTLIT          reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    }               reduce using rule 70 (continue_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 70 (continue_stmt -> CONTINUE ; .)


state 214

    (69) break_stmt -> BREAK ; .
    SPRINTF         reduce using rule 69 (break_stmt -> BREAK ; .)
    THIS            reduce using rule 69 (break_stmt -> BREAK ; .)
    FOR             reduce using rule 69 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 69 (break_stmt -> BREAK ; .)
    SUPER           reduce using rule 69 (break_stmt -> BREAK ; .)
    PRINTF          reduce using rule 69 (break_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 69 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 69 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 69 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 69 (break_stmt -> BREAK ; .)
    IF              reduce using rule 69 (break_stmt -> BREAK ; .)
    {               reduce using rule 69 (break_stmt -> BREAK ; .)
    STRING          reduce using rule 69 (break_stmt -> BREAK ; .)
    BOOL            reduce using rule 69 (break_stmt -> BREAK ; .)
    FLOAT           reduce using rule 69 (break_stmt -> BREAK ; .)
    INT             reduce using rule 69 (break_stmt -> BREAK ; .)
    VOID            reduce using rule 69 (break_stmt -> BREAK ; .)
    (               reduce using rule 69 (break_stmt -> BREAK ; .)
    NOT             reduce using rule 69 (break_stmt -> BREAK ; .)
    !               reduce using rule 69 (break_stmt -> BREAK ; .)
    -               reduce using rule 69 (break_stmt -> BREAK ; .)
    +               reduce using rule 69 (break_stmt -> BREAK ; .)
    DECREMENT       reduce using rule 69 (break_stmt -> BREAK ; .)
    INCREMENT       reduce using rule 69 (break_stmt -> BREAK ; .)
    FALSE           reduce using rule 69 (break_stmt -> BREAK ; .)
    TRUE            reduce using rule 69 (break_stmt -> BREAK ; .)
    STRINGLIT       reduce using rule 69 (break_stmt -> BREAK ; .)
    BOOLIT          reduce using rule 69 (break_stmt -> BREAK ; .)
    FLOATLIT        reduce using rule 69 (break_stmt -> BREAK ; .)
    INTLIT          reduce using rule 69 (break_stmt -> BREAK ; .)
    }               reduce using rule 69 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 69 (break_stmt -> BREAK ; .)


state 215

    (68) while_stmt -> WHILE ( . expr ) stmt
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 231
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 216

    (66) return_stmt -> RETURN expr . ;
    ;               shift and go to state 232


state 217

    (67) return_stmt -> RETURN ; .
    SPRINTF         reduce using rule 67 (return_stmt -> RETURN ; .)
    THIS            reduce using rule 67 (return_stmt -> RETURN ; .)
    FOR             reduce using rule 67 (return_stmt -> RETURN ; .)
    IDENT           reduce using rule 67 (return_stmt -> RETURN ; .)
    SUPER           reduce using rule 67 (return_stmt -> RETURN ; .)
    PRINTF          reduce using rule 67 (return_stmt -> RETURN ; .)
    CONTINUE        reduce using rule 67 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 67 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 67 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 67 (return_stmt -> RETURN ; .)
    IF              reduce using rule 67 (return_stmt -> RETURN ; .)
    {               reduce using rule 67 (return_stmt -> RETURN ; .)
    STRING          reduce using rule 67 (return_stmt -> RETURN ; .)
    BOOL            reduce using rule 67 (return_stmt -> RETURN ; .)
    FLOAT           reduce using rule 67 (return_stmt -> RETURN ; .)
    INT             reduce using rule 67 (return_stmt -> RETURN ; .)
    VOID            reduce using rule 67 (return_stmt -> RETURN ; .)
    (               reduce using rule 67 (return_stmt -> RETURN ; .)
    NOT             reduce using rule 67 (return_stmt -> RETURN ; .)
    !               reduce using rule 67 (return_stmt -> RETURN ; .)
    -               reduce using rule 67 (return_stmt -> RETURN ; .)
    +               reduce using rule 67 (return_stmt -> RETURN ; .)
    DECREMENT       reduce using rule 67 (return_stmt -> RETURN ; .)
    INCREMENT       reduce using rule 67 (return_stmt -> RETURN ; .)
    FALSE           reduce using rule 67 (return_stmt -> RETURN ; .)
    TRUE            reduce using rule 67 (return_stmt -> RETURN ; .)
    STRINGLIT       reduce using rule 67 (return_stmt -> RETURN ; .)
    BOOLIT          reduce using rule 67 (return_stmt -> RETURN ; .)
    FLOATLIT        reduce using rule 67 (return_stmt -> RETURN ; .)
    INTLIT          reduce using rule 67 (return_stmt -> RETURN ; .)
    }               reduce using rule 67 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 67 (return_stmt -> RETURN ; .)


state 218

    (64) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (65) if_stmt -> IF ( . expr ) stmt
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 233
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 219

    (56) expr_stmt -> assignment_expr ; .
    SPRINTF         reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    THIS            reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    FOR             reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    IDENT           reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    SUPER           reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    PRINTF          reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    CONTINUE        reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    BREAK           reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    WHILE           reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    RETURN          reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    IF              reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    {               reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    STRING          reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    BOOL            reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    FLOAT           reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    INT             reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    VOID            reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    (               reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    NOT             reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    !               reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    -               reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    +               reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    DECREMENT       reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    INCREMENT       reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    FALSE           reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    TRUE            reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    STRINGLIT       reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    BOOLIT          reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    FLOATLIT        reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    INTLIT          reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    }               reduce using rule 56 (expr_stmt -> assignment_expr ; .)
    ELSE            reduce using rule 56 (expr_stmt -> assignment_expr ; .)


state 220

    (121) primary_expr -> IDENT . IDENT ( args_list ) .
    DECREMENT       reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    INCREMENT       reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    %               reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    /               reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    *               reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    -               reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    +               reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    GE              reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    GT              reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    LE              reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    LT              reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    NE              reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    EQ              reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    AND             reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    OR              reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    ]               reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    ;               reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    )               reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)
    ,               reduce using rule 121 (primary_expr -> IDENT . IDENT ( args_list ) .)


state 221

    (57) assignment_expr -> IDENT [ expr ] = assignment_expr .
    ;               reduce using rule 57 (assignment_expr -> IDENT [ expr ] = assignment_expr .)
    )               reduce using rule 57 (assignment_expr -> IDENT [ expr ] = assignment_expr .)


state 222

    (29) stmt_list -> stmt local_decls stmt_list .
    }               reduce using rule 29 (stmt_list -> stmt local_decls stmt_list .)


state 223

    (75) sprintf_stmt -> SPRINTF ( expr . , args_list ) ;
    ,               shift and go to state 234


state 224

    (44) for_stmt -> FOR ( for_init . ; for_cond ; for_incr ) compound_stmt
    ;               shift and go to state 235


state 225

    (45) for_init -> empty .
    ;               reduce using rule 45 (for_init -> empty .)


state 226

    (46) for_init -> assignment_expr .
    ;               reduce using rule 46 (for_init -> assignment_expr .)


state 227

    (47) for_init -> var_decl_no_semi .
    ;               reduce using rule 47 (for_init -> var_decl_no_semi .)


state 228

    (48) var_decl_no_semi -> type_spec . IDENT [ expr ]
    (49) var_decl_no_semi -> type_spec . IDENT = assignment_expr
    (50) var_decl_no_semi -> type_spec . IDENT
    IDENT           shift and go to state 236


state 229

    (55) super_stmt -> SUPER ( args_list . ) ;
    (72) args_list -> args_list . , expr
    )               shift and go to state 237
    ,               shift and go to state 162


state 230

    (74) print_stmt -> PRINTF ( expr . , args_list ) ;
    ,               shift and go to state 238


state 231

    (68) while_stmt -> WHILE ( expr . ) stmt
    )               shift and go to state 239


state 232

    (66) return_stmt -> RETURN expr ; .
    SPRINTF         reduce using rule 66 (return_stmt -> RETURN expr ; .)
    THIS            reduce using rule 66 (return_stmt -> RETURN expr ; .)
    FOR             reduce using rule 66 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 66 (return_stmt -> RETURN expr ; .)
    SUPER           reduce using rule 66 (return_stmt -> RETURN expr ; .)
    PRINTF          reduce using rule 66 (return_stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 66 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 66 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 66 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 66 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 66 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 66 (return_stmt -> RETURN expr ; .)
    STRING          reduce using rule 66 (return_stmt -> RETURN expr ; .)
    BOOL            reduce using rule 66 (return_stmt -> RETURN expr ; .)
    FLOAT           reduce using rule 66 (return_stmt -> RETURN expr ; .)
    INT             reduce using rule 66 (return_stmt -> RETURN expr ; .)
    VOID            reduce using rule 66 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 66 (return_stmt -> RETURN expr ; .)
    NOT             reduce using rule 66 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 66 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 66 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 66 (return_stmt -> RETURN expr ; .)
    DECREMENT       reduce using rule 66 (return_stmt -> RETURN expr ; .)
    INCREMENT       reduce using rule 66 (return_stmt -> RETURN expr ; .)
    FALSE           reduce using rule 66 (return_stmt -> RETURN expr ; .)
    TRUE            reduce using rule 66 (return_stmt -> RETURN expr ; .)
    STRINGLIT       reduce using rule 66 (return_stmt -> RETURN expr ; .)
    BOOLIT          reduce using rule 66 (return_stmt -> RETURN expr ; .)
    FLOATLIT        reduce using rule 66 (return_stmt -> RETURN expr ; .)
    INTLIT          reduce using rule 66 (return_stmt -> RETURN expr ; .)
    }               reduce using rule 66 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 66 (return_stmt -> RETURN expr ; .)


state 233

    (64) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (65) if_stmt -> IF ( expr . ) stmt
    )               shift and go to state 240


state 234

    (75) sprintf_stmt -> SPRINTF ( expr , . args_list ) ;
    (71) args_list -> . expr
    (72) args_list -> . args_list , expr
    (73) args_list -> . empty
    (87) expr -> . logical_or_expr
    (130) empty -> .
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    )               reduce using rule 130 (empty -> .)
    ,               reduce using rule 130 (empty -> .)
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 127
    args_list                      shift and go to state 241
    empty                          shift and go to state 128
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 235

    (44) for_stmt -> FOR ( for_init ; . for_cond ; for_incr ) compound_stmt
    (51) for_cond -> . empty
    (52) for_cond -> . expr
    (130) empty -> .
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    ;               reduce using rule 130 (empty -> .)
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    for_cond                       shift and go to state 242
    empty                          shift and go to state 243
    expr                           shift and go to state 244
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 236

    (48) var_decl_no_semi -> type_spec IDENT . [ expr ]
    (49) var_decl_no_semi -> type_spec IDENT . = assignment_expr
    (50) var_decl_no_semi -> type_spec IDENT .
    [               shift and go to state 245
    =               shift and go to state 246
    ;               reduce using rule 50 (var_decl_no_semi -> type_spec IDENT .)


state 237

    (55) super_stmt -> SUPER ( args_list ) . ;
    ;               shift and go to state 247


state 238

    (74) print_stmt -> PRINTF ( expr , . args_list ) ;
    (71) args_list -> . expr
    (72) args_list -> . args_list , expr
    (73) args_list -> . empty
    (87) expr -> . logical_or_expr
    (130) empty -> .
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    )               reduce using rule 130 (empty -> .)
    ,               reduce using rule 130 (empty -> .)
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 127
    args_list                      shift and go to state 248
    empty                          shift and go to state 128
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 239

    (68) while_stmt -> WHILE ( expr ) . stmt
    (31) stmt -> . sprintf_stmt
    (32) stmt -> . this_stmt
    (33) stmt -> . for_stmt
    (34) stmt -> . object_decl
    (35) stmt -> . super_stmt
    (36) stmt -> . print_stmt
    (37) stmt -> . continue_stmt
    (38) stmt -> . break_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . return_stmt
    (41) stmt -> . if_stmt
    (42) stmt -> . compound_stmt
    (43) stmt -> . expr_stmt
    (75) sprintf_stmt -> . SPRINTF ( expr , args_list ) ;
    (76) this_stmt -> . THIS ;
    (44) for_stmt -> . FOR ( for_init ; for_cond ; for_incr ) compound_stmt
    (80) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (81) object_decl -> . IDENT IDENT ;
    (55) super_stmt -> . SUPER ( args_list ) ;
    (74) print_stmt -> . PRINTF ( expr , args_list ) ;
    (70) continue_stmt -> . CONTINUE ;
    (69) break_stmt -> . BREAK ;
    (68) while_stmt -> . WHILE ( expr ) stmt
    (66) return_stmt -> . RETURN expr ;
    (67) return_stmt -> . RETURN ;
    (64) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (65) if_stmt -> . IF ( expr ) stmt
    (25) compound_stmt -> . { local_decls stmt_list }
    (56) expr_stmt -> . assignment_expr ;
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    SPRINTF         shift and go to state 185
    THIS            shift and go to state 186
    FOR             shift and go to state 187
    IDENT           shift and go to state 188
    SUPER           shift and go to state 189
    PRINTF          shift and go to state 190
    CONTINUE        shift and go to state 191
    BREAK           shift and go to state 192
    WHILE           shift and go to state 193
    RETURN          shift and go to state 194
    IF              shift and go to state 195
    {               shift and go to state 121
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 69
    stmt                           shift and go to state 249
    sprintf_stmt                   shift and go to state 172
    this_stmt                      shift and go to state 173
    for_stmt                       shift and go to state 174
    object_decl                    shift and go to state 175
    super_stmt                     shift and go to state 176
    print_stmt                     shift and go to state 177
    continue_stmt                  shift and go to state 178
    break_stmt                     shift and go to state 179
    while_stmt                     shift and go to state 180
    return_stmt                    shift and go to state 181
    if_stmt                        shift and go to state 182
    compound_stmt                  shift and go to state 183
    expr_stmt                      shift and go to state 184
    assignment_expr                shift and go to state 196
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 240

    (64) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (65) if_stmt -> IF ( expr ) . stmt
    (31) stmt -> . sprintf_stmt
    (32) stmt -> . this_stmt
    (33) stmt -> . for_stmt
    (34) stmt -> . object_decl
    (35) stmt -> . super_stmt
    (36) stmt -> . print_stmt
    (37) stmt -> . continue_stmt
    (38) stmt -> . break_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . return_stmt
    (41) stmt -> . if_stmt
    (42) stmt -> . compound_stmt
    (43) stmt -> . expr_stmt
    (75) sprintf_stmt -> . SPRINTF ( expr , args_list ) ;
    (76) this_stmt -> . THIS ;
    (44) for_stmt -> . FOR ( for_init ; for_cond ; for_incr ) compound_stmt
    (80) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (81) object_decl -> . IDENT IDENT ;
    (55) super_stmt -> . SUPER ( args_list ) ;
    (74) print_stmt -> . PRINTF ( expr , args_list ) ;
    (70) continue_stmt -> . CONTINUE ;
    (69) break_stmt -> . BREAK ;
    (68) while_stmt -> . WHILE ( expr ) stmt
    (66) return_stmt -> . RETURN expr ;
    (67) return_stmt -> . RETURN ;
    (64) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (65) if_stmt -> . IF ( expr ) stmt
    (25) compound_stmt -> . { local_decls stmt_list }
    (56) expr_stmt -> . assignment_expr ;
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    SPRINTF         shift and go to state 185
    THIS            shift and go to state 186
    FOR             shift and go to state 187
    IDENT           shift and go to state 188
    SUPER           shift and go to state 189
    PRINTF          shift and go to state 190
    CONTINUE        shift and go to state 191
    BREAK           shift and go to state 192
    WHILE           shift and go to state 193
    RETURN          shift and go to state 194
    IF              shift and go to state 195
    {               shift and go to state 121
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 69
    stmt                           shift and go to state 250
    sprintf_stmt                   shift and go to state 172
    this_stmt                      shift and go to state 173
    for_stmt                       shift and go to state 174
    object_decl                    shift and go to state 175
    super_stmt                     shift and go to state 176
    print_stmt                     shift and go to state 177
    continue_stmt                  shift and go to state 178
    break_stmt                     shift and go to state 179
    while_stmt                     shift and go to state 180
    return_stmt                    shift and go to state 181
    if_stmt                        shift and go to state 182
    compound_stmt                  shift and go to state 183
    expr_stmt                      shift and go to state 184
    assignment_expr                shift and go to state 196
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 241

    (75) sprintf_stmt -> SPRINTF ( expr , args_list . ) ;
    (72) args_list -> args_list . , expr
    )               shift and go to state 251
    ,               shift and go to state 162


state 242

    (44) for_stmt -> FOR ( for_init ; for_cond . ; for_incr ) compound_stmt
    ;               shift and go to state 252


state 243

    (51) for_cond -> empty .
    ;               reduce using rule 51 (for_cond -> empty .)


state 244

    (52) for_cond -> expr .
    ;               reduce using rule 52 (for_cond -> expr .)


state 245

    (48) var_decl_no_semi -> type_spec IDENT [ . expr ]
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    IDENT           shift and go to state 43
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 253
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 246

    (49) var_decl_no_semi -> type_spec IDENT = . assignment_expr
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    IDENT           shift and go to state 67
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    assignment_expr                shift and go to state 254
    expr                           shift and go to state 69
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 247

    (55) super_stmt -> SUPER ( args_list ) ; .
    SPRINTF         reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    THIS            reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    FOR             reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    IDENT           reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    SUPER           reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    PRINTF          reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    CONTINUE        reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    BREAK           reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    WHILE           reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    RETURN          reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    IF              reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    {               reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    STRING          reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    BOOL            reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    FLOAT           reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    INT             reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    VOID            reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    (               reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    NOT             reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    !               reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    -               reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    +               reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    DECREMENT       reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    INCREMENT       reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    FALSE           reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    TRUE            reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    STRINGLIT       reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    BOOLIT          reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    FLOATLIT        reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    INTLIT          reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    }               reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)
    ELSE            reduce using rule 55 (super_stmt -> SUPER ( args_list ) ; .)


state 248

    (74) print_stmt -> PRINTF ( expr , args_list . ) ;
    (72) args_list -> args_list . , expr
    )               shift and go to state 255
    ,               shift and go to state 162


state 249

    (68) while_stmt -> WHILE ( expr ) stmt .
    SPRINTF         reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    THIS            reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    SUPER           reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    PRINTF          reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    STRING          reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL            reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT           reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    INT             reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    VOID            reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    NOT             reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    DECREMENT       reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    INCREMENT       reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    FALSE           reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    TRUE            reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    STRINGLIT       reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    BOOLIT          reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    FLOATLIT        reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    INTLIT          reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    }               reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 68 (while_stmt -> WHILE ( expr ) stmt .)


state 250

    (64) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (65) if_stmt -> IF ( expr ) stmt .
    ELSE            shift and go to state 256
    SPRINTF         reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    THIS            reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    SUPER           reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    PRINTF          reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    STRING          reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    BOOL            reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    FLOAT           reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    INT             reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    VOID            reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    NOT             reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    DECREMENT       reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    INCREMENT       reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    FALSE           reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    TRUE            reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    STRINGLIT       reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    BOOLIT          reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    FLOATLIT        reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    INTLIT          reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)
    }               reduce using rule 65 (if_stmt -> IF ( expr ) stmt .)


state 251

    (75) sprintf_stmt -> SPRINTF ( expr , args_list ) . ;
    ;               shift and go to state 257


state 252

    (44) for_stmt -> FOR ( for_init ; for_cond ; . for_incr ) compound_stmt
    (53) for_incr -> . empty
    (54) for_incr -> . assignment_expr
    (130) empty -> .
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    )               reduce using rule 130 (empty -> .)
    IDENT           shift and go to state 67
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    for_incr                       shift and go to state 258
    empty                          shift and go to state 259
    assignment_expr                shift and go to state 260
    expr                           shift and go to state 69
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 253

    (48) var_decl_no_semi -> type_spec IDENT [ expr . ]
    ]               shift and go to state 261


state 254

    (49) var_decl_no_semi -> type_spec IDENT = assignment_expr .
    ;               reduce using rule 49 (var_decl_no_semi -> type_spec IDENT = assignment_expr .)


state 255

    (74) print_stmt -> PRINTF ( expr , args_list ) . ;
    ;               shift and go to state 262


state 256

    (64) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (31) stmt -> . sprintf_stmt
    (32) stmt -> . this_stmt
    (33) stmt -> . for_stmt
    (34) stmt -> . object_decl
    (35) stmt -> . super_stmt
    (36) stmt -> . print_stmt
    (37) stmt -> . continue_stmt
    (38) stmt -> . break_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . return_stmt
    (41) stmt -> . if_stmt
    (42) stmt -> . compound_stmt
    (43) stmt -> . expr_stmt
    (75) sprintf_stmt -> . SPRINTF ( expr , args_list ) ;
    (76) this_stmt -> . THIS ;
    (44) for_stmt -> . FOR ( for_init ; for_cond ; for_incr ) compound_stmt
    (80) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (81) object_decl -> . IDENT IDENT ;
    (55) super_stmt -> . SUPER ( args_list ) ;
    (74) print_stmt -> . PRINTF ( expr , args_list ) ;
    (70) continue_stmt -> . CONTINUE ;
    (69) break_stmt -> . BREAK ;
    (68) while_stmt -> . WHILE ( expr ) stmt
    (66) return_stmt -> . RETURN expr ;
    (67) return_stmt -> . RETURN ;
    (64) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (65) if_stmt -> . IF ( expr ) stmt
    (25) compound_stmt -> . { local_decls stmt_list }
    (56) expr_stmt -> . assignment_expr ;
    (57) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (58) assignment_expr -> . expr
    (59) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (60) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (61) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (62) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (63) assignment_expr -> . IDENT = assignment_expr
    (87) expr -> . logical_or_expr
    (88) logical_or_expr -> . logical_and_expr
    (89) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (90) logical_and_expr -> . equality_expr
    (91) logical_and_expr -> . logical_and_expr AND equality_expr
    (92) equality_expr -> . relational_expr
    (93) equality_expr -> . equality_expr NE relational_expr
    (94) equality_expr -> . equality_expr EQ relational_expr
    (95) relational_expr -> . additive_expr
    (96) relational_expr -> . relational_expr GE additive_expr
    (97) relational_expr -> . relational_expr GT additive_expr
    (98) relational_expr -> . relational_expr LE additive_expr
    (99) relational_expr -> . relational_expr LT additive_expr
    (100) additive_expr -> . multiplicative_expr
    (101) additive_expr -> . additive_expr - multiplicative_expr
    (102) additive_expr -> . additive_expr + multiplicative_expr
    (103) multiplicative_expr -> . unary_expr
    (104) multiplicative_expr -> . multiplicative_expr % unary_expr
    (105) multiplicative_expr -> . multiplicative_expr / unary_expr
    (106) multiplicative_expr -> . multiplicative_expr * unary_expr
    (107) unary_expr -> . ( type_spec ) unary_expr
    (108) unary_expr -> . postfix_expr
    (109) unary_expr -> . NOT unary_expr
    (110) unary_expr -> . ! unary_expr
    (111) unary_expr -> . - unary_expr
    (112) unary_expr -> . + unary_expr
    (113) unary_expr -> . DECREMENT unary_expr
    (114) unary_expr -> . INCREMENT unary_expr
    (115) postfix_expr -> . primary_expr
    (116) postfix_expr -> . postfix_expr DECREMENT
    (117) postfix_expr -> . postfix_expr INCREMENT
    (118) primary_expr -> . IDENT . SIZE
    (119) primary_expr -> . IDENT
    (120) primary_expr -> . IDENT [ expr ]
    (121) primary_expr -> . IDENT . IDENT ( args_list )
    (122) primary_expr -> . IDENT ( args_list )
    (123) primary_expr -> . FALSE
    (124) primary_expr -> . TRUE
    (125) primary_expr -> . STRINGLIT
    (126) primary_expr -> . BOOLIT
    (127) primary_expr -> . FLOATLIT
    (128) primary_expr -> . INTLIT
    (129) primary_expr -> . ( expr )
    SPRINTF         shift and go to state 185
    THIS            shift and go to state 186
    FOR             shift and go to state 187
    IDENT           shift and go to state 188
    SUPER           shift and go to state 189
    PRINTF          shift and go to state 190
    CONTINUE        shift and go to state 191
    BREAK           shift and go to state 192
    WHILE           shift and go to state 193
    RETURN          shift and go to state 194
    IF              shift and go to state 195
    {               shift and go to state 121
    (               shift and go to state 54
    NOT             shift and go to state 56
    !               shift and go to state 57
    -               shift and go to state 51
    +               shift and go to state 52
    DECREMENT       shift and go to state 58
    INCREMENT       shift and go to state 59
    FALSE           shift and go to state 61
    TRUE            shift and go to state 62
    STRINGLIT       shift and go to state 63
    BOOLIT          shift and go to state 64
    FLOATLIT        shift and go to state 65
    INTLIT          shift and go to state 66

    expr                           shift and go to state 69
    stmt                           shift and go to state 263
    sprintf_stmt                   shift and go to state 172
    this_stmt                      shift and go to state 173
    for_stmt                       shift and go to state 174
    object_decl                    shift and go to state 175
    super_stmt                     shift and go to state 176
    print_stmt                     shift and go to state 177
    continue_stmt                  shift and go to state 178
    break_stmt                     shift and go to state 179
    while_stmt                     shift and go to state 180
    return_stmt                    shift and go to state 181
    if_stmt                        shift and go to state 182
    compound_stmt                  shift and go to state 183
    expr_stmt                      shift and go to state 184
    assignment_expr                shift and go to state 196
    logical_or_expr                shift and go to state 45
    logical_and_expr               shift and go to state 46
    equality_expr                  shift and go to state 47
    relational_expr                shift and go to state 48
    additive_expr                  shift and go to state 49
    multiplicative_expr            shift and go to state 50
    unary_expr                     shift and go to state 53
    postfix_expr                   shift and go to state 55
    primary_expr                   shift and go to state 60

state 257

    (75) sprintf_stmt -> SPRINTF ( expr , args_list ) ; .
    SPRINTF         reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    THIS            reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    FOR             reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    IDENT           reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    SUPER           reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    PRINTF          reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    CONTINUE        reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    BREAK           reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    WHILE           reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    RETURN          reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    IF              reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    {               reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    STRING          reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    BOOL            reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    FLOAT           reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    INT             reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    VOID            reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    (               reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    NOT             reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    !               reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    -               reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    +               reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    DECREMENT       reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    INCREMENT       reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    FALSE           reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    TRUE            reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    STRINGLIT       reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    BOOLIT          reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    FLOATLIT        reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    INTLIT          reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    }               reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)
    ELSE            reduce using rule 75 (sprintf_stmt -> SPRINTF ( expr , args_list ) ; .)


state 258

    (44) for_stmt -> FOR ( for_init ; for_cond ; for_incr . ) compound_stmt
    )               shift and go to state 264


state 259

    (53) for_incr -> empty .
    )               reduce using rule 53 (for_incr -> empty .)


state 260

    (54) for_incr -> assignment_expr .
    )               reduce using rule 54 (for_incr -> assignment_expr .)


state 261

    (48) var_decl_no_semi -> type_spec IDENT [ expr ] .
    ;               reduce using rule 48 (var_decl_no_semi -> type_spec IDENT [ expr ] .)


state 262

    (74) print_stmt -> PRINTF ( expr , args_list ) ; .
    SPRINTF         reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    THIS            reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    FOR             reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    IDENT           reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    SUPER           reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    PRINTF          reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    CONTINUE        reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    BREAK           reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    WHILE           reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    RETURN          reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    IF              reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    {               reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    STRING          reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    BOOL            reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    FLOAT           reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    INT             reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    VOID            reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    (               reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    NOT             reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    !               reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    -               reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    +               reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    DECREMENT       reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    INCREMENT       reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    FALSE           reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    TRUE            reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    STRINGLIT       reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    BOOLIT          reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    FLOATLIT        reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    INTLIT          reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    }               reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)
    ELSE            reduce using rule 74 (print_stmt -> PRINTF ( expr , args_list ) ; .)


state 263

    (64) if_stmt -> IF ( expr ) stmt ELSE stmt .
    SPRINTF         reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    THIS            reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SUPER           reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINTF          reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING          reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL            reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT           reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT             reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    VOID            reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NOT             reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    DECREMENT       reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INCREMENT       reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FALSE           reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    TRUE            reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRINGLIT       reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOLIT          reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOATLIT        reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INTLIT          reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    }               reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 64 (if_stmt -> IF ( expr ) stmt ELSE stmt .)


state 264

    (44) for_stmt -> FOR ( for_init ; for_cond ; for_incr ) . compound_stmt
    (25) compound_stmt -> . { local_decls stmt_list }
    {               shift and go to state 121

    compound_stmt                  shift and go to state 265

state 265

    (44) for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .
    SPRINTF         reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    THIS            reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    FOR             reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    IDENT           reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    SUPER           reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    PRINTF          reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    CONTINUE        reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    BREAK           reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    WHILE           reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    RETURN          reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    IF              reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    {               reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    STRING          reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    BOOL            reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    FLOAT           reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    INT             reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    VOID            reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    (               reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    NOT             reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    !               reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    -               reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    +               reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    DECREMENT       reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    INCREMENT       reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    FALSE           reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    TRUE            reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    STRINGLIT       reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    BOOLIT          reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    FLOATLIT        reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    INTLIT          reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    }               reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    ELSE            reduce using rule 44 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)


Conflicts:

shift/reduce conflict for SPRINTF in state 170 resolved as shift
shift/reduce conflict for THIS in state 170 resolved as shift
shift/reduce conflict for FOR in state 170 resolved as shift
shift/reduce conflict for IDENT in state 170 resolved as shift
shift/reduce conflict for SUPER in state 170 resolved as shift
shift/reduce conflict for PRINTF in state 170 resolved as shift
shift/reduce conflict for CONTINUE in state 170 resolved as shift
shift/reduce conflict for BREAK in state 170 resolved as shift
shift/reduce conflict for WHILE in state 170 resolved as shift
shift/reduce conflict for RETURN in state 170 resolved as shift
shift/reduce conflict for IF in state 170 resolved as shift
shift/reduce conflict for { in state 170 resolved as shift
shift/reduce conflict for ( in state 170 resolved as shift
shift/reduce conflict for NOT in state 170 resolved as shift
shift/reduce conflict for ! in state 170 resolved as shift
shift/reduce conflict for - in state 170 resolved as shift
shift/reduce conflict for + in state 170 resolved as shift
shift/reduce conflict for DECREMENT in state 170 resolved as shift
shift/reduce conflict for INCREMENT in state 170 resolved as shift
shift/reduce conflict for FALSE in state 170 resolved as shift
shift/reduce conflict for TRUE in state 170 resolved as shift
shift/reduce conflict for STRINGLIT in state 170 resolved as shift
shift/reduce conflict for BOOLIT in state 170 resolved as shift
shift/reduce conflict for FLOATLIT in state 170 resolved as shift
shift/reduce conflict for INTLIT in state 170 resolved as shift
reduce/reduce conflict in state 207 resolved using rule local_decls -> empty
rejected rule (stmt_list -> empty) in state 207