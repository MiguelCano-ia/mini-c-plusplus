Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> object_decl
Rule 5     decl -> class_decl
Rule 6     decl -> func_decl
Rule 7     decl -> var_decl
Rule 8     class_decl -> CLASS IDENT : IDENT { class_body } ;
Rule 9     class_decl -> CLASS IDENT { class_body } ;
Rule 10    class_body -> empty
Rule 11    class_body -> class_member class_body
Rule 12    class_body -> access_specifier class_body
Rule 13    access_specifier -> PUBLIC :
Rule 14    access_specifier -> PRIVATE :
Rule 15    class_member -> constructor_decl
Rule 16    class_member -> method_decl
Rule 17    class_member -> var_decl
Rule 18    method_decl -> type_spec IDENT ( param_list ) compound_stmt
Rule 19    constructor_decl -> IDENT ( param_list ) compound_stmt
Rule 20    func_decl -> type_spec IDENT ( param_list ) compound_stmt
Rule 21    param_list -> param
Rule 22    param_list -> param_list , param
Rule 23    param_list -> empty
Rule 24    param -> type_spec IDENT [ INTLIT ]
Rule 25    param -> type_spec IDENT
Rule 26    compound_stmt -> { block_items }
Rule 27    block_items -> block_item
Rule 28    block_items -> block_items block_item
Rule 29    block_item -> var_decl
Rule 30    block_item -> stmt
Rule 31    stmt -> sprintf_stmt
Rule 32    stmt -> printf_stmt
Rule 33    stmt -> this_stmt
Rule 34    stmt -> for_stmt
Rule 35    stmt -> object_decl
Rule 36    stmt -> super_stmt
Rule 37    stmt -> continue_stmt
Rule 38    stmt -> break_stmt
Rule 39    stmt -> while_stmt
Rule 40    stmt -> return_stmt
Rule 41    stmt -> if_stmt
Rule 42    stmt -> compound_stmt
Rule 43    stmt -> expr_stmt
Rule 44    printf_stmt -> PRINTF ( STRINGLIT ) ;
Rule 45    printf_stmt -> PRINTF ( STRINGLIT , args_list ) ;
Rule 46    sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ;
Rule 47    sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ;
Rule 48    for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt
Rule 49    for_init -> empty
Rule 50    for_init -> assignment_expr
Rule 51    for_init -> var_decl_no_semi
Rule 52    var_decl_no_semi -> type_spec IDENT [ expr ]
Rule 53    var_decl_no_semi -> type_spec IDENT = assignment_expr
Rule 54    var_decl_no_semi -> type_spec IDENT
Rule 55    for_cond -> empty
Rule 56    for_cond -> expr
Rule 57    for_incr -> empty
Rule 58    for_incr -> assignment_expr
Rule 59    super_stmt -> SUPER ( args_list ) ;
Rule 60    expr_stmt -> assignment_expr ;
Rule 61    assignment_expr -> IDENT [ expr ] = assignment_expr
Rule 62    assignment_expr -> expr
Rule 63    assignment_expr -> IDENT DIV_ASSIGN assignment_expr  [precedence=left, level=6]
Rule 64    assignment_expr -> IDENT MULT_ASSIGN assignment_expr  [precedence=left, level=6]
Rule 65    assignment_expr -> IDENT MINUS_ASSIGN assignment_expr  [precedence=left, level=6]
Rule 66    assignment_expr -> IDENT PLUS_ASSIGN assignment_expr  [precedence=left, level=6]
Rule 67    assignment_expr -> IDENT = assignment_expr
Rule 68    primary_expr -> IDENT . SIZE
Rule 69    primary_expr -> IDENT
Rule 70    primary_expr -> IDENT [ expr ]
Rule 71    primary_expr -> IDENT . IDENT ( args_list )
Rule 72    primary_expr -> IDENT ( args_list )
Rule 73    primary_expr -> FALSE
Rule 74    primary_expr -> TRUE
Rule 75    primary_expr -> STRINGLIT
Rule 76    primary_expr -> BOOLIT
Rule 77    primary_expr -> FLOATLIT
Rule 78    primary_expr -> INTLIT
Rule 79    primary_expr -> ( expr )
Rule 80    primary_expr -> NULL
Rule 81    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=nonassoc, level=4]
Rule 82    if_stmt -> IF ( expr ) stmt  [precedence=nonassoc, level=3]
Rule 83    return_stmt -> RETURN expr ;
Rule 84    return_stmt -> RETURN ;
Rule 85    while_stmt -> WHILE ( expr ) stmt
Rule 86    break_stmt -> BREAK ;
Rule 87    continue_stmt -> CONTINUE ;
Rule 88    args_list -> expr
Rule 89    args_list -> args_list , expr
Rule 90    args_list -> empty
Rule 91    this_stmt -> THIS ;
Rule 92    var_decl -> type_spec IDENT [ expr ] ;
Rule 93    var_decl -> type_spec IDENT = assignment_expr ;
Rule 94    var_decl -> type_spec IDENT ;
Rule 95    object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ;
Rule 96    object_decl -> IDENT IDENT ;
Rule 97    type_spec -> STRING
Rule 98    type_spec -> BOOL
Rule 99    type_spec -> FLOAT
Rule 100   type_spec -> INT
Rule 101   type_spec -> VOID
Rule 102   expr -> logical_or_expr
Rule 103   logical_or_expr -> logical_and_expr
Rule 104   logical_or_expr -> logical_or_expr OR logical_and_expr
Rule 105   logical_and_expr -> equality_expr
Rule 106   logical_and_expr -> logical_and_expr AND equality_expr
Rule 107   equality_expr -> relational_expr
Rule 108   equality_expr -> equality_expr NE relational_expr
Rule 109   equality_expr -> equality_expr EQ relational_expr
Rule 110   relational_expr -> additive_expr
Rule 111   relational_expr -> relational_expr GE additive_expr
Rule 112   relational_expr -> relational_expr GT additive_expr
Rule 113   relational_expr -> relational_expr LE additive_expr
Rule 114   relational_expr -> relational_expr LT additive_expr
Rule 115   additive_expr -> multiplicative_expr
Rule 116   additive_expr -> additive_expr - multiplicative_expr  [precedence=right, level=5]
Rule 117   additive_expr -> additive_expr + multiplicative_expr  [precedence=right, level=5]
Rule 118   multiplicative_expr -> unary_expr
Rule 119   multiplicative_expr -> multiplicative_expr % unary_expr
Rule 120   multiplicative_expr -> multiplicative_expr / unary_expr
Rule 121   multiplicative_expr -> multiplicative_expr * unary_expr
Rule 122   unary_expr -> ( type_spec ) unary_expr  [precedence=right, level=2]
Rule 123   unary_expr -> postfix_expr
Rule 124   unary_expr -> NOT unary_expr  [precedence=right, level=5]
Rule 125   unary_expr -> ! unary_expr  [precedence=right, level=5]
Rule 126   unary_expr -> - unary_expr  [precedence=right, level=5]
Rule 127   unary_expr -> + unary_expr  [precedence=right, level=5]
Rule 128   unary_expr -> DECREMENT unary_expr  [precedence=right, level=1]
Rule 129   unary_expr -> INCREMENT unary_expr  [precedence=right, level=1]
Rule 130   postfix_expr -> primary_expr
Rule 131   postfix_expr -> postfix_expr DECREMENT  [precedence=right, level=1]
Rule 132   postfix_expr -> postfix_expr INCREMENT  [precedence=right, level=1]
Rule 133   empty -> <empty>

Terminals, with rules where they appear:

!                    : 125
%                    : 119
(                    : 18 19 20 44 45 46 47 48 59 71 72 79 81 82 85 95 122
)                    : 18 19 20 44 45 46 47 48 59 71 72 79 81 82 85 95 122
*                    : 121
+                    : 117 127
,                    : 22 45 46 47 47 89
-                    : 116 126
.                    : 68 71
/                    : 120
:                    : 8 13 14
;                    : 8 9 44 45 46 47 48 48 59 60 83 84 86 87 91 92 93 94 95 96
=                    : 53 61 67 93 95
AND                  : 106
BOOL                 : 98
BOOLIT               : 76
BREAK                : 86
CLASS                : 8 9
CONTINUE             : 87
DECREMENT            : 128 131
DIV_ASSIGN           : 63
ELSE                 : 81
EQ                   : 109
FALSE                : 73
FLOAT                : 99
FLOATLIT             : 77
FOR                  : 48
GE                   : 111
GT                   : 112
IDENT                : 8 8 9 18 19 20 24 25 52 53 54 61 63 64 65 66 67 68 69 70 71 71 72 92 93 94 95 95 95 96 96
IF                   : 81 82
INCREMENT            : 129 132
INT                  : 100
INTLIT               : 24 78
LE                   : 113
LT                   : 114
MINUS_ASSIGN         : 65
MULT_ASSIGN          : 64
NE                   : 108
NEW                  : 95
NOT                  : 124
NULL                 : 80
OR                   : 104
PLUS_ASSIGN          : 66
PRINTF               : 44 45
PRIVATE              : 14
PUBLIC               : 13
RETURN               : 83 84
SIZE                 : 68
SPRINTF              : 46 47
STRING               : 97
STRINGLIT            : 44 45 46 47 75
SUPER                : 59
THIS                 : 91
TRUE                 : 74
VOID                 : 101
WHILE                : 85
[                    : 24 52 61 70 92
]                    : 24 52 61 70 92
error                : 
{                    : 8 9 26
}                    : 8 9 26

Nonterminals, with rules where they appear:

access_specifier     : 12
additive_expr        : 110 111 112 113 114 116 117
args_list            : 45 47 59 71 72 89 95
assignment_expr      : 50 53 58 60 61 63 64 65 66 67 93
block_item           : 27 28
block_items          : 26 28
break_stmt           : 38
class_body           : 8 9 11 12
class_decl           : 5
class_member         : 11
compound_stmt        : 18 19 20 42 48
constructor_decl     : 15
continue_stmt        : 37
decl                 : 2 3
decl_list            : 1 3
empty                : 10 23 49 55 57 90
equality_expr        : 105 106 108 109
expr                 : 46 47 52 56 61 62 70 79 81 82 83 85 88 89 92
expr_stmt            : 43
for_cond             : 48
for_incr             : 48
for_init             : 48
for_stmt             : 34
func_decl            : 6
if_stmt              : 41
logical_and_expr     : 103 104 106
logical_or_expr      : 102 104
method_decl          : 16
multiplicative_expr  : 115 116 117 119 120 121
object_decl          : 4 35
param                : 21 22
param_list           : 18 19 20 22
postfix_expr         : 123 131 132
primary_expr         : 130
printf_stmt          : 32
program              : 0
relational_expr      : 107 108 109 111 112 113 114
return_stmt          : 40
sprintf_stmt         : 31
stmt                 : 30 81 81 82 85
super_stmt           : 36
this_stmt            : 33
type_spec            : 18 20 24 25 52 53 54 92 93 94 122
unary_expr           : 118 119 120 121 122 124 125 126 127 128 129
var_decl             : 7 17 29
var_decl_no_semi     : 51
while_stmt           : 39


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . object_decl
    (5) decl -> . class_decl
    (6) decl -> . func_decl
    (7) decl -> . var_decl
    (95) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (96) object_decl -> . IDENT IDENT ;
    (8) class_decl -> . CLASS IDENT : IDENT { class_body } ;
    (9) class_decl -> . CLASS IDENT { class_body } ;
    (20) func_decl -> . type_spec IDENT ( param_list ) compound_stmt
    (92) var_decl -> . type_spec IDENT [ expr ] ;
    (93) var_decl -> . type_spec IDENT = assignment_expr ;
    (94) var_decl -> . type_spec IDENT ;
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    IDENT           shift and go to state 8
    CLASS           shift and go to state 9
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    object_decl                    shift and go to state 4
    class_decl                     shift and go to state 5
    func_decl                      shift and go to state 6
    var_decl                       shift and go to state 7
    type_spec                      shift and go to state 10

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . object_decl
    (5) decl -> . class_decl
    (6) decl -> . func_decl
    (7) decl -> . var_decl
    (95) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (96) object_decl -> . IDENT IDENT ;
    (8) class_decl -> . CLASS IDENT : IDENT { class_body } ;
    (9) class_decl -> . CLASS IDENT { class_body } ;
    (20) func_decl -> . type_spec IDENT ( param_list ) compound_stmt
    (92) var_decl -> . type_spec IDENT [ expr ] ;
    (93) var_decl -> . type_spec IDENT = assignment_expr ;
    (94) var_decl -> . type_spec IDENT ;
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    $end            reduce using rule 1 (program -> decl_list .)
    IDENT           shift and go to state 8
    CLASS           shift and go to state 9
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    decl                           shift and go to state 16
    object_decl                    shift and go to state 4
    class_decl                     shift and go to state 5
    func_decl                      shift and go to state 6
    var_decl                       shift and go to state 7
    type_spec                      shift and go to state 10

state 3

    (2) decl_list -> decl .
    IDENT           reduce using rule 2 (decl_list -> decl .)
    CLASS           reduce using rule 2 (decl_list -> decl .)
    STRING          reduce using rule 2 (decl_list -> decl .)
    BOOL            reduce using rule 2 (decl_list -> decl .)
    FLOAT           reduce using rule 2 (decl_list -> decl .)
    INT             reduce using rule 2 (decl_list -> decl .)
    VOID            reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> object_decl .
    IDENT           reduce using rule 4 (decl -> object_decl .)
    CLASS           reduce using rule 4 (decl -> object_decl .)
    STRING          reduce using rule 4 (decl -> object_decl .)
    BOOL            reduce using rule 4 (decl -> object_decl .)
    FLOAT           reduce using rule 4 (decl -> object_decl .)
    INT             reduce using rule 4 (decl -> object_decl .)
    VOID            reduce using rule 4 (decl -> object_decl .)
    $end            reduce using rule 4 (decl -> object_decl .)


state 5

    (5) decl -> class_decl .
    IDENT           reduce using rule 5 (decl -> class_decl .)
    CLASS           reduce using rule 5 (decl -> class_decl .)
    STRING          reduce using rule 5 (decl -> class_decl .)
    BOOL            reduce using rule 5 (decl -> class_decl .)
    FLOAT           reduce using rule 5 (decl -> class_decl .)
    INT             reduce using rule 5 (decl -> class_decl .)
    VOID            reduce using rule 5 (decl -> class_decl .)
    $end            reduce using rule 5 (decl -> class_decl .)


state 6

    (6) decl -> func_decl .
    IDENT           reduce using rule 6 (decl -> func_decl .)
    CLASS           reduce using rule 6 (decl -> func_decl .)
    STRING          reduce using rule 6 (decl -> func_decl .)
    BOOL            reduce using rule 6 (decl -> func_decl .)
    FLOAT           reduce using rule 6 (decl -> func_decl .)
    INT             reduce using rule 6 (decl -> func_decl .)
    VOID            reduce using rule 6 (decl -> func_decl .)
    $end            reduce using rule 6 (decl -> func_decl .)


state 7

    (7) decl -> var_decl .
    IDENT           reduce using rule 7 (decl -> var_decl .)
    CLASS           reduce using rule 7 (decl -> var_decl .)
    STRING          reduce using rule 7 (decl -> var_decl .)
    BOOL            reduce using rule 7 (decl -> var_decl .)
    FLOAT           reduce using rule 7 (decl -> var_decl .)
    INT             reduce using rule 7 (decl -> var_decl .)
    VOID            reduce using rule 7 (decl -> var_decl .)
    $end            reduce using rule 7 (decl -> var_decl .)


state 8

    (95) object_decl -> IDENT . IDENT = NEW IDENT ( args_list ) ;
    (96) object_decl -> IDENT . IDENT ;
    IDENT           shift and go to state 17


state 9

    (8) class_decl -> CLASS . IDENT : IDENT { class_body } ;
    (9) class_decl -> CLASS . IDENT { class_body } ;
    IDENT           shift and go to state 18


state 10

    (20) func_decl -> type_spec . IDENT ( param_list ) compound_stmt
    (92) var_decl -> type_spec . IDENT [ expr ] ;
    (93) var_decl -> type_spec . IDENT = assignment_expr ;
    (94) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 19


state 11

    (97) type_spec -> STRING .
    IDENT           reduce using rule 97 (type_spec -> STRING .)
    )               reduce using rule 97 (type_spec -> STRING .)


state 12

    (98) type_spec -> BOOL .
    IDENT           reduce using rule 98 (type_spec -> BOOL .)
    )               reduce using rule 98 (type_spec -> BOOL .)


state 13

    (99) type_spec -> FLOAT .
    IDENT           reduce using rule 99 (type_spec -> FLOAT .)
    )               reduce using rule 99 (type_spec -> FLOAT .)


state 14

    (100) type_spec -> INT .
    IDENT           reduce using rule 100 (type_spec -> INT .)
    )               reduce using rule 100 (type_spec -> INT .)


state 15

    (101) type_spec -> VOID .
    IDENT           reduce using rule 101 (type_spec -> VOID .)
    )               reduce using rule 101 (type_spec -> VOID .)


state 16

    (3) decl_list -> decl_list decl .
    IDENT           reduce using rule 3 (decl_list -> decl_list decl .)
    CLASS           reduce using rule 3 (decl_list -> decl_list decl .)
    STRING          reduce using rule 3 (decl_list -> decl_list decl .)
    BOOL            reduce using rule 3 (decl_list -> decl_list decl .)
    FLOAT           reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    VOID            reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 17

    (95) object_decl -> IDENT IDENT . = NEW IDENT ( args_list ) ;
    (96) object_decl -> IDENT IDENT . ;
    =               shift and go to state 20
    ;               shift and go to state 21


state 18

    (8) class_decl -> CLASS IDENT . : IDENT { class_body } ;
    (9) class_decl -> CLASS IDENT . { class_body } ;
    :               shift and go to state 22
    {               shift and go to state 23


state 19

    (20) func_decl -> type_spec IDENT . ( param_list ) compound_stmt
    (92) var_decl -> type_spec IDENT . [ expr ] ;
    (93) var_decl -> type_spec IDENT . = assignment_expr ;
    (94) var_decl -> type_spec IDENT . ;
    (               shift and go to state 24
    [               shift and go to state 25
    =               shift and go to state 27
    ;               shift and go to state 26


state 20

    (95) object_decl -> IDENT IDENT = . NEW IDENT ( args_list ) ;
    NEW             shift and go to state 28


state 21

    (96) object_decl -> IDENT IDENT ; .
    IDENT           reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    CLASS           reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    STRING          reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    BOOL            reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    FLOAT           reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    INT             reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    VOID            reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    $end            reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    }               reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    SPRINTF         reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    PRINTF          reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    THIS            reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    FOR             reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    SUPER           reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    CONTINUE        reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    BREAK           reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    WHILE           reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    RETURN          reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    IF              reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    {               reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    (               reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    NOT             reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    !               reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    -               reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    +               reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    DECREMENT       reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    INCREMENT       reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    FALSE           reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    TRUE            reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    STRINGLIT       reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    BOOLIT          reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    FLOATLIT        reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    INTLIT          reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    NULL            reduce using rule 96 (object_decl -> IDENT IDENT ; .)
    ELSE            reduce using rule 96 (object_decl -> IDENT IDENT ; .)


state 22

    (8) class_decl -> CLASS IDENT : . IDENT { class_body } ;
    IDENT           shift and go to state 29


state 23

    (9) class_decl -> CLASS IDENT { . class_body } ;
    (10) class_body -> . empty
    (11) class_body -> . class_member class_body
    (12) class_body -> . access_specifier class_body
    (133) empty -> .
    (15) class_member -> . constructor_decl
    (16) class_member -> . method_decl
    (17) class_member -> . var_decl
    (13) access_specifier -> . PUBLIC :
    (14) access_specifier -> . PRIVATE :
    (19) constructor_decl -> . IDENT ( param_list ) compound_stmt
    (18) method_decl -> . type_spec IDENT ( param_list ) compound_stmt
    (92) var_decl -> . type_spec IDENT [ expr ] ;
    (93) var_decl -> . type_spec IDENT = assignment_expr ;
    (94) var_decl -> . type_spec IDENT ;
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    }               reduce using rule 133 (empty -> .)
    PUBLIC          shift and go to state 38
    PRIVATE         shift and go to state 39
    IDENT           shift and go to state 30
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    class_body                     shift and go to state 31
    empty                          shift and go to state 32
    class_member                   shift and go to state 33
    access_specifier               shift and go to state 34
    constructor_decl               shift and go to state 35
    method_decl                    shift and go to state 36
    var_decl                       shift and go to state 37
    type_spec                      shift and go to state 40

state 24

    (20) func_decl -> type_spec IDENT ( . param_list ) compound_stmt
    (21) param_list -> . param
    (22) param_list -> . param_list , param
    (23) param_list -> . empty
    (24) param -> . type_spec IDENT [ INTLIT ]
    (25) param -> . type_spec IDENT
    (133) empty -> .
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    )               reduce using rule 133 (empty -> .)
    ,               reduce using rule 133 (empty -> .)
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    type_spec                      shift and go to state 41
    param_list                     shift and go to state 42
    param                          shift and go to state 43
    empty                          shift and go to state 44

state 25

    (92) var_decl -> type_spec IDENT [ . expr ] ;
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 46
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 26

    (94) var_decl -> type_spec IDENT ; .
    IDENT           reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    CLASS           reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    STRING          reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    BOOL            reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    FLOAT           reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    INT             reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    VOID            reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    $end            reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    PUBLIC          reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    PRIVATE         reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    }               reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    SPRINTF         reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    PRINTF          reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    THIS            reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    FOR             reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    SUPER           reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    CONTINUE        reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    BREAK           reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    WHILE           reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    RETURN          reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    IF              reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    {               reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    (               reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    NOT             reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    !               reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    -               reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    +               reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    DECREMENT       reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    INCREMENT       reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    FALSE           reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    TRUE            reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    STRINGLIT       reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    BOOLIT          reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    FLOATLIT        reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    INTLIT          reduce using rule 94 (var_decl -> type_spec IDENT ; .)
    NULL            reduce using rule 94 (var_decl -> type_spec IDENT ; .)


state 27

    (93) var_decl -> type_spec IDENT = . assignment_expr ;
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    IDENT           shift and go to state 70
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    assignment_expr                shift and go to state 71
    expr                           shift and go to state 72
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 28

    (95) object_decl -> IDENT IDENT = NEW . IDENT ( args_list ) ;
    IDENT           shift and go to state 73


state 29

    (8) class_decl -> CLASS IDENT : IDENT . { class_body } ;
    {               shift and go to state 74


state 30

    (19) constructor_decl -> IDENT . ( param_list ) compound_stmt
    (               shift and go to state 75


state 31

    (9) class_decl -> CLASS IDENT { class_body . } ;
    }               shift and go to state 76


state 32

    (10) class_body -> empty .
    }               reduce using rule 10 (class_body -> empty .)


state 33

    (11) class_body -> class_member . class_body
    (10) class_body -> . empty
    (11) class_body -> . class_member class_body
    (12) class_body -> . access_specifier class_body
    (133) empty -> .
    (15) class_member -> . constructor_decl
    (16) class_member -> . method_decl
    (17) class_member -> . var_decl
    (13) access_specifier -> . PUBLIC :
    (14) access_specifier -> . PRIVATE :
    (19) constructor_decl -> . IDENT ( param_list ) compound_stmt
    (18) method_decl -> . type_spec IDENT ( param_list ) compound_stmt
    (92) var_decl -> . type_spec IDENT [ expr ] ;
    (93) var_decl -> . type_spec IDENT = assignment_expr ;
    (94) var_decl -> . type_spec IDENT ;
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    }               reduce using rule 133 (empty -> .)
    PUBLIC          shift and go to state 38
    PRIVATE         shift and go to state 39
    IDENT           shift and go to state 30
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    class_member                   shift and go to state 33
    class_body                     shift and go to state 77
    empty                          shift and go to state 32
    access_specifier               shift and go to state 34
    constructor_decl               shift and go to state 35
    method_decl                    shift and go to state 36
    var_decl                       shift and go to state 37
    type_spec                      shift and go to state 40

state 34

    (12) class_body -> access_specifier . class_body
    (10) class_body -> . empty
    (11) class_body -> . class_member class_body
    (12) class_body -> . access_specifier class_body
    (133) empty -> .
    (15) class_member -> . constructor_decl
    (16) class_member -> . method_decl
    (17) class_member -> . var_decl
    (13) access_specifier -> . PUBLIC :
    (14) access_specifier -> . PRIVATE :
    (19) constructor_decl -> . IDENT ( param_list ) compound_stmt
    (18) method_decl -> . type_spec IDENT ( param_list ) compound_stmt
    (92) var_decl -> . type_spec IDENT [ expr ] ;
    (93) var_decl -> . type_spec IDENT = assignment_expr ;
    (94) var_decl -> . type_spec IDENT ;
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    }               reduce using rule 133 (empty -> .)
    PUBLIC          shift and go to state 38
    PRIVATE         shift and go to state 39
    IDENT           shift and go to state 30
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    access_specifier               shift and go to state 34
    class_body                     shift and go to state 78
    empty                          shift and go to state 32
    class_member                   shift and go to state 33
    constructor_decl               shift and go to state 35
    method_decl                    shift and go to state 36
    var_decl                       shift and go to state 37
    type_spec                      shift and go to state 40

state 35

    (15) class_member -> constructor_decl .
    PUBLIC          reduce using rule 15 (class_member -> constructor_decl .)
    PRIVATE         reduce using rule 15 (class_member -> constructor_decl .)
    IDENT           reduce using rule 15 (class_member -> constructor_decl .)
    STRING          reduce using rule 15 (class_member -> constructor_decl .)
    BOOL            reduce using rule 15 (class_member -> constructor_decl .)
    FLOAT           reduce using rule 15 (class_member -> constructor_decl .)
    INT             reduce using rule 15 (class_member -> constructor_decl .)
    VOID            reduce using rule 15 (class_member -> constructor_decl .)
    }               reduce using rule 15 (class_member -> constructor_decl .)


state 36

    (16) class_member -> method_decl .
    PUBLIC          reduce using rule 16 (class_member -> method_decl .)
    PRIVATE         reduce using rule 16 (class_member -> method_decl .)
    IDENT           reduce using rule 16 (class_member -> method_decl .)
    STRING          reduce using rule 16 (class_member -> method_decl .)
    BOOL            reduce using rule 16 (class_member -> method_decl .)
    FLOAT           reduce using rule 16 (class_member -> method_decl .)
    INT             reduce using rule 16 (class_member -> method_decl .)
    VOID            reduce using rule 16 (class_member -> method_decl .)
    }               reduce using rule 16 (class_member -> method_decl .)


state 37

    (17) class_member -> var_decl .
    PUBLIC          reduce using rule 17 (class_member -> var_decl .)
    PRIVATE         reduce using rule 17 (class_member -> var_decl .)
    IDENT           reduce using rule 17 (class_member -> var_decl .)
    STRING          reduce using rule 17 (class_member -> var_decl .)
    BOOL            reduce using rule 17 (class_member -> var_decl .)
    FLOAT           reduce using rule 17 (class_member -> var_decl .)
    INT             reduce using rule 17 (class_member -> var_decl .)
    VOID            reduce using rule 17 (class_member -> var_decl .)
    }               reduce using rule 17 (class_member -> var_decl .)


state 38

    (13) access_specifier -> PUBLIC . :
    :               shift and go to state 79


state 39

    (14) access_specifier -> PRIVATE . :
    :               shift and go to state 80


state 40

    (18) method_decl -> type_spec . IDENT ( param_list ) compound_stmt
    (92) var_decl -> type_spec . IDENT [ expr ] ;
    (93) var_decl -> type_spec . IDENT = assignment_expr ;
    (94) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 81


state 41

    (24) param -> type_spec . IDENT [ INTLIT ]
    (25) param -> type_spec . IDENT
    IDENT           shift and go to state 82


state 42

    (20) func_decl -> type_spec IDENT ( param_list . ) compound_stmt
    (22) param_list -> param_list . , param
    )               shift and go to state 83
    ,               shift and go to state 84


state 43

    (21) param_list -> param .
    )               reduce using rule 21 (param_list -> param .)
    ,               reduce using rule 21 (param_list -> param .)


state 44

    (23) param_list -> empty .
    )               reduce using rule 23 (param_list -> empty .)
    ,               reduce using rule 23 (param_list -> empty .)


state 45

    (68) primary_expr -> IDENT . . SIZE
    (69) primary_expr -> IDENT .
    (70) primary_expr -> IDENT . [ expr ]
    (71) primary_expr -> IDENT . . IDENT ( args_list )
    (72) primary_expr -> IDENT . ( args_list )
    .               shift and go to state 85
    DECREMENT       reduce using rule 69 (primary_expr -> IDENT .)
    INCREMENT       reduce using rule 69 (primary_expr -> IDENT .)
    %               reduce using rule 69 (primary_expr -> IDENT .)
    /               reduce using rule 69 (primary_expr -> IDENT .)
    *               reduce using rule 69 (primary_expr -> IDENT .)
    -               reduce using rule 69 (primary_expr -> IDENT .)
    +               reduce using rule 69 (primary_expr -> IDENT .)
    GE              reduce using rule 69 (primary_expr -> IDENT .)
    GT              reduce using rule 69 (primary_expr -> IDENT .)
    LE              reduce using rule 69 (primary_expr -> IDENT .)
    LT              reduce using rule 69 (primary_expr -> IDENT .)
    NE              reduce using rule 69 (primary_expr -> IDENT .)
    EQ              reduce using rule 69 (primary_expr -> IDENT .)
    AND             reduce using rule 69 (primary_expr -> IDENT .)
    OR              reduce using rule 69 (primary_expr -> IDENT .)
    ]               reduce using rule 69 (primary_expr -> IDENT .)
    ;               reduce using rule 69 (primary_expr -> IDENT .)
    )               reduce using rule 69 (primary_expr -> IDENT .)
    ,               reduce using rule 69 (primary_expr -> IDENT .)
    [               shift and go to state 86
    (               shift and go to state 87


state 46

    (92) var_decl -> type_spec IDENT [ expr . ] ;
    ]               shift and go to state 88


state 47

    (102) expr -> logical_or_expr .
    (104) logical_or_expr -> logical_or_expr . OR logical_and_expr
    ]               reduce using rule 102 (expr -> logical_or_expr .)
    ;               reduce using rule 102 (expr -> logical_or_expr .)
    )               reduce using rule 102 (expr -> logical_or_expr .)
    ,               reduce using rule 102 (expr -> logical_or_expr .)
    OR              shift and go to state 89


state 48

    (103) logical_or_expr -> logical_and_expr .
    (106) logical_and_expr -> logical_and_expr . AND equality_expr
    OR              reduce using rule 103 (logical_or_expr -> logical_and_expr .)
    ]               reduce using rule 103 (logical_or_expr -> logical_and_expr .)
    ;               reduce using rule 103 (logical_or_expr -> logical_and_expr .)
    )               reduce using rule 103 (logical_or_expr -> logical_and_expr .)
    ,               reduce using rule 103 (logical_or_expr -> logical_and_expr .)
    AND             shift and go to state 90


state 49

    (105) logical_and_expr -> equality_expr .
    (108) equality_expr -> equality_expr . NE relational_expr
    (109) equality_expr -> equality_expr . EQ relational_expr
    AND             reduce using rule 105 (logical_and_expr -> equality_expr .)
    OR              reduce using rule 105 (logical_and_expr -> equality_expr .)
    ]               reduce using rule 105 (logical_and_expr -> equality_expr .)
    ;               reduce using rule 105 (logical_and_expr -> equality_expr .)
    )               reduce using rule 105 (logical_and_expr -> equality_expr .)
    ,               reduce using rule 105 (logical_and_expr -> equality_expr .)
    NE              shift and go to state 91
    EQ              shift and go to state 92


state 50

    (107) equality_expr -> relational_expr .
    (111) relational_expr -> relational_expr . GE additive_expr
    (112) relational_expr -> relational_expr . GT additive_expr
    (113) relational_expr -> relational_expr . LE additive_expr
    (114) relational_expr -> relational_expr . LT additive_expr
    NE              reduce using rule 107 (equality_expr -> relational_expr .)
    EQ              reduce using rule 107 (equality_expr -> relational_expr .)
    AND             reduce using rule 107 (equality_expr -> relational_expr .)
    OR              reduce using rule 107 (equality_expr -> relational_expr .)
    ]               reduce using rule 107 (equality_expr -> relational_expr .)
    ;               reduce using rule 107 (equality_expr -> relational_expr .)
    )               reduce using rule 107 (equality_expr -> relational_expr .)
    ,               reduce using rule 107 (equality_expr -> relational_expr .)
    GE              shift and go to state 93
    GT              shift and go to state 94
    LE              shift and go to state 95
    LT              shift and go to state 96


state 51

    (110) relational_expr -> additive_expr .
    (116) additive_expr -> additive_expr . - multiplicative_expr
    (117) additive_expr -> additive_expr . + multiplicative_expr
    GE              reduce using rule 110 (relational_expr -> additive_expr .)
    GT              reduce using rule 110 (relational_expr -> additive_expr .)
    LE              reduce using rule 110 (relational_expr -> additive_expr .)
    LT              reduce using rule 110 (relational_expr -> additive_expr .)
    NE              reduce using rule 110 (relational_expr -> additive_expr .)
    EQ              reduce using rule 110 (relational_expr -> additive_expr .)
    AND             reduce using rule 110 (relational_expr -> additive_expr .)
    OR              reduce using rule 110 (relational_expr -> additive_expr .)
    ]               reduce using rule 110 (relational_expr -> additive_expr .)
    ;               reduce using rule 110 (relational_expr -> additive_expr .)
    )               reduce using rule 110 (relational_expr -> additive_expr .)
    ,               reduce using rule 110 (relational_expr -> additive_expr .)
    -               shift and go to state 97
    +               shift and go to state 98


state 52

    (115) additive_expr -> multiplicative_expr .
    (119) multiplicative_expr -> multiplicative_expr . % unary_expr
    (120) multiplicative_expr -> multiplicative_expr . / unary_expr
    (121) multiplicative_expr -> multiplicative_expr . * unary_expr
    -               reduce using rule 115 (additive_expr -> multiplicative_expr .)
    +               reduce using rule 115 (additive_expr -> multiplicative_expr .)
    GE              reduce using rule 115 (additive_expr -> multiplicative_expr .)
    GT              reduce using rule 115 (additive_expr -> multiplicative_expr .)
    LE              reduce using rule 115 (additive_expr -> multiplicative_expr .)
    LT              reduce using rule 115 (additive_expr -> multiplicative_expr .)
    NE              reduce using rule 115 (additive_expr -> multiplicative_expr .)
    EQ              reduce using rule 115 (additive_expr -> multiplicative_expr .)
    AND             reduce using rule 115 (additive_expr -> multiplicative_expr .)
    OR              reduce using rule 115 (additive_expr -> multiplicative_expr .)
    ]               reduce using rule 115 (additive_expr -> multiplicative_expr .)
    ;               reduce using rule 115 (additive_expr -> multiplicative_expr .)
    )               reduce using rule 115 (additive_expr -> multiplicative_expr .)
    ,               reduce using rule 115 (additive_expr -> multiplicative_expr .)
    %               shift and go to state 99
    /               shift and go to state 100
    *               shift and go to state 101


state 53

    (126) unary_expr -> - . unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    unary_expr                     shift and go to state 102
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 54

    (127) unary_expr -> + . unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    unary_expr                     shift and go to state 103
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 55

    (118) multiplicative_expr -> unary_expr .
    %               reduce using rule 118 (multiplicative_expr -> unary_expr .)
    /               reduce using rule 118 (multiplicative_expr -> unary_expr .)
    *               reduce using rule 118 (multiplicative_expr -> unary_expr .)
    -               reduce using rule 118 (multiplicative_expr -> unary_expr .)
    +               reduce using rule 118 (multiplicative_expr -> unary_expr .)
    GE              reduce using rule 118 (multiplicative_expr -> unary_expr .)
    GT              reduce using rule 118 (multiplicative_expr -> unary_expr .)
    LE              reduce using rule 118 (multiplicative_expr -> unary_expr .)
    LT              reduce using rule 118 (multiplicative_expr -> unary_expr .)
    NE              reduce using rule 118 (multiplicative_expr -> unary_expr .)
    EQ              reduce using rule 118 (multiplicative_expr -> unary_expr .)
    AND             reduce using rule 118 (multiplicative_expr -> unary_expr .)
    OR              reduce using rule 118 (multiplicative_expr -> unary_expr .)
    ]               reduce using rule 118 (multiplicative_expr -> unary_expr .)
    ;               reduce using rule 118 (multiplicative_expr -> unary_expr .)
    )               reduce using rule 118 (multiplicative_expr -> unary_expr .)
    ,               reduce using rule 118 (multiplicative_expr -> unary_expr .)


state 56

    (122) unary_expr -> ( . type_spec ) unary_expr
    (79) primary_expr -> ( . expr )
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    type_spec                      shift and go to state 104
    unary_expr                     shift and go to state 55
    expr                           shift and go to state 105
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 57

    (123) unary_expr -> postfix_expr .
    (131) postfix_expr -> postfix_expr . DECREMENT
    (132) postfix_expr -> postfix_expr . INCREMENT
    %               reduce using rule 123 (unary_expr -> postfix_expr .)
    /               reduce using rule 123 (unary_expr -> postfix_expr .)
    *               reduce using rule 123 (unary_expr -> postfix_expr .)
    -               reduce using rule 123 (unary_expr -> postfix_expr .)
    +               reduce using rule 123 (unary_expr -> postfix_expr .)
    GE              reduce using rule 123 (unary_expr -> postfix_expr .)
    GT              reduce using rule 123 (unary_expr -> postfix_expr .)
    LE              reduce using rule 123 (unary_expr -> postfix_expr .)
    LT              reduce using rule 123 (unary_expr -> postfix_expr .)
    NE              reduce using rule 123 (unary_expr -> postfix_expr .)
    EQ              reduce using rule 123 (unary_expr -> postfix_expr .)
    AND             reduce using rule 123 (unary_expr -> postfix_expr .)
    OR              reduce using rule 123 (unary_expr -> postfix_expr .)
    ]               reduce using rule 123 (unary_expr -> postfix_expr .)
    ;               reduce using rule 123 (unary_expr -> postfix_expr .)
    )               reduce using rule 123 (unary_expr -> postfix_expr .)
    ,               reduce using rule 123 (unary_expr -> postfix_expr .)
    DECREMENT       shift and go to state 106
    INCREMENT       shift and go to state 107


state 58

    (124) unary_expr -> NOT . unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    unary_expr                     shift and go to state 108
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 59

    (125) unary_expr -> ! . unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    unary_expr                     shift and go to state 109
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 60

    (128) unary_expr -> DECREMENT . unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    unary_expr                     shift and go to state 110
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 61

    (129) unary_expr -> INCREMENT . unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    unary_expr                     shift and go to state 111
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 62

    (130) postfix_expr -> primary_expr .
    DECREMENT       reduce using rule 130 (postfix_expr -> primary_expr .)
    INCREMENT       reduce using rule 130 (postfix_expr -> primary_expr .)
    %               reduce using rule 130 (postfix_expr -> primary_expr .)
    /               reduce using rule 130 (postfix_expr -> primary_expr .)
    *               reduce using rule 130 (postfix_expr -> primary_expr .)
    -               reduce using rule 130 (postfix_expr -> primary_expr .)
    +               reduce using rule 130 (postfix_expr -> primary_expr .)
    GE              reduce using rule 130 (postfix_expr -> primary_expr .)
    GT              reduce using rule 130 (postfix_expr -> primary_expr .)
    LE              reduce using rule 130 (postfix_expr -> primary_expr .)
    LT              reduce using rule 130 (postfix_expr -> primary_expr .)
    NE              reduce using rule 130 (postfix_expr -> primary_expr .)
    EQ              reduce using rule 130 (postfix_expr -> primary_expr .)
    AND             reduce using rule 130 (postfix_expr -> primary_expr .)
    OR              reduce using rule 130 (postfix_expr -> primary_expr .)
    ]               reduce using rule 130 (postfix_expr -> primary_expr .)
    ;               reduce using rule 130 (postfix_expr -> primary_expr .)
    )               reduce using rule 130 (postfix_expr -> primary_expr .)
    ,               reduce using rule 130 (postfix_expr -> primary_expr .)


state 63

    (73) primary_expr -> FALSE .
    DECREMENT       reduce using rule 73 (primary_expr -> FALSE .)
    INCREMENT       reduce using rule 73 (primary_expr -> FALSE .)
    %               reduce using rule 73 (primary_expr -> FALSE .)
    /               reduce using rule 73 (primary_expr -> FALSE .)
    *               reduce using rule 73 (primary_expr -> FALSE .)
    -               reduce using rule 73 (primary_expr -> FALSE .)
    +               reduce using rule 73 (primary_expr -> FALSE .)
    GE              reduce using rule 73 (primary_expr -> FALSE .)
    GT              reduce using rule 73 (primary_expr -> FALSE .)
    LE              reduce using rule 73 (primary_expr -> FALSE .)
    LT              reduce using rule 73 (primary_expr -> FALSE .)
    NE              reduce using rule 73 (primary_expr -> FALSE .)
    EQ              reduce using rule 73 (primary_expr -> FALSE .)
    AND             reduce using rule 73 (primary_expr -> FALSE .)
    OR              reduce using rule 73 (primary_expr -> FALSE .)
    ]               reduce using rule 73 (primary_expr -> FALSE .)
    ;               reduce using rule 73 (primary_expr -> FALSE .)
    )               reduce using rule 73 (primary_expr -> FALSE .)
    ,               reduce using rule 73 (primary_expr -> FALSE .)


state 64

    (74) primary_expr -> TRUE .
    DECREMENT       reduce using rule 74 (primary_expr -> TRUE .)
    INCREMENT       reduce using rule 74 (primary_expr -> TRUE .)
    %               reduce using rule 74 (primary_expr -> TRUE .)
    /               reduce using rule 74 (primary_expr -> TRUE .)
    *               reduce using rule 74 (primary_expr -> TRUE .)
    -               reduce using rule 74 (primary_expr -> TRUE .)
    +               reduce using rule 74 (primary_expr -> TRUE .)
    GE              reduce using rule 74 (primary_expr -> TRUE .)
    GT              reduce using rule 74 (primary_expr -> TRUE .)
    LE              reduce using rule 74 (primary_expr -> TRUE .)
    LT              reduce using rule 74 (primary_expr -> TRUE .)
    NE              reduce using rule 74 (primary_expr -> TRUE .)
    EQ              reduce using rule 74 (primary_expr -> TRUE .)
    AND             reduce using rule 74 (primary_expr -> TRUE .)
    OR              reduce using rule 74 (primary_expr -> TRUE .)
    ]               reduce using rule 74 (primary_expr -> TRUE .)
    ;               reduce using rule 74 (primary_expr -> TRUE .)
    )               reduce using rule 74 (primary_expr -> TRUE .)
    ,               reduce using rule 74 (primary_expr -> TRUE .)


state 65

    (75) primary_expr -> STRINGLIT .
    DECREMENT       reduce using rule 75 (primary_expr -> STRINGLIT .)
    INCREMENT       reduce using rule 75 (primary_expr -> STRINGLIT .)
    %               reduce using rule 75 (primary_expr -> STRINGLIT .)
    /               reduce using rule 75 (primary_expr -> STRINGLIT .)
    *               reduce using rule 75 (primary_expr -> STRINGLIT .)
    -               reduce using rule 75 (primary_expr -> STRINGLIT .)
    +               reduce using rule 75 (primary_expr -> STRINGLIT .)
    GE              reduce using rule 75 (primary_expr -> STRINGLIT .)
    GT              reduce using rule 75 (primary_expr -> STRINGLIT .)
    LE              reduce using rule 75 (primary_expr -> STRINGLIT .)
    LT              reduce using rule 75 (primary_expr -> STRINGLIT .)
    NE              reduce using rule 75 (primary_expr -> STRINGLIT .)
    EQ              reduce using rule 75 (primary_expr -> STRINGLIT .)
    AND             reduce using rule 75 (primary_expr -> STRINGLIT .)
    OR              reduce using rule 75 (primary_expr -> STRINGLIT .)
    ]               reduce using rule 75 (primary_expr -> STRINGLIT .)
    ;               reduce using rule 75 (primary_expr -> STRINGLIT .)
    )               reduce using rule 75 (primary_expr -> STRINGLIT .)
    ,               reduce using rule 75 (primary_expr -> STRINGLIT .)


state 66

    (76) primary_expr -> BOOLIT .
    DECREMENT       reduce using rule 76 (primary_expr -> BOOLIT .)
    INCREMENT       reduce using rule 76 (primary_expr -> BOOLIT .)
    %               reduce using rule 76 (primary_expr -> BOOLIT .)
    /               reduce using rule 76 (primary_expr -> BOOLIT .)
    *               reduce using rule 76 (primary_expr -> BOOLIT .)
    -               reduce using rule 76 (primary_expr -> BOOLIT .)
    +               reduce using rule 76 (primary_expr -> BOOLIT .)
    GE              reduce using rule 76 (primary_expr -> BOOLIT .)
    GT              reduce using rule 76 (primary_expr -> BOOLIT .)
    LE              reduce using rule 76 (primary_expr -> BOOLIT .)
    LT              reduce using rule 76 (primary_expr -> BOOLIT .)
    NE              reduce using rule 76 (primary_expr -> BOOLIT .)
    EQ              reduce using rule 76 (primary_expr -> BOOLIT .)
    AND             reduce using rule 76 (primary_expr -> BOOLIT .)
    OR              reduce using rule 76 (primary_expr -> BOOLIT .)
    ]               reduce using rule 76 (primary_expr -> BOOLIT .)
    ;               reduce using rule 76 (primary_expr -> BOOLIT .)
    )               reduce using rule 76 (primary_expr -> BOOLIT .)
    ,               reduce using rule 76 (primary_expr -> BOOLIT .)


state 67

    (77) primary_expr -> FLOATLIT .
    DECREMENT       reduce using rule 77 (primary_expr -> FLOATLIT .)
    INCREMENT       reduce using rule 77 (primary_expr -> FLOATLIT .)
    %               reduce using rule 77 (primary_expr -> FLOATLIT .)
    /               reduce using rule 77 (primary_expr -> FLOATLIT .)
    *               reduce using rule 77 (primary_expr -> FLOATLIT .)
    -               reduce using rule 77 (primary_expr -> FLOATLIT .)
    +               reduce using rule 77 (primary_expr -> FLOATLIT .)
    GE              reduce using rule 77 (primary_expr -> FLOATLIT .)
    GT              reduce using rule 77 (primary_expr -> FLOATLIT .)
    LE              reduce using rule 77 (primary_expr -> FLOATLIT .)
    LT              reduce using rule 77 (primary_expr -> FLOATLIT .)
    NE              reduce using rule 77 (primary_expr -> FLOATLIT .)
    EQ              reduce using rule 77 (primary_expr -> FLOATLIT .)
    AND             reduce using rule 77 (primary_expr -> FLOATLIT .)
    OR              reduce using rule 77 (primary_expr -> FLOATLIT .)
    ]               reduce using rule 77 (primary_expr -> FLOATLIT .)
    ;               reduce using rule 77 (primary_expr -> FLOATLIT .)
    )               reduce using rule 77 (primary_expr -> FLOATLIT .)
    ,               reduce using rule 77 (primary_expr -> FLOATLIT .)


state 68

    (78) primary_expr -> INTLIT .
    DECREMENT       reduce using rule 78 (primary_expr -> INTLIT .)
    INCREMENT       reduce using rule 78 (primary_expr -> INTLIT .)
    %               reduce using rule 78 (primary_expr -> INTLIT .)
    /               reduce using rule 78 (primary_expr -> INTLIT .)
    *               reduce using rule 78 (primary_expr -> INTLIT .)
    -               reduce using rule 78 (primary_expr -> INTLIT .)
    +               reduce using rule 78 (primary_expr -> INTLIT .)
    GE              reduce using rule 78 (primary_expr -> INTLIT .)
    GT              reduce using rule 78 (primary_expr -> INTLIT .)
    LE              reduce using rule 78 (primary_expr -> INTLIT .)
    LT              reduce using rule 78 (primary_expr -> INTLIT .)
    NE              reduce using rule 78 (primary_expr -> INTLIT .)
    EQ              reduce using rule 78 (primary_expr -> INTLIT .)
    AND             reduce using rule 78 (primary_expr -> INTLIT .)
    OR              reduce using rule 78 (primary_expr -> INTLIT .)
    ]               reduce using rule 78 (primary_expr -> INTLIT .)
    ;               reduce using rule 78 (primary_expr -> INTLIT .)
    )               reduce using rule 78 (primary_expr -> INTLIT .)
    ,               reduce using rule 78 (primary_expr -> INTLIT .)


state 69

    (80) primary_expr -> NULL .
    DECREMENT       reduce using rule 80 (primary_expr -> NULL .)
    INCREMENT       reduce using rule 80 (primary_expr -> NULL .)
    %               reduce using rule 80 (primary_expr -> NULL .)
    /               reduce using rule 80 (primary_expr -> NULL .)
    *               reduce using rule 80 (primary_expr -> NULL .)
    -               reduce using rule 80 (primary_expr -> NULL .)
    +               reduce using rule 80 (primary_expr -> NULL .)
    GE              reduce using rule 80 (primary_expr -> NULL .)
    GT              reduce using rule 80 (primary_expr -> NULL .)
    LE              reduce using rule 80 (primary_expr -> NULL .)
    LT              reduce using rule 80 (primary_expr -> NULL .)
    NE              reduce using rule 80 (primary_expr -> NULL .)
    EQ              reduce using rule 80 (primary_expr -> NULL .)
    AND             reduce using rule 80 (primary_expr -> NULL .)
    OR              reduce using rule 80 (primary_expr -> NULL .)
    ]               reduce using rule 80 (primary_expr -> NULL .)
    ;               reduce using rule 80 (primary_expr -> NULL .)
    )               reduce using rule 80 (primary_expr -> NULL .)
    ,               reduce using rule 80 (primary_expr -> NULL .)


state 70

    (61) assignment_expr -> IDENT . [ expr ] = assignment_expr
    (63) assignment_expr -> IDENT . DIV_ASSIGN assignment_expr
    (64) assignment_expr -> IDENT . MULT_ASSIGN assignment_expr
    (65) assignment_expr -> IDENT . MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> IDENT . PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> IDENT . = assignment_expr
    (68) primary_expr -> IDENT . . SIZE
    (69) primary_expr -> IDENT .
    (70) primary_expr -> IDENT . [ expr ]
    (71) primary_expr -> IDENT . . IDENT ( args_list )
    (72) primary_expr -> IDENT . ( args_list )
    [               shift and go to state 112
    DIV_ASSIGN      shift and go to state 114
    MULT_ASSIGN     shift and go to state 115
    MINUS_ASSIGN    shift and go to state 116
    PLUS_ASSIGN     shift and go to state 117
    =               shift and go to state 113
    .               shift and go to state 85
    DECREMENT       reduce using rule 69 (primary_expr -> IDENT .)
    INCREMENT       reduce using rule 69 (primary_expr -> IDENT .)
    %               reduce using rule 69 (primary_expr -> IDENT .)
    /               reduce using rule 69 (primary_expr -> IDENT .)
    *               reduce using rule 69 (primary_expr -> IDENT .)
    -               reduce using rule 69 (primary_expr -> IDENT .)
    +               reduce using rule 69 (primary_expr -> IDENT .)
    GE              reduce using rule 69 (primary_expr -> IDENT .)
    GT              reduce using rule 69 (primary_expr -> IDENT .)
    LE              reduce using rule 69 (primary_expr -> IDENT .)
    LT              reduce using rule 69 (primary_expr -> IDENT .)
    NE              reduce using rule 69 (primary_expr -> IDENT .)
    EQ              reduce using rule 69 (primary_expr -> IDENT .)
    AND             reduce using rule 69 (primary_expr -> IDENT .)
    OR              reduce using rule 69 (primary_expr -> IDENT .)
    ;               reduce using rule 69 (primary_expr -> IDENT .)
    )               reduce using rule 69 (primary_expr -> IDENT .)
    (               shift and go to state 87


state 71

    (93) var_decl -> type_spec IDENT = assignment_expr . ;
    ;               shift and go to state 118


state 72

    (62) assignment_expr -> expr .
    ;               reduce using rule 62 (assignment_expr -> expr .)
    )               reduce using rule 62 (assignment_expr -> expr .)


state 73

    (95) object_decl -> IDENT IDENT = NEW IDENT . ( args_list ) ;
    (               shift and go to state 119


state 74

    (8) class_decl -> CLASS IDENT : IDENT { . class_body } ;
    (10) class_body -> . empty
    (11) class_body -> . class_member class_body
    (12) class_body -> . access_specifier class_body
    (133) empty -> .
    (15) class_member -> . constructor_decl
    (16) class_member -> . method_decl
    (17) class_member -> . var_decl
    (13) access_specifier -> . PUBLIC :
    (14) access_specifier -> . PRIVATE :
    (19) constructor_decl -> . IDENT ( param_list ) compound_stmt
    (18) method_decl -> . type_spec IDENT ( param_list ) compound_stmt
    (92) var_decl -> . type_spec IDENT [ expr ] ;
    (93) var_decl -> . type_spec IDENT = assignment_expr ;
    (94) var_decl -> . type_spec IDENT ;
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    }               reduce using rule 133 (empty -> .)
    PUBLIC          shift and go to state 38
    PRIVATE         shift and go to state 39
    IDENT           shift and go to state 30
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    class_body                     shift and go to state 120
    empty                          shift and go to state 32
    class_member                   shift and go to state 33
    access_specifier               shift and go to state 34
    constructor_decl               shift and go to state 35
    method_decl                    shift and go to state 36
    var_decl                       shift and go to state 37
    type_spec                      shift and go to state 40

state 75

    (19) constructor_decl -> IDENT ( . param_list ) compound_stmt
    (21) param_list -> . param
    (22) param_list -> . param_list , param
    (23) param_list -> . empty
    (24) param -> . type_spec IDENT [ INTLIT ]
    (25) param -> . type_spec IDENT
    (133) empty -> .
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    )               reduce using rule 133 (empty -> .)
    ,               reduce using rule 133 (empty -> .)
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    param_list                     shift and go to state 121
    param                          shift and go to state 43
    empty                          shift and go to state 44
    type_spec                      shift and go to state 41

state 76

    (9) class_decl -> CLASS IDENT { class_body } . ;
    ;               shift and go to state 122


state 77

    (11) class_body -> class_member class_body .
    }               reduce using rule 11 (class_body -> class_member class_body .)


state 78

    (12) class_body -> access_specifier class_body .
    }               reduce using rule 12 (class_body -> access_specifier class_body .)


state 79

    (13) access_specifier -> PUBLIC : .
    PUBLIC          reduce using rule 13 (access_specifier -> PUBLIC : .)
    PRIVATE         reduce using rule 13 (access_specifier -> PUBLIC : .)
    IDENT           reduce using rule 13 (access_specifier -> PUBLIC : .)
    STRING          reduce using rule 13 (access_specifier -> PUBLIC : .)
    BOOL            reduce using rule 13 (access_specifier -> PUBLIC : .)
    FLOAT           reduce using rule 13 (access_specifier -> PUBLIC : .)
    INT             reduce using rule 13 (access_specifier -> PUBLIC : .)
    VOID            reduce using rule 13 (access_specifier -> PUBLIC : .)
    }               reduce using rule 13 (access_specifier -> PUBLIC : .)


state 80

    (14) access_specifier -> PRIVATE : .
    PUBLIC          reduce using rule 14 (access_specifier -> PRIVATE : .)
    PRIVATE         reduce using rule 14 (access_specifier -> PRIVATE : .)
    IDENT           reduce using rule 14 (access_specifier -> PRIVATE : .)
    STRING          reduce using rule 14 (access_specifier -> PRIVATE : .)
    BOOL            reduce using rule 14 (access_specifier -> PRIVATE : .)
    FLOAT           reduce using rule 14 (access_specifier -> PRIVATE : .)
    INT             reduce using rule 14 (access_specifier -> PRIVATE : .)
    VOID            reduce using rule 14 (access_specifier -> PRIVATE : .)
    }               reduce using rule 14 (access_specifier -> PRIVATE : .)


state 81

    (18) method_decl -> type_spec IDENT . ( param_list ) compound_stmt
    (92) var_decl -> type_spec IDENT . [ expr ] ;
    (93) var_decl -> type_spec IDENT . = assignment_expr ;
    (94) var_decl -> type_spec IDENT . ;
    (               shift and go to state 123
    [               shift and go to state 25
    =               shift and go to state 27
    ;               shift and go to state 26


state 82

    (24) param -> type_spec IDENT . [ INTLIT ]
    (25) param -> type_spec IDENT .
    [               shift and go to state 124
    )               reduce using rule 25 (param -> type_spec IDENT .)
    ,               reduce using rule 25 (param -> type_spec IDENT .)


state 83

    (20) func_decl -> type_spec IDENT ( param_list ) . compound_stmt
    (26) compound_stmt -> . { block_items }
    {               shift and go to state 126

    compound_stmt                  shift and go to state 125

state 84

    (22) param_list -> param_list , . param
    (24) param -> . type_spec IDENT [ INTLIT ]
    (25) param -> . type_spec IDENT
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    param                          shift and go to state 127
    type_spec                      shift and go to state 41

state 85

    (68) primary_expr -> IDENT . . SIZE
    (71) primary_expr -> IDENT . . IDENT ( args_list )
    SIZE            shift and go to state 129
    IDENT           shift and go to state 128


state 86

    (70) primary_expr -> IDENT [ . expr ]
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 130
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 87

    (72) primary_expr -> IDENT ( . args_list )
    (88) args_list -> . expr
    (89) args_list -> . args_list , expr
    (90) args_list -> . empty
    (102) expr -> . logical_or_expr
    (133) empty -> .
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    )               reduce using rule 133 (empty -> .)
    ,               reduce using rule 133 (empty -> .)
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    args_list                      shift and go to state 131
    expr                           shift and go to state 132
    empty                          shift and go to state 133
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 88

    (92) var_decl -> type_spec IDENT [ expr ] . ;
    ;               shift and go to state 134


state 89

    (104) logical_or_expr -> logical_or_expr OR . logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    logical_and_expr               shift and go to state 135
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 90

    (106) logical_and_expr -> logical_and_expr AND . equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    equality_expr                  shift and go to state 136
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 91

    (108) equality_expr -> equality_expr NE . relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    relational_expr                shift and go to state 137
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 92

    (109) equality_expr -> equality_expr EQ . relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    relational_expr                shift and go to state 138
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 93

    (111) relational_expr -> relational_expr GE . additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    additive_expr                  shift and go to state 139
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 94

    (112) relational_expr -> relational_expr GT . additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    additive_expr                  shift and go to state 140
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 95

    (113) relational_expr -> relational_expr LE . additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    additive_expr                  shift and go to state 141
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 96

    (114) relational_expr -> relational_expr LT . additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    additive_expr                  shift and go to state 142
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 97

    (116) additive_expr -> additive_expr - . multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    multiplicative_expr            shift and go to state 143
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 98

    (117) additive_expr -> additive_expr + . multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    multiplicative_expr            shift and go to state 144
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 99

    (119) multiplicative_expr -> multiplicative_expr % . unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    unary_expr                     shift and go to state 145
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 100

    (120) multiplicative_expr -> multiplicative_expr / . unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    unary_expr                     shift and go to state 146
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 101

    (121) multiplicative_expr -> multiplicative_expr * . unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    unary_expr                     shift and go to state 147
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 102

    (126) unary_expr -> - unary_expr .
    %               reduce using rule 126 (unary_expr -> - unary_expr .)
    /               reduce using rule 126 (unary_expr -> - unary_expr .)
    *               reduce using rule 126 (unary_expr -> - unary_expr .)
    -               reduce using rule 126 (unary_expr -> - unary_expr .)
    +               reduce using rule 126 (unary_expr -> - unary_expr .)
    GE              reduce using rule 126 (unary_expr -> - unary_expr .)
    GT              reduce using rule 126 (unary_expr -> - unary_expr .)
    LE              reduce using rule 126 (unary_expr -> - unary_expr .)
    LT              reduce using rule 126 (unary_expr -> - unary_expr .)
    NE              reduce using rule 126 (unary_expr -> - unary_expr .)
    EQ              reduce using rule 126 (unary_expr -> - unary_expr .)
    AND             reduce using rule 126 (unary_expr -> - unary_expr .)
    OR              reduce using rule 126 (unary_expr -> - unary_expr .)
    ]               reduce using rule 126 (unary_expr -> - unary_expr .)
    ;               reduce using rule 126 (unary_expr -> - unary_expr .)
    )               reduce using rule 126 (unary_expr -> - unary_expr .)
    ,               reduce using rule 126 (unary_expr -> - unary_expr .)


state 103

    (127) unary_expr -> + unary_expr .
    %               reduce using rule 127 (unary_expr -> + unary_expr .)
    /               reduce using rule 127 (unary_expr -> + unary_expr .)
    *               reduce using rule 127 (unary_expr -> + unary_expr .)
    -               reduce using rule 127 (unary_expr -> + unary_expr .)
    +               reduce using rule 127 (unary_expr -> + unary_expr .)
    GE              reduce using rule 127 (unary_expr -> + unary_expr .)
    GT              reduce using rule 127 (unary_expr -> + unary_expr .)
    LE              reduce using rule 127 (unary_expr -> + unary_expr .)
    LT              reduce using rule 127 (unary_expr -> + unary_expr .)
    NE              reduce using rule 127 (unary_expr -> + unary_expr .)
    EQ              reduce using rule 127 (unary_expr -> + unary_expr .)
    AND             reduce using rule 127 (unary_expr -> + unary_expr .)
    OR              reduce using rule 127 (unary_expr -> + unary_expr .)
    ]               reduce using rule 127 (unary_expr -> + unary_expr .)
    ;               reduce using rule 127 (unary_expr -> + unary_expr .)
    )               reduce using rule 127 (unary_expr -> + unary_expr .)
    ,               reduce using rule 127 (unary_expr -> + unary_expr .)


state 104

    (122) unary_expr -> ( type_spec . ) unary_expr
    )               shift and go to state 148


state 105

    (79) primary_expr -> ( expr . )
    )               shift and go to state 149


state 106

    (131) postfix_expr -> postfix_expr DECREMENT .
    DECREMENT       reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    INCREMENT       reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    %               reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    /               reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    *               reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    -               reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    +               reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    GE              reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    GT              reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    LE              reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    LT              reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    NE              reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    EQ              reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    AND             reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    OR              reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    ]               reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    ;               reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    )               reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)
    ,               reduce using rule 131 (postfix_expr -> postfix_expr DECREMENT .)


state 107

    (132) postfix_expr -> postfix_expr INCREMENT .
    DECREMENT       reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    INCREMENT       reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    %               reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    /               reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    *               reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    -               reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    +               reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    GE              reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    GT              reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    LE              reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    LT              reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    NE              reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    EQ              reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    AND             reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    OR              reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    ]               reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    ;               reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    )               reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)
    ,               reduce using rule 132 (postfix_expr -> postfix_expr INCREMENT .)


state 108

    (124) unary_expr -> NOT unary_expr .
    %               reduce using rule 124 (unary_expr -> NOT unary_expr .)
    /               reduce using rule 124 (unary_expr -> NOT unary_expr .)
    *               reduce using rule 124 (unary_expr -> NOT unary_expr .)
    -               reduce using rule 124 (unary_expr -> NOT unary_expr .)
    +               reduce using rule 124 (unary_expr -> NOT unary_expr .)
    GE              reduce using rule 124 (unary_expr -> NOT unary_expr .)
    GT              reduce using rule 124 (unary_expr -> NOT unary_expr .)
    LE              reduce using rule 124 (unary_expr -> NOT unary_expr .)
    LT              reduce using rule 124 (unary_expr -> NOT unary_expr .)
    NE              reduce using rule 124 (unary_expr -> NOT unary_expr .)
    EQ              reduce using rule 124 (unary_expr -> NOT unary_expr .)
    AND             reduce using rule 124 (unary_expr -> NOT unary_expr .)
    OR              reduce using rule 124 (unary_expr -> NOT unary_expr .)
    ]               reduce using rule 124 (unary_expr -> NOT unary_expr .)
    ;               reduce using rule 124 (unary_expr -> NOT unary_expr .)
    )               reduce using rule 124 (unary_expr -> NOT unary_expr .)
    ,               reduce using rule 124 (unary_expr -> NOT unary_expr .)


state 109

    (125) unary_expr -> ! unary_expr .
    %               reduce using rule 125 (unary_expr -> ! unary_expr .)
    /               reduce using rule 125 (unary_expr -> ! unary_expr .)
    *               reduce using rule 125 (unary_expr -> ! unary_expr .)
    -               reduce using rule 125 (unary_expr -> ! unary_expr .)
    +               reduce using rule 125 (unary_expr -> ! unary_expr .)
    GE              reduce using rule 125 (unary_expr -> ! unary_expr .)
    GT              reduce using rule 125 (unary_expr -> ! unary_expr .)
    LE              reduce using rule 125 (unary_expr -> ! unary_expr .)
    LT              reduce using rule 125 (unary_expr -> ! unary_expr .)
    NE              reduce using rule 125 (unary_expr -> ! unary_expr .)
    EQ              reduce using rule 125 (unary_expr -> ! unary_expr .)
    AND             reduce using rule 125 (unary_expr -> ! unary_expr .)
    OR              reduce using rule 125 (unary_expr -> ! unary_expr .)
    ]               reduce using rule 125 (unary_expr -> ! unary_expr .)
    ;               reduce using rule 125 (unary_expr -> ! unary_expr .)
    )               reduce using rule 125 (unary_expr -> ! unary_expr .)
    ,               reduce using rule 125 (unary_expr -> ! unary_expr .)


state 110

    (128) unary_expr -> DECREMENT unary_expr .
    %               reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    /               reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    *               reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    -               reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    +               reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    GE              reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    GT              reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    LE              reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    LT              reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    NE              reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    EQ              reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    AND             reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    OR              reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    ]               reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    ;               reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    )               reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)
    ,               reduce using rule 128 (unary_expr -> DECREMENT unary_expr .)


state 111

    (129) unary_expr -> INCREMENT unary_expr .
    %               reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    /               reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    *               reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    -               reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    +               reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    GE              reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    GT              reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    LE              reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    LT              reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    NE              reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    EQ              reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    AND             reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    OR              reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    ]               reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    ;               reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    )               reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)
    ,               reduce using rule 129 (unary_expr -> INCREMENT unary_expr .)


state 112

    (61) assignment_expr -> IDENT [ . expr ] = assignment_expr
    (70) primary_expr -> IDENT [ . expr ]
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 150
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 113

    (67) assignment_expr -> IDENT = . assignment_expr
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    IDENT           shift and go to state 70
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    assignment_expr                shift and go to state 151
    expr                           shift and go to state 72
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 114

    (63) assignment_expr -> IDENT DIV_ASSIGN . assignment_expr
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    IDENT           shift and go to state 70
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    assignment_expr                shift and go to state 152
    expr                           shift and go to state 72
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 115

    (64) assignment_expr -> IDENT MULT_ASSIGN . assignment_expr
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    IDENT           shift and go to state 70
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    assignment_expr                shift and go to state 153
    expr                           shift and go to state 72
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 116

    (65) assignment_expr -> IDENT MINUS_ASSIGN . assignment_expr
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    IDENT           shift and go to state 70
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    assignment_expr                shift and go to state 154
    expr                           shift and go to state 72
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 117

    (66) assignment_expr -> IDENT PLUS_ASSIGN . assignment_expr
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    IDENT           shift and go to state 70
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    assignment_expr                shift and go to state 155
    expr                           shift and go to state 72
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 118

    (93) var_decl -> type_spec IDENT = assignment_expr ; .
    IDENT           reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    CLASS           reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    STRING          reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    BOOL            reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    FLOAT           reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    INT             reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    VOID            reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    $end            reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    PUBLIC          reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    PRIVATE         reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    }               reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    SPRINTF         reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    PRINTF          reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    THIS            reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    FOR             reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    SUPER           reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    CONTINUE        reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    BREAK           reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    WHILE           reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    RETURN          reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    IF              reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    {               reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    (               reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    NOT             reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    !               reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    -               reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    +               reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    DECREMENT       reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    INCREMENT       reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    FALSE           reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    TRUE            reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    STRINGLIT       reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    BOOLIT          reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    FLOATLIT        reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    INTLIT          reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)
    NULL            reduce using rule 93 (var_decl -> type_spec IDENT = assignment_expr ; .)


state 119

    (95) object_decl -> IDENT IDENT = NEW IDENT ( . args_list ) ;
    (88) args_list -> . expr
    (89) args_list -> . args_list , expr
    (90) args_list -> . empty
    (102) expr -> . logical_or_expr
    (133) empty -> .
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    )               reduce using rule 133 (empty -> .)
    ,               reduce using rule 133 (empty -> .)
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    args_list                      shift and go to state 156
    expr                           shift and go to state 132
    empty                          shift and go to state 133
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 120

    (8) class_decl -> CLASS IDENT : IDENT { class_body . } ;
    }               shift and go to state 157


state 121

    (19) constructor_decl -> IDENT ( param_list . ) compound_stmt
    (22) param_list -> param_list . , param
    )               shift and go to state 158
    ,               shift and go to state 84


state 122

    (9) class_decl -> CLASS IDENT { class_body } ; .
    IDENT           reduce using rule 9 (class_decl -> CLASS IDENT { class_body } ; .)
    CLASS           reduce using rule 9 (class_decl -> CLASS IDENT { class_body } ; .)
    STRING          reduce using rule 9 (class_decl -> CLASS IDENT { class_body } ; .)
    BOOL            reduce using rule 9 (class_decl -> CLASS IDENT { class_body } ; .)
    FLOAT           reduce using rule 9 (class_decl -> CLASS IDENT { class_body } ; .)
    INT             reduce using rule 9 (class_decl -> CLASS IDENT { class_body } ; .)
    VOID            reduce using rule 9 (class_decl -> CLASS IDENT { class_body } ; .)
    $end            reduce using rule 9 (class_decl -> CLASS IDENT { class_body } ; .)


state 123

    (18) method_decl -> type_spec IDENT ( . param_list ) compound_stmt
    (21) param_list -> . param
    (22) param_list -> . param_list , param
    (23) param_list -> . empty
    (24) param -> . type_spec IDENT [ INTLIT ]
    (25) param -> . type_spec IDENT
    (133) empty -> .
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    )               reduce using rule 133 (empty -> .)
    ,               reduce using rule 133 (empty -> .)
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15

    type_spec                      shift and go to state 41
    param_list                     shift and go to state 159
    param                          shift and go to state 43
    empty                          shift and go to state 44

state 124

    (24) param -> type_spec IDENT [ . INTLIT ]
    INTLIT          shift and go to state 160


state 125

    (20) func_decl -> type_spec IDENT ( param_list ) compound_stmt .
    IDENT           reduce using rule 20 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    CLASS           reduce using rule 20 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    STRING          reduce using rule 20 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    BOOL            reduce using rule 20 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    FLOAT           reduce using rule 20 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    INT             reduce using rule 20 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    VOID            reduce using rule 20 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    $end            reduce using rule 20 (func_decl -> type_spec IDENT ( param_list ) compound_stmt .)


state 126

    (26) compound_stmt -> { . block_items }
    (27) block_items -> . block_item
    (28) block_items -> . block_items block_item
    (29) block_item -> . var_decl
    (30) block_item -> . stmt
    (92) var_decl -> . type_spec IDENT [ expr ] ;
    (93) var_decl -> . type_spec IDENT = assignment_expr ;
    (94) var_decl -> . type_spec IDENT ;
    (31) stmt -> . sprintf_stmt
    (32) stmt -> . printf_stmt
    (33) stmt -> . this_stmt
    (34) stmt -> . for_stmt
    (35) stmt -> . object_decl
    (36) stmt -> . super_stmt
    (37) stmt -> . continue_stmt
    (38) stmt -> . break_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . return_stmt
    (41) stmt -> . if_stmt
    (42) stmt -> . compound_stmt
    (43) stmt -> . expr_stmt
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    (46) sprintf_stmt -> . SPRINTF ( expr , STRINGLIT ) ;
    (47) sprintf_stmt -> . SPRINTF ( expr , STRINGLIT , args_list ) ;
    (44) printf_stmt -> . PRINTF ( STRINGLIT ) ;
    (45) printf_stmt -> . PRINTF ( STRINGLIT , args_list ) ;
    (91) this_stmt -> . THIS ;
    (48) for_stmt -> . FOR ( for_init ; for_cond ; for_incr ) compound_stmt
    (95) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (96) object_decl -> . IDENT IDENT ;
    (59) super_stmt -> . SUPER ( args_list ) ;
    (87) continue_stmt -> . CONTINUE ;
    (86) break_stmt -> . BREAK ;
    (85) while_stmt -> . WHILE ( expr ) stmt
    (83) return_stmt -> . RETURN expr ;
    (84) return_stmt -> . RETURN ;
    (81) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (82) if_stmt -> . IF ( expr ) stmt
    (26) compound_stmt -> . { block_items }
    (60) expr_stmt -> . assignment_expr ;
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15
    SPRINTF         shift and go to state 181
    PRINTF          shift and go to state 182
    THIS            shift and go to state 183
    FOR             shift and go to state 184
    IDENT           shift and go to state 166
    SUPER           shift and go to state 185
    CONTINUE        shift and go to state 186
    BREAK           shift and go to state 187
    WHILE           shift and go to state 188
    RETURN          shift and go to state 189
    IF              shift and go to state 190
    {               shift and go to state 126
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    block_items                    shift and go to state 161
    block_item                     shift and go to state 162
    var_decl                       shift and go to state 163
    stmt                           shift and go to state 164
    type_spec                      shift and go to state 165
    expr                           shift and go to state 72
    assignment_expr                shift and go to state 167
    sprintf_stmt                   shift and go to state 168
    printf_stmt                    shift and go to state 169
    this_stmt                      shift and go to state 170
    for_stmt                       shift and go to state 171
    object_decl                    shift and go to state 172
    super_stmt                     shift and go to state 173
    continue_stmt                  shift and go to state 174
    break_stmt                     shift and go to state 175
    while_stmt                     shift and go to state 176
    return_stmt                    shift and go to state 177
    if_stmt                        shift and go to state 178
    compound_stmt                  shift and go to state 179
    expr_stmt                      shift and go to state 180
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 127

    (22) param_list -> param_list , param .
    )               reduce using rule 22 (param_list -> param_list , param .)
    ,               reduce using rule 22 (param_list -> param_list , param .)


state 128

    (71) primary_expr -> IDENT . IDENT . ( args_list )
    (               shift and go to state 191


state 129

    (68) primary_expr -> IDENT . SIZE .
    DECREMENT       reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    INCREMENT       reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    %               reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    /               reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    *               reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    -               reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    +               reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    GE              reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    GT              reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    LE              reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    LT              reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    NE              reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    EQ              reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    AND             reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    OR              reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    ]               reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    ;               reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    )               reduce using rule 68 (primary_expr -> IDENT . SIZE .)
    ,               reduce using rule 68 (primary_expr -> IDENT . SIZE .)


state 130

    (70) primary_expr -> IDENT [ expr . ]
    ]               shift and go to state 192


state 131

    (72) primary_expr -> IDENT ( args_list . )
    (89) args_list -> args_list . , expr
    )               shift and go to state 193
    ,               shift and go to state 194


state 132

    (88) args_list -> expr .
    )               reduce using rule 88 (args_list -> expr .)
    ,               reduce using rule 88 (args_list -> expr .)


state 133

    (90) args_list -> empty .
    )               reduce using rule 90 (args_list -> empty .)
    ,               reduce using rule 90 (args_list -> empty .)


state 134

    (92) var_decl -> type_spec IDENT [ expr ] ; .
    IDENT           reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    CLASS           reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    STRING          reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    BOOL            reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    FLOAT           reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    INT             reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    VOID            reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    $end            reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    PUBLIC          reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    PRIVATE         reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    }               reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    SPRINTF         reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    PRINTF          reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    THIS            reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    FOR             reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    SUPER           reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    CONTINUE        reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    BREAK           reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    WHILE           reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    RETURN          reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    IF              reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    {               reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    (               reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    NOT             reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    !               reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    -               reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    +               reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    DECREMENT       reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    INCREMENT       reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    FALSE           reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    TRUE            reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    STRINGLIT       reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    BOOLIT          reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    FLOATLIT        reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    INTLIT          reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)
    NULL            reduce using rule 92 (var_decl -> type_spec IDENT [ expr ] ; .)


state 135

    (104) logical_or_expr -> logical_or_expr OR logical_and_expr .
    (106) logical_and_expr -> logical_and_expr . AND equality_expr
    OR              reduce using rule 104 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    ]               reduce using rule 104 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    ;               reduce using rule 104 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    )               reduce using rule 104 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    ,               reduce using rule 104 (logical_or_expr -> logical_or_expr OR logical_and_expr .)
    AND             shift and go to state 90


state 136

    (106) logical_and_expr -> logical_and_expr AND equality_expr .
    (108) equality_expr -> equality_expr . NE relational_expr
    (109) equality_expr -> equality_expr . EQ relational_expr
    AND             reduce using rule 106 (logical_and_expr -> logical_and_expr AND equality_expr .)
    OR              reduce using rule 106 (logical_and_expr -> logical_and_expr AND equality_expr .)
    ]               reduce using rule 106 (logical_and_expr -> logical_and_expr AND equality_expr .)
    ;               reduce using rule 106 (logical_and_expr -> logical_and_expr AND equality_expr .)
    )               reduce using rule 106 (logical_and_expr -> logical_and_expr AND equality_expr .)
    ,               reduce using rule 106 (logical_and_expr -> logical_and_expr AND equality_expr .)
    NE              shift and go to state 91
    EQ              shift and go to state 92


state 137

    (108) equality_expr -> equality_expr NE relational_expr .
    (111) relational_expr -> relational_expr . GE additive_expr
    (112) relational_expr -> relational_expr . GT additive_expr
    (113) relational_expr -> relational_expr . LE additive_expr
    (114) relational_expr -> relational_expr . LT additive_expr
    NE              reduce using rule 108 (equality_expr -> equality_expr NE relational_expr .)
    EQ              reduce using rule 108 (equality_expr -> equality_expr NE relational_expr .)
    AND             reduce using rule 108 (equality_expr -> equality_expr NE relational_expr .)
    OR              reduce using rule 108 (equality_expr -> equality_expr NE relational_expr .)
    ]               reduce using rule 108 (equality_expr -> equality_expr NE relational_expr .)
    ;               reduce using rule 108 (equality_expr -> equality_expr NE relational_expr .)
    )               reduce using rule 108 (equality_expr -> equality_expr NE relational_expr .)
    ,               reduce using rule 108 (equality_expr -> equality_expr NE relational_expr .)
    GE              shift and go to state 93
    GT              shift and go to state 94
    LE              shift and go to state 95
    LT              shift and go to state 96


state 138

    (109) equality_expr -> equality_expr EQ relational_expr .
    (111) relational_expr -> relational_expr . GE additive_expr
    (112) relational_expr -> relational_expr . GT additive_expr
    (113) relational_expr -> relational_expr . LE additive_expr
    (114) relational_expr -> relational_expr . LT additive_expr
    NE              reduce using rule 109 (equality_expr -> equality_expr EQ relational_expr .)
    EQ              reduce using rule 109 (equality_expr -> equality_expr EQ relational_expr .)
    AND             reduce using rule 109 (equality_expr -> equality_expr EQ relational_expr .)
    OR              reduce using rule 109 (equality_expr -> equality_expr EQ relational_expr .)
    ]               reduce using rule 109 (equality_expr -> equality_expr EQ relational_expr .)
    ;               reduce using rule 109 (equality_expr -> equality_expr EQ relational_expr .)
    )               reduce using rule 109 (equality_expr -> equality_expr EQ relational_expr .)
    ,               reduce using rule 109 (equality_expr -> equality_expr EQ relational_expr .)
    GE              shift and go to state 93
    GT              shift and go to state 94
    LE              shift and go to state 95
    LT              shift and go to state 96


state 139

    (111) relational_expr -> relational_expr GE additive_expr .
    (116) additive_expr -> additive_expr . - multiplicative_expr
    (117) additive_expr -> additive_expr . + multiplicative_expr
    GE              reduce using rule 111 (relational_expr -> relational_expr GE additive_expr .)
    GT              reduce using rule 111 (relational_expr -> relational_expr GE additive_expr .)
    LE              reduce using rule 111 (relational_expr -> relational_expr GE additive_expr .)
    LT              reduce using rule 111 (relational_expr -> relational_expr GE additive_expr .)
    NE              reduce using rule 111 (relational_expr -> relational_expr GE additive_expr .)
    EQ              reduce using rule 111 (relational_expr -> relational_expr GE additive_expr .)
    AND             reduce using rule 111 (relational_expr -> relational_expr GE additive_expr .)
    OR              reduce using rule 111 (relational_expr -> relational_expr GE additive_expr .)
    ]               reduce using rule 111 (relational_expr -> relational_expr GE additive_expr .)
    ;               reduce using rule 111 (relational_expr -> relational_expr GE additive_expr .)
    )               reduce using rule 111 (relational_expr -> relational_expr GE additive_expr .)
    ,               reduce using rule 111 (relational_expr -> relational_expr GE additive_expr .)
    -               shift and go to state 97
    +               shift and go to state 98


state 140

    (112) relational_expr -> relational_expr GT additive_expr .
    (116) additive_expr -> additive_expr . - multiplicative_expr
    (117) additive_expr -> additive_expr . + multiplicative_expr
    GE              reduce using rule 112 (relational_expr -> relational_expr GT additive_expr .)
    GT              reduce using rule 112 (relational_expr -> relational_expr GT additive_expr .)
    LE              reduce using rule 112 (relational_expr -> relational_expr GT additive_expr .)
    LT              reduce using rule 112 (relational_expr -> relational_expr GT additive_expr .)
    NE              reduce using rule 112 (relational_expr -> relational_expr GT additive_expr .)
    EQ              reduce using rule 112 (relational_expr -> relational_expr GT additive_expr .)
    AND             reduce using rule 112 (relational_expr -> relational_expr GT additive_expr .)
    OR              reduce using rule 112 (relational_expr -> relational_expr GT additive_expr .)
    ]               reduce using rule 112 (relational_expr -> relational_expr GT additive_expr .)
    ;               reduce using rule 112 (relational_expr -> relational_expr GT additive_expr .)
    )               reduce using rule 112 (relational_expr -> relational_expr GT additive_expr .)
    ,               reduce using rule 112 (relational_expr -> relational_expr GT additive_expr .)
    -               shift and go to state 97
    +               shift and go to state 98


state 141

    (113) relational_expr -> relational_expr LE additive_expr .
    (116) additive_expr -> additive_expr . - multiplicative_expr
    (117) additive_expr -> additive_expr . + multiplicative_expr
    GE              reduce using rule 113 (relational_expr -> relational_expr LE additive_expr .)
    GT              reduce using rule 113 (relational_expr -> relational_expr LE additive_expr .)
    LE              reduce using rule 113 (relational_expr -> relational_expr LE additive_expr .)
    LT              reduce using rule 113 (relational_expr -> relational_expr LE additive_expr .)
    NE              reduce using rule 113 (relational_expr -> relational_expr LE additive_expr .)
    EQ              reduce using rule 113 (relational_expr -> relational_expr LE additive_expr .)
    AND             reduce using rule 113 (relational_expr -> relational_expr LE additive_expr .)
    OR              reduce using rule 113 (relational_expr -> relational_expr LE additive_expr .)
    ]               reduce using rule 113 (relational_expr -> relational_expr LE additive_expr .)
    ;               reduce using rule 113 (relational_expr -> relational_expr LE additive_expr .)
    )               reduce using rule 113 (relational_expr -> relational_expr LE additive_expr .)
    ,               reduce using rule 113 (relational_expr -> relational_expr LE additive_expr .)
    -               shift and go to state 97
    +               shift and go to state 98


state 142

    (114) relational_expr -> relational_expr LT additive_expr .
    (116) additive_expr -> additive_expr . - multiplicative_expr
    (117) additive_expr -> additive_expr . + multiplicative_expr
    GE              reduce using rule 114 (relational_expr -> relational_expr LT additive_expr .)
    GT              reduce using rule 114 (relational_expr -> relational_expr LT additive_expr .)
    LE              reduce using rule 114 (relational_expr -> relational_expr LT additive_expr .)
    LT              reduce using rule 114 (relational_expr -> relational_expr LT additive_expr .)
    NE              reduce using rule 114 (relational_expr -> relational_expr LT additive_expr .)
    EQ              reduce using rule 114 (relational_expr -> relational_expr LT additive_expr .)
    AND             reduce using rule 114 (relational_expr -> relational_expr LT additive_expr .)
    OR              reduce using rule 114 (relational_expr -> relational_expr LT additive_expr .)
    ]               reduce using rule 114 (relational_expr -> relational_expr LT additive_expr .)
    ;               reduce using rule 114 (relational_expr -> relational_expr LT additive_expr .)
    )               reduce using rule 114 (relational_expr -> relational_expr LT additive_expr .)
    ,               reduce using rule 114 (relational_expr -> relational_expr LT additive_expr .)
    -               shift and go to state 97
    +               shift and go to state 98


state 143

    (116) additive_expr -> additive_expr - multiplicative_expr .
    (119) multiplicative_expr -> multiplicative_expr . % unary_expr
    (120) multiplicative_expr -> multiplicative_expr . / unary_expr
    (121) multiplicative_expr -> multiplicative_expr . * unary_expr
    -               reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    +               reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    GE              reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    GT              reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    LE              reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    LT              reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    NE              reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    EQ              reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    AND             reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    OR              reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    ]               reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    ;               reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    )               reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    ,               reduce using rule 116 (additive_expr -> additive_expr - multiplicative_expr .)
    %               shift and go to state 99
    /               shift and go to state 100
    *               shift and go to state 101


state 144

    (117) additive_expr -> additive_expr + multiplicative_expr .
    (119) multiplicative_expr -> multiplicative_expr . % unary_expr
    (120) multiplicative_expr -> multiplicative_expr . / unary_expr
    (121) multiplicative_expr -> multiplicative_expr . * unary_expr
    -               reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    +               reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    GE              reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    GT              reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    LE              reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    LT              reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    NE              reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    EQ              reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    AND             reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    OR              reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    ]               reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    ;               reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    )               reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    ,               reduce using rule 117 (additive_expr -> additive_expr + multiplicative_expr .)
    %               shift and go to state 99
    /               shift and go to state 100
    *               shift and go to state 101


state 145

    (119) multiplicative_expr -> multiplicative_expr % unary_expr .
    %               reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    /               reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    *               reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    -               reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    +               reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    GE              reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    GT              reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    LE              reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    LT              reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    NE              reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    EQ              reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    AND             reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    OR              reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    ]               reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    ;               reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    )               reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)
    ,               reduce using rule 119 (multiplicative_expr -> multiplicative_expr % unary_expr .)


state 146

    (120) multiplicative_expr -> multiplicative_expr / unary_expr .
    %               reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    /               reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    *               reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    -               reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    +               reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    GE              reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    GT              reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    LE              reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    LT              reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    NE              reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    EQ              reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    AND             reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    OR              reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    ]               reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    ;               reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    )               reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)
    ,               reduce using rule 120 (multiplicative_expr -> multiplicative_expr / unary_expr .)


state 147

    (121) multiplicative_expr -> multiplicative_expr * unary_expr .
    %               reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    /               reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    *               reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    -               reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    +               reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    GE              reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    GT              reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    LE              reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    LT              reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    NE              reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    EQ              reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    AND             reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    OR              reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    ]               reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    ;               reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    )               reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)
    ,               reduce using rule 121 (multiplicative_expr -> multiplicative_expr * unary_expr .)


state 148

    (122) unary_expr -> ( type_spec ) . unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    unary_expr                     shift and go to state 195
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 149

    (79) primary_expr -> ( expr ) .
    DECREMENT       reduce using rule 79 (primary_expr -> ( expr ) .)
    INCREMENT       reduce using rule 79 (primary_expr -> ( expr ) .)
    %               reduce using rule 79 (primary_expr -> ( expr ) .)
    /               reduce using rule 79 (primary_expr -> ( expr ) .)
    *               reduce using rule 79 (primary_expr -> ( expr ) .)
    -               reduce using rule 79 (primary_expr -> ( expr ) .)
    +               reduce using rule 79 (primary_expr -> ( expr ) .)
    GE              reduce using rule 79 (primary_expr -> ( expr ) .)
    GT              reduce using rule 79 (primary_expr -> ( expr ) .)
    LE              reduce using rule 79 (primary_expr -> ( expr ) .)
    LT              reduce using rule 79 (primary_expr -> ( expr ) .)
    NE              reduce using rule 79 (primary_expr -> ( expr ) .)
    EQ              reduce using rule 79 (primary_expr -> ( expr ) .)
    AND             reduce using rule 79 (primary_expr -> ( expr ) .)
    OR              reduce using rule 79 (primary_expr -> ( expr ) .)
    ]               reduce using rule 79 (primary_expr -> ( expr ) .)
    ;               reduce using rule 79 (primary_expr -> ( expr ) .)
    )               reduce using rule 79 (primary_expr -> ( expr ) .)
    ,               reduce using rule 79 (primary_expr -> ( expr ) .)


state 150

    (61) assignment_expr -> IDENT [ expr . ] = assignment_expr
    (70) primary_expr -> IDENT [ expr . ]
    ]               shift and go to state 196


state 151

    (67) assignment_expr -> IDENT = assignment_expr .
    ;               reduce using rule 67 (assignment_expr -> IDENT = assignment_expr .)
    )               reduce using rule 67 (assignment_expr -> IDENT = assignment_expr .)


state 152

    (63) assignment_expr -> IDENT DIV_ASSIGN assignment_expr .
    ;               reduce using rule 63 (assignment_expr -> IDENT DIV_ASSIGN assignment_expr .)
    )               reduce using rule 63 (assignment_expr -> IDENT DIV_ASSIGN assignment_expr .)


state 153

    (64) assignment_expr -> IDENT MULT_ASSIGN assignment_expr .
    ;               reduce using rule 64 (assignment_expr -> IDENT MULT_ASSIGN assignment_expr .)
    )               reduce using rule 64 (assignment_expr -> IDENT MULT_ASSIGN assignment_expr .)


state 154

    (65) assignment_expr -> IDENT MINUS_ASSIGN assignment_expr .
    ;               reduce using rule 65 (assignment_expr -> IDENT MINUS_ASSIGN assignment_expr .)
    )               reduce using rule 65 (assignment_expr -> IDENT MINUS_ASSIGN assignment_expr .)


state 155

    (66) assignment_expr -> IDENT PLUS_ASSIGN assignment_expr .
    ;               reduce using rule 66 (assignment_expr -> IDENT PLUS_ASSIGN assignment_expr .)
    )               reduce using rule 66 (assignment_expr -> IDENT PLUS_ASSIGN assignment_expr .)


state 156

    (95) object_decl -> IDENT IDENT = NEW IDENT ( args_list . ) ;
    (89) args_list -> args_list . , expr
    )               shift and go to state 197
    ,               shift and go to state 194


state 157

    (8) class_decl -> CLASS IDENT : IDENT { class_body } . ;
    ;               shift and go to state 198


state 158

    (19) constructor_decl -> IDENT ( param_list ) . compound_stmt
    (26) compound_stmt -> . { block_items }
    {               shift and go to state 126

    compound_stmt                  shift and go to state 199

state 159

    (18) method_decl -> type_spec IDENT ( param_list . ) compound_stmt
    (22) param_list -> param_list . , param
    )               shift and go to state 200
    ,               shift and go to state 84


state 160

    (24) param -> type_spec IDENT [ INTLIT . ]
    ]               shift and go to state 201


state 161

    (26) compound_stmt -> { block_items . }
    (28) block_items -> block_items . block_item
    (29) block_item -> . var_decl
    (30) block_item -> . stmt
    (92) var_decl -> . type_spec IDENT [ expr ] ;
    (93) var_decl -> . type_spec IDENT = assignment_expr ;
    (94) var_decl -> . type_spec IDENT ;
    (31) stmt -> . sprintf_stmt
    (32) stmt -> . printf_stmt
    (33) stmt -> . this_stmt
    (34) stmt -> . for_stmt
    (35) stmt -> . object_decl
    (36) stmt -> . super_stmt
    (37) stmt -> . continue_stmt
    (38) stmt -> . break_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . return_stmt
    (41) stmt -> . if_stmt
    (42) stmt -> . compound_stmt
    (43) stmt -> . expr_stmt
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    (46) sprintf_stmt -> . SPRINTF ( expr , STRINGLIT ) ;
    (47) sprintf_stmt -> . SPRINTF ( expr , STRINGLIT , args_list ) ;
    (44) printf_stmt -> . PRINTF ( STRINGLIT ) ;
    (45) printf_stmt -> . PRINTF ( STRINGLIT , args_list ) ;
    (91) this_stmt -> . THIS ;
    (48) for_stmt -> . FOR ( for_init ; for_cond ; for_incr ) compound_stmt
    (95) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (96) object_decl -> . IDENT IDENT ;
    (59) super_stmt -> . SUPER ( args_list ) ;
    (87) continue_stmt -> . CONTINUE ;
    (86) break_stmt -> . BREAK ;
    (85) while_stmt -> . WHILE ( expr ) stmt
    (83) return_stmt -> . RETURN expr ;
    (84) return_stmt -> . RETURN ;
    (81) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (82) if_stmt -> . IF ( expr ) stmt
    (26) compound_stmt -> . { block_items }
    (60) expr_stmt -> . assignment_expr ;
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    }               shift and go to state 202
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15
    SPRINTF         shift and go to state 181
    PRINTF          shift and go to state 182
    THIS            shift and go to state 183
    FOR             shift and go to state 184
    IDENT           shift and go to state 166
    SUPER           shift and go to state 185
    CONTINUE        shift and go to state 186
    BREAK           shift and go to state 187
    WHILE           shift and go to state 188
    RETURN          shift and go to state 189
    IF              shift and go to state 190
    {               shift and go to state 126
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    block_item                     shift and go to state 203
    var_decl                       shift and go to state 163
    stmt                           shift and go to state 164
    type_spec                      shift and go to state 165
    expr                           shift and go to state 72
    assignment_expr                shift and go to state 167
    sprintf_stmt                   shift and go to state 168
    printf_stmt                    shift and go to state 169
    this_stmt                      shift and go to state 170
    for_stmt                       shift and go to state 171
    object_decl                    shift and go to state 172
    super_stmt                     shift and go to state 173
    continue_stmt                  shift and go to state 174
    break_stmt                     shift and go to state 175
    while_stmt                     shift and go to state 176
    return_stmt                    shift and go to state 177
    if_stmt                        shift and go to state 178
    compound_stmt                  shift and go to state 179
    expr_stmt                      shift and go to state 180
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 162

    (27) block_items -> block_item .
    }               reduce using rule 27 (block_items -> block_item .)
    STRING          reduce using rule 27 (block_items -> block_item .)
    BOOL            reduce using rule 27 (block_items -> block_item .)
    FLOAT           reduce using rule 27 (block_items -> block_item .)
    INT             reduce using rule 27 (block_items -> block_item .)
    VOID            reduce using rule 27 (block_items -> block_item .)
    SPRINTF         reduce using rule 27 (block_items -> block_item .)
    PRINTF          reduce using rule 27 (block_items -> block_item .)
    THIS            reduce using rule 27 (block_items -> block_item .)
    FOR             reduce using rule 27 (block_items -> block_item .)
    IDENT           reduce using rule 27 (block_items -> block_item .)
    SUPER           reduce using rule 27 (block_items -> block_item .)
    CONTINUE        reduce using rule 27 (block_items -> block_item .)
    BREAK           reduce using rule 27 (block_items -> block_item .)
    WHILE           reduce using rule 27 (block_items -> block_item .)
    RETURN          reduce using rule 27 (block_items -> block_item .)
    IF              reduce using rule 27 (block_items -> block_item .)
    {               reduce using rule 27 (block_items -> block_item .)
    (               reduce using rule 27 (block_items -> block_item .)
    NOT             reduce using rule 27 (block_items -> block_item .)
    !               reduce using rule 27 (block_items -> block_item .)
    -               reduce using rule 27 (block_items -> block_item .)
    +               reduce using rule 27 (block_items -> block_item .)
    DECREMENT       reduce using rule 27 (block_items -> block_item .)
    INCREMENT       reduce using rule 27 (block_items -> block_item .)
    FALSE           reduce using rule 27 (block_items -> block_item .)
    TRUE            reduce using rule 27 (block_items -> block_item .)
    STRINGLIT       reduce using rule 27 (block_items -> block_item .)
    BOOLIT          reduce using rule 27 (block_items -> block_item .)
    FLOATLIT        reduce using rule 27 (block_items -> block_item .)
    INTLIT          reduce using rule 27 (block_items -> block_item .)
    NULL            reduce using rule 27 (block_items -> block_item .)


state 163

    (29) block_item -> var_decl .
    }               reduce using rule 29 (block_item -> var_decl .)
    STRING          reduce using rule 29 (block_item -> var_decl .)
    BOOL            reduce using rule 29 (block_item -> var_decl .)
    FLOAT           reduce using rule 29 (block_item -> var_decl .)
    INT             reduce using rule 29 (block_item -> var_decl .)
    VOID            reduce using rule 29 (block_item -> var_decl .)
    SPRINTF         reduce using rule 29 (block_item -> var_decl .)
    PRINTF          reduce using rule 29 (block_item -> var_decl .)
    THIS            reduce using rule 29 (block_item -> var_decl .)
    FOR             reduce using rule 29 (block_item -> var_decl .)
    IDENT           reduce using rule 29 (block_item -> var_decl .)
    SUPER           reduce using rule 29 (block_item -> var_decl .)
    CONTINUE        reduce using rule 29 (block_item -> var_decl .)
    BREAK           reduce using rule 29 (block_item -> var_decl .)
    WHILE           reduce using rule 29 (block_item -> var_decl .)
    RETURN          reduce using rule 29 (block_item -> var_decl .)
    IF              reduce using rule 29 (block_item -> var_decl .)
    {               reduce using rule 29 (block_item -> var_decl .)
    (               reduce using rule 29 (block_item -> var_decl .)
    NOT             reduce using rule 29 (block_item -> var_decl .)
    !               reduce using rule 29 (block_item -> var_decl .)
    -               reduce using rule 29 (block_item -> var_decl .)
    +               reduce using rule 29 (block_item -> var_decl .)
    DECREMENT       reduce using rule 29 (block_item -> var_decl .)
    INCREMENT       reduce using rule 29 (block_item -> var_decl .)
    FALSE           reduce using rule 29 (block_item -> var_decl .)
    TRUE            reduce using rule 29 (block_item -> var_decl .)
    STRINGLIT       reduce using rule 29 (block_item -> var_decl .)
    BOOLIT          reduce using rule 29 (block_item -> var_decl .)
    FLOATLIT        reduce using rule 29 (block_item -> var_decl .)
    INTLIT          reduce using rule 29 (block_item -> var_decl .)
    NULL            reduce using rule 29 (block_item -> var_decl .)


state 164

    (30) block_item -> stmt .
    }               reduce using rule 30 (block_item -> stmt .)
    STRING          reduce using rule 30 (block_item -> stmt .)
    BOOL            reduce using rule 30 (block_item -> stmt .)
    FLOAT           reduce using rule 30 (block_item -> stmt .)
    INT             reduce using rule 30 (block_item -> stmt .)
    VOID            reduce using rule 30 (block_item -> stmt .)
    SPRINTF         reduce using rule 30 (block_item -> stmt .)
    PRINTF          reduce using rule 30 (block_item -> stmt .)
    THIS            reduce using rule 30 (block_item -> stmt .)
    FOR             reduce using rule 30 (block_item -> stmt .)
    IDENT           reduce using rule 30 (block_item -> stmt .)
    SUPER           reduce using rule 30 (block_item -> stmt .)
    CONTINUE        reduce using rule 30 (block_item -> stmt .)
    BREAK           reduce using rule 30 (block_item -> stmt .)
    WHILE           reduce using rule 30 (block_item -> stmt .)
    RETURN          reduce using rule 30 (block_item -> stmt .)
    IF              reduce using rule 30 (block_item -> stmt .)
    {               reduce using rule 30 (block_item -> stmt .)
    (               reduce using rule 30 (block_item -> stmt .)
    NOT             reduce using rule 30 (block_item -> stmt .)
    !               reduce using rule 30 (block_item -> stmt .)
    -               reduce using rule 30 (block_item -> stmt .)
    +               reduce using rule 30 (block_item -> stmt .)
    DECREMENT       reduce using rule 30 (block_item -> stmt .)
    INCREMENT       reduce using rule 30 (block_item -> stmt .)
    FALSE           reduce using rule 30 (block_item -> stmt .)
    TRUE            reduce using rule 30 (block_item -> stmt .)
    STRINGLIT       reduce using rule 30 (block_item -> stmt .)
    BOOLIT          reduce using rule 30 (block_item -> stmt .)
    FLOATLIT        reduce using rule 30 (block_item -> stmt .)
    INTLIT          reduce using rule 30 (block_item -> stmt .)
    NULL            reduce using rule 30 (block_item -> stmt .)


state 165

    (92) var_decl -> type_spec . IDENT [ expr ] ;
    (93) var_decl -> type_spec . IDENT = assignment_expr ;
    (94) var_decl -> type_spec . IDENT ;
    IDENT           shift and go to state 204


state 166

    (95) object_decl -> IDENT . IDENT = NEW IDENT ( args_list ) ;
    (96) object_decl -> IDENT . IDENT ;
    (61) assignment_expr -> IDENT . [ expr ] = assignment_expr
    (63) assignment_expr -> IDENT . DIV_ASSIGN assignment_expr
    (64) assignment_expr -> IDENT . MULT_ASSIGN assignment_expr
    (65) assignment_expr -> IDENT . MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> IDENT . PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> IDENT . = assignment_expr
    (68) primary_expr -> IDENT . . SIZE
    (69) primary_expr -> IDENT .
    (70) primary_expr -> IDENT . [ expr ]
    (71) primary_expr -> IDENT . . IDENT ( args_list )
    (72) primary_expr -> IDENT . ( args_list )
    IDENT           shift and go to state 17
    [               shift and go to state 112
    DIV_ASSIGN      shift and go to state 114
    MULT_ASSIGN     shift and go to state 115
    MINUS_ASSIGN    shift and go to state 116
    PLUS_ASSIGN     shift and go to state 117
    =               shift and go to state 113
    .               shift and go to state 85
    DECREMENT       reduce using rule 69 (primary_expr -> IDENT .)
    INCREMENT       reduce using rule 69 (primary_expr -> IDENT .)
    %               reduce using rule 69 (primary_expr -> IDENT .)
    /               reduce using rule 69 (primary_expr -> IDENT .)
    *               reduce using rule 69 (primary_expr -> IDENT .)
    -               reduce using rule 69 (primary_expr -> IDENT .)
    +               reduce using rule 69 (primary_expr -> IDENT .)
    GE              reduce using rule 69 (primary_expr -> IDENT .)
    GT              reduce using rule 69 (primary_expr -> IDENT .)
    LE              reduce using rule 69 (primary_expr -> IDENT .)
    LT              reduce using rule 69 (primary_expr -> IDENT .)
    NE              reduce using rule 69 (primary_expr -> IDENT .)
    EQ              reduce using rule 69 (primary_expr -> IDENT .)
    AND             reduce using rule 69 (primary_expr -> IDENT .)
    OR              reduce using rule 69 (primary_expr -> IDENT .)
    ;               reduce using rule 69 (primary_expr -> IDENT .)
    (               shift and go to state 87


state 167

    (60) expr_stmt -> assignment_expr . ;
    ;               shift and go to state 205


state 168

    (31) stmt -> sprintf_stmt .
    }               reduce using rule 31 (stmt -> sprintf_stmt .)
    STRING          reduce using rule 31 (stmt -> sprintf_stmt .)
    BOOL            reduce using rule 31 (stmt -> sprintf_stmt .)
    FLOAT           reduce using rule 31 (stmt -> sprintf_stmt .)
    INT             reduce using rule 31 (stmt -> sprintf_stmt .)
    VOID            reduce using rule 31 (stmt -> sprintf_stmt .)
    SPRINTF         reduce using rule 31 (stmt -> sprintf_stmt .)
    PRINTF          reduce using rule 31 (stmt -> sprintf_stmt .)
    THIS            reduce using rule 31 (stmt -> sprintf_stmt .)
    FOR             reduce using rule 31 (stmt -> sprintf_stmt .)
    IDENT           reduce using rule 31 (stmt -> sprintf_stmt .)
    SUPER           reduce using rule 31 (stmt -> sprintf_stmt .)
    CONTINUE        reduce using rule 31 (stmt -> sprintf_stmt .)
    BREAK           reduce using rule 31 (stmt -> sprintf_stmt .)
    WHILE           reduce using rule 31 (stmt -> sprintf_stmt .)
    RETURN          reduce using rule 31 (stmt -> sprintf_stmt .)
    IF              reduce using rule 31 (stmt -> sprintf_stmt .)
    {               reduce using rule 31 (stmt -> sprintf_stmt .)
    (               reduce using rule 31 (stmt -> sprintf_stmt .)
    NOT             reduce using rule 31 (stmt -> sprintf_stmt .)
    !               reduce using rule 31 (stmt -> sprintf_stmt .)
    -               reduce using rule 31 (stmt -> sprintf_stmt .)
    +               reduce using rule 31 (stmt -> sprintf_stmt .)
    DECREMENT       reduce using rule 31 (stmt -> sprintf_stmt .)
    INCREMENT       reduce using rule 31 (stmt -> sprintf_stmt .)
    FALSE           reduce using rule 31 (stmt -> sprintf_stmt .)
    TRUE            reduce using rule 31 (stmt -> sprintf_stmt .)
    STRINGLIT       reduce using rule 31 (stmt -> sprintf_stmt .)
    BOOLIT          reduce using rule 31 (stmt -> sprintf_stmt .)
    FLOATLIT        reduce using rule 31 (stmt -> sprintf_stmt .)
    INTLIT          reduce using rule 31 (stmt -> sprintf_stmt .)
    NULL            reduce using rule 31 (stmt -> sprintf_stmt .)
    ELSE            reduce using rule 31 (stmt -> sprintf_stmt .)


state 169

    (32) stmt -> printf_stmt .
    }               reduce using rule 32 (stmt -> printf_stmt .)
    STRING          reduce using rule 32 (stmt -> printf_stmt .)
    BOOL            reduce using rule 32 (stmt -> printf_stmt .)
    FLOAT           reduce using rule 32 (stmt -> printf_stmt .)
    INT             reduce using rule 32 (stmt -> printf_stmt .)
    VOID            reduce using rule 32 (stmt -> printf_stmt .)
    SPRINTF         reduce using rule 32 (stmt -> printf_stmt .)
    PRINTF          reduce using rule 32 (stmt -> printf_stmt .)
    THIS            reduce using rule 32 (stmt -> printf_stmt .)
    FOR             reduce using rule 32 (stmt -> printf_stmt .)
    IDENT           reduce using rule 32 (stmt -> printf_stmt .)
    SUPER           reduce using rule 32 (stmt -> printf_stmt .)
    CONTINUE        reduce using rule 32 (stmt -> printf_stmt .)
    BREAK           reduce using rule 32 (stmt -> printf_stmt .)
    WHILE           reduce using rule 32 (stmt -> printf_stmt .)
    RETURN          reduce using rule 32 (stmt -> printf_stmt .)
    IF              reduce using rule 32 (stmt -> printf_stmt .)
    {               reduce using rule 32 (stmt -> printf_stmt .)
    (               reduce using rule 32 (stmt -> printf_stmt .)
    NOT             reduce using rule 32 (stmt -> printf_stmt .)
    !               reduce using rule 32 (stmt -> printf_stmt .)
    -               reduce using rule 32 (stmt -> printf_stmt .)
    +               reduce using rule 32 (stmt -> printf_stmt .)
    DECREMENT       reduce using rule 32 (stmt -> printf_stmt .)
    INCREMENT       reduce using rule 32 (stmt -> printf_stmt .)
    FALSE           reduce using rule 32 (stmt -> printf_stmt .)
    TRUE            reduce using rule 32 (stmt -> printf_stmt .)
    STRINGLIT       reduce using rule 32 (stmt -> printf_stmt .)
    BOOLIT          reduce using rule 32 (stmt -> printf_stmt .)
    FLOATLIT        reduce using rule 32 (stmt -> printf_stmt .)
    INTLIT          reduce using rule 32 (stmt -> printf_stmt .)
    NULL            reduce using rule 32 (stmt -> printf_stmt .)
    ELSE            reduce using rule 32 (stmt -> printf_stmt .)


state 170

    (33) stmt -> this_stmt .
    }               reduce using rule 33 (stmt -> this_stmt .)
    STRING          reduce using rule 33 (stmt -> this_stmt .)
    BOOL            reduce using rule 33 (stmt -> this_stmt .)
    FLOAT           reduce using rule 33 (stmt -> this_stmt .)
    INT             reduce using rule 33 (stmt -> this_stmt .)
    VOID            reduce using rule 33 (stmt -> this_stmt .)
    SPRINTF         reduce using rule 33 (stmt -> this_stmt .)
    PRINTF          reduce using rule 33 (stmt -> this_stmt .)
    THIS            reduce using rule 33 (stmt -> this_stmt .)
    FOR             reduce using rule 33 (stmt -> this_stmt .)
    IDENT           reduce using rule 33 (stmt -> this_stmt .)
    SUPER           reduce using rule 33 (stmt -> this_stmt .)
    CONTINUE        reduce using rule 33 (stmt -> this_stmt .)
    BREAK           reduce using rule 33 (stmt -> this_stmt .)
    WHILE           reduce using rule 33 (stmt -> this_stmt .)
    RETURN          reduce using rule 33 (stmt -> this_stmt .)
    IF              reduce using rule 33 (stmt -> this_stmt .)
    {               reduce using rule 33 (stmt -> this_stmt .)
    (               reduce using rule 33 (stmt -> this_stmt .)
    NOT             reduce using rule 33 (stmt -> this_stmt .)
    !               reduce using rule 33 (stmt -> this_stmt .)
    -               reduce using rule 33 (stmt -> this_stmt .)
    +               reduce using rule 33 (stmt -> this_stmt .)
    DECREMENT       reduce using rule 33 (stmt -> this_stmt .)
    INCREMENT       reduce using rule 33 (stmt -> this_stmt .)
    FALSE           reduce using rule 33 (stmt -> this_stmt .)
    TRUE            reduce using rule 33 (stmt -> this_stmt .)
    STRINGLIT       reduce using rule 33 (stmt -> this_stmt .)
    BOOLIT          reduce using rule 33 (stmt -> this_stmt .)
    FLOATLIT        reduce using rule 33 (stmt -> this_stmt .)
    INTLIT          reduce using rule 33 (stmt -> this_stmt .)
    NULL            reduce using rule 33 (stmt -> this_stmt .)
    ELSE            reduce using rule 33 (stmt -> this_stmt .)


state 171

    (34) stmt -> for_stmt .
    }               reduce using rule 34 (stmt -> for_stmt .)
    STRING          reduce using rule 34 (stmt -> for_stmt .)
    BOOL            reduce using rule 34 (stmt -> for_stmt .)
    FLOAT           reduce using rule 34 (stmt -> for_stmt .)
    INT             reduce using rule 34 (stmt -> for_stmt .)
    VOID            reduce using rule 34 (stmt -> for_stmt .)
    SPRINTF         reduce using rule 34 (stmt -> for_stmt .)
    PRINTF          reduce using rule 34 (stmt -> for_stmt .)
    THIS            reduce using rule 34 (stmt -> for_stmt .)
    FOR             reduce using rule 34 (stmt -> for_stmt .)
    IDENT           reduce using rule 34 (stmt -> for_stmt .)
    SUPER           reduce using rule 34 (stmt -> for_stmt .)
    CONTINUE        reduce using rule 34 (stmt -> for_stmt .)
    BREAK           reduce using rule 34 (stmt -> for_stmt .)
    WHILE           reduce using rule 34 (stmt -> for_stmt .)
    RETURN          reduce using rule 34 (stmt -> for_stmt .)
    IF              reduce using rule 34 (stmt -> for_stmt .)
    {               reduce using rule 34 (stmt -> for_stmt .)
    (               reduce using rule 34 (stmt -> for_stmt .)
    NOT             reduce using rule 34 (stmt -> for_stmt .)
    !               reduce using rule 34 (stmt -> for_stmt .)
    -               reduce using rule 34 (stmt -> for_stmt .)
    +               reduce using rule 34 (stmt -> for_stmt .)
    DECREMENT       reduce using rule 34 (stmt -> for_stmt .)
    INCREMENT       reduce using rule 34 (stmt -> for_stmt .)
    FALSE           reduce using rule 34 (stmt -> for_stmt .)
    TRUE            reduce using rule 34 (stmt -> for_stmt .)
    STRINGLIT       reduce using rule 34 (stmt -> for_stmt .)
    BOOLIT          reduce using rule 34 (stmt -> for_stmt .)
    FLOATLIT        reduce using rule 34 (stmt -> for_stmt .)
    INTLIT          reduce using rule 34 (stmt -> for_stmt .)
    NULL            reduce using rule 34 (stmt -> for_stmt .)
    ELSE            reduce using rule 34 (stmt -> for_stmt .)


state 172

    (35) stmt -> object_decl .
    }               reduce using rule 35 (stmt -> object_decl .)
    STRING          reduce using rule 35 (stmt -> object_decl .)
    BOOL            reduce using rule 35 (stmt -> object_decl .)
    FLOAT           reduce using rule 35 (stmt -> object_decl .)
    INT             reduce using rule 35 (stmt -> object_decl .)
    VOID            reduce using rule 35 (stmt -> object_decl .)
    SPRINTF         reduce using rule 35 (stmt -> object_decl .)
    PRINTF          reduce using rule 35 (stmt -> object_decl .)
    THIS            reduce using rule 35 (stmt -> object_decl .)
    FOR             reduce using rule 35 (stmt -> object_decl .)
    IDENT           reduce using rule 35 (stmt -> object_decl .)
    SUPER           reduce using rule 35 (stmt -> object_decl .)
    CONTINUE        reduce using rule 35 (stmt -> object_decl .)
    BREAK           reduce using rule 35 (stmt -> object_decl .)
    WHILE           reduce using rule 35 (stmt -> object_decl .)
    RETURN          reduce using rule 35 (stmt -> object_decl .)
    IF              reduce using rule 35 (stmt -> object_decl .)
    {               reduce using rule 35 (stmt -> object_decl .)
    (               reduce using rule 35 (stmt -> object_decl .)
    NOT             reduce using rule 35 (stmt -> object_decl .)
    !               reduce using rule 35 (stmt -> object_decl .)
    -               reduce using rule 35 (stmt -> object_decl .)
    +               reduce using rule 35 (stmt -> object_decl .)
    DECREMENT       reduce using rule 35 (stmt -> object_decl .)
    INCREMENT       reduce using rule 35 (stmt -> object_decl .)
    FALSE           reduce using rule 35 (stmt -> object_decl .)
    TRUE            reduce using rule 35 (stmt -> object_decl .)
    STRINGLIT       reduce using rule 35 (stmt -> object_decl .)
    BOOLIT          reduce using rule 35 (stmt -> object_decl .)
    FLOATLIT        reduce using rule 35 (stmt -> object_decl .)
    INTLIT          reduce using rule 35 (stmt -> object_decl .)
    NULL            reduce using rule 35 (stmt -> object_decl .)
    ELSE            reduce using rule 35 (stmt -> object_decl .)


state 173

    (36) stmt -> super_stmt .
    }               reduce using rule 36 (stmt -> super_stmt .)
    STRING          reduce using rule 36 (stmt -> super_stmt .)
    BOOL            reduce using rule 36 (stmt -> super_stmt .)
    FLOAT           reduce using rule 36 (stmt -> super_stmt .)
    INT             reduce using rule 36 (stmt -> super_stmt .)
    VOID            reduce using rule 36 (stmt -> super_stmt .)
    SPRINTF         reduce using rule 36 (stmt -> super_stmt .)
    PRINTF          reduce using rule 36 (stmt -> super_stmt .)
    THIS            reduce using rule 36 (stmt -> super_stmt .)
    FOR             reduce using rule 36 (stmt -> super_stmt .)
    IDENT           reduce using rule 36 (stmt -> super_stmt .)
    SUPER           reduce using rule 36 (stmt -> super_stmt .)
    CONTINUE        reduce using rule 36 (stmt -> super_stmt .)
    BREAK           reduce using rule 36 (stmt -> super_stmt .)
    WHILE           reduce using rule 36 (stmt -> super_stmt .)
    RETURN          reduce using rule 36 (stmt -> super_stmt .)
    IF              reduce using rule 36 (stmt -> super_stmt .)
    {               reduce using rule 36 (stmt -> super_stmt .)
    (               reduce using rule 36 (stmt -> super_stmt .)
    NOT             reduce using rule 36 (stmt -> super_stmt .)
    !               reduce using rule 36 (stmt -> super_stmt .)
    -               reduce using rule 36 (stmt -> super_stmt .)
    +               reduce using rule 36 (stmt -> super_stmt .)
    DECREMENT       reduce using rule 36 (stmt -> super_stmt .)
    INCREMENT       reduce using rule 36 (stmt -> super_stmt .)
    FALSE           reduce using rule 36 (stmt -> super_stmt .)
    TRUE            reduce using rule 36 (stmt -> super_stmt .)
    STRINGLIT       reduce using rule 36 (stmt -> super_stmt .)
    BOOLIT          reduce using rule 36 (stmt -> super_stmt .)
    FLOATLIT        reduce using rule 36 (stmt -> super_stmt .)
    INTLIT          reduce using rule 36 (stmt -> super_stmt .)
    NULL            reduce using rule 36 (stmt -> super_stmt .)
    ELSE            reduce using rule 36 (stmt -> super_stmt .)


state 174

    (37) stmt -> continue_stmt .
    }               reduce using rule 37 (stmt -> continue_stmt .)
    STRING          reduce using rule 37 (stmt -> continue_stmt .)
    BOOL            reduce using rule 37 (stmt -> continue_stmt .)
    FLOAT           reduce using rule 37 (stmt -> continue_stmt .)
    INT             reduce using rule 37 (stmt -> continue_stmt .)
    VOID            reduce using rule 37 (stmt -> continue_stmt .)
    SPRINTF         reduce using rule 37 (stmt -> continue_stmt .)
    PRINTF          reduce using rule 37 (stmt -> continue_stmt .)
    THIS            reduce using rule 37 (stmt -> continue_stmt .)
    FOR             reduce using rule 37 (stmt -> continue_stmt .)
    IDENT           reduce using rule 37 (stmt -> continue_stmt .)
    SUPER           reduce using rule 37 (stmt -> continue_stmt .)
    CONTINUE        reduce using rule 37 (stmt -> continue_stmt .)
    BREAK           reduce using rule 37 (stmt -> continue_stmt .)
    WHILE           reduce using rule 37 (stmt -> continue_stmt .)
    RETURN          reduce using rule 37 (stmt -> continue_stmt .)
    IF              reduce using rule 37 (stmt -> continue_stmt .)
    {               reduce using rule 37 (stmt -> continue_stmt .)
    (               reduce using rule 37 (stmt -> continue_stmt .)
    NOT             reduce using rule 37 (stmt -> continue_stmt .)
    !               reduce using rule 37 (stmt -> continue_stmt .)
    -               reduce using rule 37 (stmt -> continue_stmt .)
    +               reduce using rule 37 (stmt -> continue_stmt .)
    DECREMENT       reduce using rule 37 (stmt -> continue_stmt .)
    INCREMENT       reduce using rule 37 (stmt -> continue_stmt .)
    FALSE           reduce using rule 37 (stmt -> continue_stmt .)
    TRUE            reduce using rule 37 (stmt -> continue_stmt .)
    STRINGLIT       reduce using rule 37 (stmt -> continue_stmt .)
    BOOLIT          reduce using rule 37 (stmt -> continue_stmt .)
    FLOATLIT        reduce using rule 37 (stmt -> continue_stmt .)
    INTLIT          reduce using rule 37 (stmt -> continue_stmt .)
    NULL            reduce using rule 37 (stmt -> continue_stmt .)
    ELSE            reduce using rule 37 (stmt -> continue_stmt .)


state 175

    (38) stmt -> break_stmt .
    }               reduce using rule 38 (stmt -> break_stmt .)
    STRING          reduce using rule 38 (stmt -> break_stmt .)
    BOOL            reduce using rule 38 (stmt -> break_stmt .)
    FLOAT           reduce using rule 38 (stmt -> break_stmt .)
    INT             reduce using rule 38 (stmt -> break_stmt .)
    VOID            reduce using rule 38 (stmt -> break_stmt .)
    SPRINTF         reduce using rule 38 (stmt -> break_stmt .)
    PRINTF          reduce using rule 38 (stmt -> break_stmt .)
    THIS            reduce using rule 38 (stmt -> break_stmt .)
    FOR             reduce using rule 38 (stmt -> break_stmt .)
    IDENT           reduce using rule 38 (stmt -> break_stmt .)
    SUPER           reduce using rule 38 (stmt -> break_stmt .)
    CONTINUE        reduce using rule 38 (stmt -> break_stmt .)
    BREAK           reduce using rule 38 (stmt -> break_stmt .)
    WHILE           reduce using rule 38 (stmt -> break_stmt .)
    RETURN          reduce using rule 38 (stmt -> break_stmt .)
    IF              reduce using rule 38 (stmt -> break_stmt .)
    {               reduce using rule 38 (stmt -> break_stmt .)
    (               reduce using rule 38 (stmt -> break_stmt .)
    NOT             reduce using rule 38 (stmt -> break_stmt .)
    !               reduce using rule 38 (stmt -> break_stmt .)
    -               reduce using rule 38 (stmt -> break_stmt .)
    +               reduce using rule 38 (stmt -> break_stmt .)
    DECREMENT       reduce using rule 38 (stmt -> break_stmt .)
    INCREMENT       reduce using rule 38 (stmt -> break_stmt .)
    FALSE           reduce using rule 38 (stmt -> break_stmt .)
    TRUE            reduce using rule 38 (stmt -> break_stmt .)
    STRINGLIT       reduce using rule 38 (stmt -> break_stmt .)
    BOOLIT          reduce using rule 38 (stmt -> break_stmt .)
    FLOATLIT        reduce using rule 38 (stmt -> break_stmt .)
    INTLIT          reduce using rule 38 (stmt -> break_stmt .)
    NULL            reduce using rule 38 (stmt -> break_stmt .)
    ELSE            reduce using rule 38 (stmt -> break_stmt .)


state 176

    (39) stmt -> while_stmt .
    }               reduce using rule 39 (stmt -> while_stmt .)
    STRING          reduce using rule 39 (stmt -> while_stmt .)
    BOOL            reduce using rule 39 (stmt -> while_stmt .)
    FLOAT           reduce using rule 39 (stmt -> while_stmt .)
    INT             reduce using rule 39 (stmt -> while_stmt .)
    VOID            reduce using rule 39 (stmt -> while_stmt .)
    SPRINTF         reduce using rule 39 (stmt -> while_stmt .)
    PRINTF          reduce using rule 39 (stmt -> while_stmt .)
    THIS            reduce using rule 39 (stmt -> while_stmt .)
    FOR             reduce using rule 39 (stmt -> while_stmt .)
    IDENT           reduce using rule 39 (stmt -> while_stmt .)
    SUPER           reduce using rule 39 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 39 (stmt -> while_stmt .)
    BREAK           reduce using rule 39 (stmt -> while_stmt .)
    WHILE           reduce using rule 39 (stmt -> while_stmt .)
    RETURN          reduce using rule 39 (stmt -> while_stmt .)
    IF              reduce using rule 39 (stmt -> while_stmt .)
    {               reduce using rule 39 (stmt -> while_stmt .)
    (               reduce using rule 39 (stmt -> while_stmt .)
    NOT             reduce using rule 39 (stmt -> while_stmt .)
    !               reduce using rule 39 (stmt -> while_stmt .)
    -               reduce using rule 39 (stmt -> while_stmt .)
    +               reduce using rule 39 (stmt -> while_stmt .)
    DECREMENT       reduce using rule 39 (stmt -> while_stmt .)
    INCREMENT       reduce using rule 39 (stmt -> while_stmt .)
    FALSE           reduce using rule 39 (stmt -> while_stmt .)
    TRUE            reduce using rule 39 (stmt -> while_stmt .)
    STRINGLIT       reduce using rule 39 (stmt -> while_stmt .)
    BOOLIT          reduce using rule 39 (stmt -> while_stmt .)
    FLOATLIT        reduce using rule 39 (stmt -> while_stmt .)
    INTLIT          reduce using rule 39 (stmt -> while_stmt .)
    NULL            reduce using rule 39 (stmt -> while_stmt .)
    ELSE            reduce using rule 39 (stmt -> while_stmt .)


state 177

    (40) stmt -> return_stmt .
    }               reduce using rule 40 (stmt -> return_stmt .)
    STRING          reduce using rule 40 (stmt -> return_stmt .)
    BOOL            reduce using rule 40 (stmt -> return_stmt .)
    FLOAT           reduce using rule 40 (stmt -> return_stmt .)
    INT             reduce using rule 40 (stmt -> return_stmt .)
    VOID            reduce using rule 40 (stmt -> return_stmt .)
    SPRINTF         reduce using rule 40 (stmt -> return_stmt .)
    PRINTF          reduce using rule 40 (stmt -> return_stmt .)
    THIS            reduce using rule 40 (stmt -> return_stmt .)
    FOR             reduce using rule 40 (stmt -> return_stmt .)
    IDENT           reduce using rule 40 (stmt -> return_stmt .)
    SUPER           reduce using rule 40 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 40 (stmt -> return_stmt .)
    BREAK           reduce using rule 40 (stmt -> return_stmt .)
    WHILE           reduce using rule 40 (stmt -> return_stmt .)
    RETURN          reduce using rule 40 (stmt -> return_stmt .)
    IF              reduce using rule 40 (stmt -> return_stmt .)
    {               reduce using rule 40 (stmt -> return_stmt .)
    (               reduce using rule 40 (stmt -> return_stmt .)
    NOT             reduce using rule 40 (stmt -> return_stmt .)
    !               reduce using rule 40 (stmt -> return_stmt .)
    -               reduce using rule 40 (stmt -> return_stmt .)
    +               reduce using rule 40 (stmt -> return_stmt .)
    DECREMENT       reduce using rule 40 (stmt -> return_stmt .)
    INCREMENT       reduce using rule 40 (stmt -> return_stmt .)
    FALSE           reduce using rule 40 (stmt -> return_stmt .)
    TRUE            reduce using rule 40 (stmt -> return_stmt .)
    STRINGLIT       reduce using rule 40 (stmt -> return_stmt .)
    BOOLIT          reduce using rule 40 (stmt -> return_stmt .)
    FLOATLIT        reduce using rule 40 (stmt -> return_stmt .)
    INTLIT          reduce using rule 40 (stmt -> return_stmt .)
    NULL            reduce using rule 40 (stmt -> return_stmt .)
    ELSE            reduce using rule 40 (stmt -> return_stmt .)


state 178

    (41) stmt -> if_stmt .
    }               reduce using rule 41 (stmt -> if_stmt .)
    STRING          reduce using rule 41 (stmt -> if_stmt .)
    BOOL            reduce using rule 41 (stmt -> if_stmt .)
    FLOAT           reduce using rule 41 (stmt -> if_stmt .)
    INT             reduce using rule 41 (stmt -> if_stmt .)
    VOID            reduce using rule 41 (stmt -> if_stmt .)
    SPRINTF         reduce using rule 41 (stmt -> if_stmt .)
    PRINTF          reduce using rule 41 (stmt -> if_stmt .)
    THIS            reduce using rule 41 (stmt -> if_stmt .)
    FOR             reduce using rule 41 (stmt -> if_stmt .)
    IDENT           reduce using rule 41 (stmt -> if_stmt .)
    SUPER           reduce using rule 41 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 41 (stmt -> if_stmt .)
    BREAK           reduce using rule 41 (stmt -> if_stmt .)
    WHILE           reduce using rule 41 (stmt -> if_stmt .)
    RETURN          reduce using rule 41 (stmt -> if_stmt .)
    IF              reduce using rule 41 (stmt -> if_stmt .)
    {               reduce using rule 41 (stmt -> if_stmt .)
    (               reduce using rule 41 (stmt -> if_stmt .)
    NOT             reduce using rule 41 (stmt -> if_stmt .)
    !               reduce using rule 41 (stmt -> if_stmt .)
    -               reduce using rule 41 (stmt -> if_stmt .)
    +               reduce using rule 41 (stmt -> if_stmt .)
    DECREMENT       reduce using rule 41 (stmt -> if_stmt .)
    INCREMENT       reduce using rule 41 (stmt -> if_stmt .)
    FALSE           reduce using rule 41 (stmt -> if_stmt .)
    TRUE            reduce using rule 41 (stmt -> if_stmt .)
    STRINGLIT       reduce using rule 41 (stmt -> if_stmt .)
    BOOLIT          reduce using rule 41 (stmt -> if_stmt .)
    FLOATLIT        reduce using rule 41 (stmt -> if_stmt .)
    INTLIT          reduce using rule 41 (stmt -> if_stmt .)
    NULL            reduce using rule 41 (stmt -> if_stmt .)
    ELSE            reduce using rule 41 (stmt -> if_stmt .)


state 179

    (42) stmt -> compound_stmt .
    }               reduce using rule 42 (stmt -> compound_stmt .)
    STRING          reduce using rule 42 (stmt -> compound_stmt .)
    BOOL            reduce using rule 42 (stmt -> compound_stmt .)
    FLOAT           reduce using rule 42 (stmt -> compound_stmt .)
    INT             reduce using rule 42 (stmt -> compound_stmt .)
    VOID            reduce using rule 42 (stmt -> compound_stmt .)
    SPRINTF         reduce using rule 42 (stmt -> compound_stmt .)
    PRINTF          reduce using rule 42 (stmt -> compound_stmt .)
    THIS            reduce using rule 42 (stmt -> compound_stmt .)
    FOR             reduce using rule 42 (stmt -> compound_stmt .)
    IDENT           reduce using rule 42 (stmt -> compound_stmt .)
    SUPER           reduce using rule 42 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 42 (stmt -> compound_stmt .)
    BREAK           reduce using rule 42 (stmt -> compound_stmt .)
    WHILE           reduce using rule 42 (stmt -> compound_stmt .)
    RETURN          reduce using rule 42 (stmt -> compound_stmt .)
    IF              reduce using rule 42 (stmt -> compound_stmt .)
    {               reduce using rule 42 (stmt -> compound_stmt .)
    (               reduce using rule 42 (stmt -> compound_stmt .)
    NOT             reduce using rule 42 (stmt -> compound_stmt .)
    !               reduce using rule 42 (stmt -> compound_stmt .)
    -               reduce using rule 42 (stmt -> compound_stmt .)
    +               reduce using rule 42 (stmt -> compound_stmt .)
    DECREMENT       reduce using rule 42 (stmt -> compound_stmt .)
    INCREMENT       reduce using rule 42 (stmt -> compound_stmt .)
    FALSE           reduce using rule 42 (stmt -> compound_stmt .)
    TRUE            reduce using rule 42 (stmt -> compound_stmt .)
    STRINGLIT       reduce using rule 42 (stmt -> compound_stmt .)
    BOOLIT          reduce using rule 42 (stmt -> compound_stmt .)
    FLOATLIT        reduce using rule 42 (stmt -> compound_stmt .)
    INTLIT          reduce using rule 42 (stmt -> compound_stmt .)
    NULL            reduce using rule 42 (stmt -> compound_stmt .)
    ELSE            reduce using rule 42 (stmt -> compound_stmt .)


state 180

    (43) stmt -> expr_stmt .
    }               reduce using rule 43 (stmt -> expr_stmt .)
    STRING          reduce using rule 43 (stmt -> expr_stmt .)
    BOOL            reduce using rule 43 (stmt -> expr_stmt .)
    FLOAT           reduce using rule 43 (stmt -> expr_stmt .)
    INT             reduce using rule 43 (stmt -> expr_stmt .)
    VOID            reduce using rule 43 (stmt -> expr_stmt .)
    SPRINTF         reduce using rule 43 (stmt -> expr_stmt .)
    PRINTF          reduce using rule 43 (stmt -> expr_stmt .)
    THIS            reduce using rule 43 (stmt -> expr_stmt .)
    FOR             reduce using rule 43 (stmt -> expr_stmt .)
    IDENT           reduce using rule 43 (stmt -> expr_stmt .)
    SUPER           reduce using rule 43 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 43 (stmt -> expr_stmt .)
    BREAK           reduce using rule 43 (stmt -> expr_stmt .)
    WHILE           reduce using rule 43 (stmt -> expr_stmt .)
    RETURN          reduce using rule 43 (stmt -> expr_stmt .)
    IF              reduce using rule 43 (stmt -> expr_stmt .)
    {               reduce using rule 43 (stmt -> expr_stmt .)
    (               reduce using rule 43 (stmt -> expr_stmt .)
    NOT             reduce using rule 43 (stmt -> expr_stmt .)
    !               reduce using rule 43 (stmt -> expr_stmt .)
    -               reduce using rule 43 (stmt -> expr_stmt .)
    +               reduce using rule 43 (stmt -> expr_stmt .)
    DECREMENT       reduce using rule 43 (stmt -> expr_stmt .)
    INCREMENT       reduce using rule 43 (stmt -> expr_stmt .)
    FALSE           reduce using rule 43 (stmt -> expr_stmt .)
    TRUE            reduce using rule 43 (stmt -> expr_stmt .)
    STRINGLIT       reduce using rule 43 (stmt -> expr_stmt .)
    BOOLIT          reduce using rule 43 (stmt -> expr_stmt .)
    FLOATLIT        reduce using rule 43 (stmt -> expr_stmt .)
    INTLIT          reduce using rule 43 (stmt -> expr_stmt .)
    NULL            reduce using rule 43 (stmt -> expr_stmt .)
    ELSE            reduce using rule 43 (stmt -> expr_stmt .)


state 181

    (46) sprintf_stmt -> SPRINTF . ( expr , STRINGLIT ) ;
    (47) sprintf_stmt -> SPRINTF . ( expr , STRINGLIT , args_list ) ;
    (               shift and go to state 206


state 182

    (44) printf_stmt -> PRINTF . ( STRINGLIT ) ;
    (45) printf_stmt -> PRINTF . ( STRINGLIT , args_list ) ;
    (               shift and go to state 207


state 183

    (91) this_stmt -> THIS . ;
    ;               shift and go to state 208


state 184

    (48) for_stmt -> FOR . ( for_init ; for_cond ; for_incr ) compound_stmt
    (               shift and go to state 209


state 185

    (59) super_stmt -> SUPER . ( args_list ) ;
    (               shift and go to state 210


state 186

    (87) continue_stmt -> CONTINUE . ;
    ;               shift and go to state 211


state 187

    (86) break_stmt -> BREAK . ;
    ;               shift and go to state 212


state 188

    (85) while_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 213


state 189

    (83) return_stmt -> RETURN . expr ;
    (84) return_stmt -> RETURN . ;
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    ;               shift and go to state 215
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 214
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 190

    (81) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (82) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 216


state 191

    (71) primary_expr -> IDENT . IDENT ( . args_list )
    (88) args_list -> . expr
    (89) args_list -> . args_list , expr
    (90) args_list -> . empty
    (102) expr -> . logical_or_expr
    (133) empty -> .
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    )               reduce using rule 133 (empty -> .)
    ,               reduce using rule 133 (empty -> .)
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    args_list                      shift and go to state 217
    expr                           shift and go to state 132
    empty                          shift and go to state 133
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 192

    (70) primary_expr -> IDENT [ expr ] .
    DECREMENT       reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    INCREMENT       reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    %               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    /               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    *               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    -               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    +               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    GE              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    GT              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    LE              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    LT              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    NE              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    EQ              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    AND             reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    OR              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    ]               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    ;               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    )               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    ,               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)


state 193

    (72) primary_expr -> IDENT ( args_list ) .
    DECREMENT       reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    INCREMENT       reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    %               reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    /               reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    *               reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    -               reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    +               reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    GE              reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    GT              reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    LE              reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    LT              reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    NE              reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    EQ              reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    AND             reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    OR              reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    ]               reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    ;               reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    )               reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)
    ,               reduce using rule 72 (primary_expr -> IDENT ( args_list ) .)


state 194

    (89) args_list -> args_list , . expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 218
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 195

    (122) unary_expr -> ( type_spec ) unary_expr .
    %               reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    /               reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    *               reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    -               reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    +               reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    GE              reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    GT              reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    LE              reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    LT              reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    NE              reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    EQ              reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    AND             reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    OR              reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    ]               reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    ;               reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    )               reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)
    ,               reduce using rule 122 (unary_expr -> ( type_spec ) unary_expr .)


state 196

    (61) assignment_expr -> IDENT [ expr ] . = assignment_expr
    (70) primary_expr -> IDENT [ expr ] .
    =               shift and go to state 219
    DECREMENT       reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    INCREMENT       reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    %               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    /               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    *               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    -               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    +               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    GE              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    GT              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    LE              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    LT              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    NE              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    EQ              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    AND             reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    OR              reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    ;               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)
    )               reduce using rule 70 (primary_expr -> IDENT [ expr ] .)


state 197

    (95) object_decl -> IDENT IDENT = NEW IDENT ( args_list ) . ;
    ;               shift and go to state 220


state 198

    (8) class_decl -> CLASS IDENT : IDENT { class_body } ; .
    IDENT           reduce using rule 8 (class_decl -> CLASS IDENT : IDENT { class_body } ; .)
    CLASS           reduce using rule 8 (class_decl -> CLASS IDENT : IDENT { class_body } ; .)
    STRING          reduce using rule 8 (class_decl -> CLASS IDENT : IDENT { class_body } ; .)
    BOOL            reduce using rule 8 (class_decl -> CLASS IDENT : IDENT { class_body } ; .)
    FLOAT           reduce using rule 8 (class_decl -> CLASS IDENT : IDENT { class_body } ; .)
    INT             reduce using rule 8 (class_decl -> CLASS IDENT : IDENT { class_body } ; .)
    VOID            reduce using rule 8 (class_decl -> CLASS IDENT : IDENT { class_body } ; .)
    $end            reduce using rule 8 (class_decl -> CLASS IDENT : IDENT { class_body } ; .)


state 199

    (19) constructor_decl -> IDENT ( param_list ) compound_stmt .
    PUBLIC          reduce using rule 19 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    PRIVATE         reduce using rule 19 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    IDENT           reduce using rule 19 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    STRING          reduce using rule 19 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    BOOL            reduce using rule 19 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    FLOAT           reduce using rule 19 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    INT             reduce using rule 19 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    VOID            reduce using rule 19 (constructor_decl -> IDENT ( param_list ) compound_stmt .)
    }               reduce using rule 19 (constructor_decl -> IDENT ( param_list ) compound_stmt .)


state 200

    (18) method_decl -> type_spec IDENT ( param_list ) . compound_stmt
    (26) compound_stmt -> . { block_items }
    {               shift and go to state 126

    compound_stmt                  shift and go to state 221

state 201

    (24) param -> type_spec IDENT [ INTLIT ] .
    )               reduce using rule 24 (param -> type_spec IDENT [ INTLIT ] .)
    ,               reduce using rule 24 (param -> type_spec IDENT [ INTLIT ] .)


state 202

    (26) compound_stmt -> { block_items } .
    IDENT           reduce using rule 26 (compound_stmt -> { block_items } .)
    CLASS           reduce using rule 26 (compound_stmt -> { block_items } .)
    STRING          reduce using rule 26 (compound_stmt -> { block_items } .)
    BOOL            reduce using rule 26 (compound_stmt -> { block_items } .)
    FLOAT           reduce using rule 26 (compound_stmt -> { block_items } .)
    INT             reduce using rule 26 (compound_stmt -> { block_items } .)
    VOID            reduce using rule 26 (compound_stmt -> { block_items } .)
    $end            reduce using rule 26 (compound_stmt -> { block_items } .)
    }               reduce using rule 26 (compound_stmt -> { block_items } .)
    SPRINTF         reduce using rule 26 (compound_stmt -> { block_items } .)
    PRINTF          reduce using rule 26 (compound_stmt -> { block_items } .)
    THIS            reduce using rule 26 (compound_stmt -> { block_items } .)
    FOR             reduce using rule 26 (compound_stmt -> { block_items } .)
    SUPER           reduce using rule 26 (compound_stmt -> { block_items } .)
    CONTINUE        reduce using rule 26 (compound_stmt -> { block_items } .)
    BREAK           reduce using rule 26 (compound_stmt -> { block_items } .)
    WHILE           reduce using rule 26 (compound_stmt -> { block_items } .)
    RETURN          reduce using rule 26 (compound_stmt -> { block_items } .)
    IF              reduce using rule 26 (compound_stmt -> { block_items } .)
    {               reduce using rule 26 (compound_stmt -> { block_items } .)
    (               reduce using rule 26 (compound_stmt -> { block_items } .)
    NOT             reduce using rule 26 (compound_stmt -> { block_items } .)
    !               reduce using rule 26 (compound_stmt -> { block_items } .)
    -               reduce using rule 26 (compound_stmt -> { block_items } .)
    +               reduce using rule 26 (compound_stmt -> { block_items } .)
    DECREMENT       reduce using rule 26 (compound_stmt -> { block_items } .)
    INCREMENT       reduce using rule 26 (compound_stmt -> { block_items } .)
    FALSE           reduce using rule 26 (compound_stmt -> { block_items } .)
    TRUE            reduce using rule 26 (compound_stmt -> { block_items } .)
    STRINGLIT       reduce using rule 26 (compound_stmt -> { block_items } .)
    BOOLIT          reduce using rule 26 (compound_stmt -> { block_items } .)
    FLOATLIT        reduce using rule 26 (compound_stmt -> { block_items } .)
    INTLIT          reduce using rule 26 (compound_stmt -> { block_items } .)
    NULL            reduce using rule 26 (compound_stmt -> { block_items } .)
    PUBLIC          reduce using rule 26 (compound_stmt -> { block_items } .)
    PRIVATE         reduce using rule 26 (compound_stmt -> { block_items } .)
    ELSE            reduce using rule 26 (compound_stmt -> { block_items } .)


state 203

    (28) block_items -> block_items block_item .
    }               reduce using rule 28 (block_items -> block_items block_item .)
    STRING          reduce using rule 28 (block_items -> block_items block_item .)
    BOOL            reduce using rule 28 (block_items -> block_items block_item .)
    FLOAT           reduce using rule 28 (block_items -> block_items block_item .)
    INT             reduce using rule 28 (block_items -> block_items block_item .)
    VOID            reduce using rule 28 (block_items -> block_items block_item .)
    SPRINTF         reduce using rule 28 (block_items -> block_items block_item .)
    PRINTF          reduce using rule 28 (block_items -> block_items block_item .)
    THIS            reduce using rule 28 (block_items -> block_items block_item .)
    FOR             reduce using rule 28 (block_items -> block_items block_item .)
    IDENT           reduce using rule 28 (block_items -> block_items block_item .)
    SUPER           reduce using rule 28 (block_items -> block_items block_item .)
    CONTINUE        reduce using rule 28 (block_items -> block_items block_item .)
    BREAK           reduce using rule 28 (block_items -> block_items block_item .)
    WHILE           reduce using rule 28 (block_items -> block_items block_item .)
    RETURN          reduce using rule 28 (block_items -> block_items block_item .)
    IF              reduce using rule 28 (block_items -> block_items block_item .)
    {               reduce using rule 28 (block_items -> block_items block_item .)
    (               reduce using rule 28 (block_items -> block_items block_item .)
    NOT             reduce using rule 28 (block_items -> block_items block_item .)
    !               reduce using rule 28 (block_items -> block_items block_item .)
    -               reduce using rule 28 (block_items -> block_items block_item .)
    +               reduce using rule 28 (block_items -> block_items block_item .)
    DECREMENT       reduce using rule 28 (block_items -> block_items block_item .)
    INCREMENT       reduce using rule 28 (block_items -> block_items block_item .)
    FALSE           reduce using rule 28 (block_items -> block_items block_item .)
    TRUE            reduce using rule 28 (block_items -> block_items block_item .)
    STRINGLIT       reduce using rule 28 (block_items -> block_items block_item .)
    BOOLIT          reduce using rule 28 (block_items -> block_items block_item .)
    FLOATLIT        reduce using rule 28 (block_items -> block_items block_item .)
    INTLIT          reduce using rule 28 (block_items -> block_items block_item .)
    NULL            reduce using rule 28 (block_items -> block_items block_item .)


state 204

    (92) var_decl -> type_spec IDENT . [ expr ] ;
    (93) var_decl -> type_spec IDENT . = assignment_expr ;
    (94) var_decl -> type_spec IDENT . ;
    [               shift and go to state 25
    =               shift and go to state 27
    ;               shift and go to state 26


state 205

    (60) expr_stmt -> assignment_expr ; .
    }               reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    STRING          reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    BOOL            reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    FLOAT           reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    INT             reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    VOID            reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    SPRINTF         reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    PRINTF          reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    THIS            reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    FOR             reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    IDENT           reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    SUPER           reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    CONTINUE        reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    BREAK           reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    WHILE           reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    RETURN          reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    IF              reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    {               reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    (               reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    NOT             reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    !               reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    -               reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    +               reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    DECREMENT       reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    INCREMENT       reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    FALSE           reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    TRUE            reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    STRINGLIT       reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    BOOLIT          reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    FLOATLIT        reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    INTLIT          reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    NULL            reduce using rule 60 (expr_stmt -> assignment_expr ; .)
    ELSE            reduce using rule 60 (expr_stmt -> assignment_expr ; .)


state 206

    (46) sprintf_stmt -> SPRINTF ( . expr , STRINGLIT ) ;
    (47) sprintf_stmt -> SPRINTF ( . expr , STRINGLIT , args_list ) ;
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 222
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 207

    (44) printf_stmt -> PRINTF ( . STRINGLIT ) ;
    (45) printf_stmt -> PRINTF ( . STRINGLIT , args_list ) ;
    STRINGLIT       shift and go to state 223


state 208

    (91) this_stmt -> THIS ; .
    }               reduce using rule 91 (this_stmt -> THIS ; .)
    STRING          reduce using rule 91 (this_stmt -> THIS ; .)
    BOOL            reduce using rule 91 (this_stmt -> THIS ; .)
    FLOAT           reduce using rule 91 (this_stmt -> THIS ; .)
    INT             reduce using rule 91 (this_stmt -> THIS ; .)
    VOID            reduce using rule 91 (this_stmt -> THIS ; .)
    SPRINTF         reduce using rule 91 (this_stmt -> THIS ; .)
    PRINTF          reduce using rule 91 (this_stmt -> THIS ; .)
    THIS            reduce using rule 91 (this_stmt -> THIS ; .)
    FOR             reduce using rule 91 (this_stmt -> THIS ; .)
    IDENT           reduce using rule 91 (this_stmt -> THIS ; .)
    SUPER           reduce using rule 91 (this_stmt -> THIS ; .)
    CONTINUE        reduce using rule 91 (this_stmt -> THIS ; .)
    BREAK           reduce using rule 91 (this_stmt -> THIS ; .)
    WHILE           reduce using rule 91 (this_stmt -> THIS ; .)
    RETURN          reduce using rule 91 (this_stmt -> THIS ; .)
    IF              reduce using rule 91 (this_stmt -> THIS ; .)
    {               reduce using rule 91 (this_stmt -> THIS ; .)
    (               reduce using rule 91 (this_stmt -> THIS ; .)
    NOT             reduce using rule 91 (this_stmt -> THIS ; .)
    !               reduce using rule 91 (this_stmt -> THIS ; .)
    -               reduce using rule 91 (this_stmt -> THIS ; .)
    +               reduce using rule 91 (this_stmt -> THIS ; .)
    DECREMENT       reduce using rule 91 (this_stmt -> THIS ; .)
    INCREMENT       reduce using rule 91 (this_stmt -> THIS ; .)
    FALSE           reduce using rule 91 (this_stmt -> THIS ; .)
    TRUE            reduce using rule 91 (this_stmt -> THIS ; .)
    STRINGLIT       reduce using rule 91 (this_stmt -> THIS ; .)
    BOOLIT          reduce using rule 91 (this_stmt -> THIS ; .)
    FLOATLIT        reduce using rule 91 (this_stmt -> THIS ; .)
    INTLIT          reduce using rule 91 (this_stmt -> THIS ; .)
    NULL            reduce using rule 91 (this_stmt -> THIS ; .)
    ELSE            reduce using rule 91 (this_stmt -> THIS ; .)


state 209

    (48) for_stmt -> FOR ( . for_init ; for_cond ; for_incr ) compound_stmt
    (49) for_init -> . empty
    (50) for_init -> . assignment_expr
    (51) for_init -> . var_decl_no_semi
    (133) empty -> .
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (52) var_decl_no_semi -> . type_spec IDENT [ expr ]
    (53) var_decl_no_semi -> . type_spec IDENT = assignment_expr
    (54) var_decl_no_semi -> . type_spec IDENT
    (102) expr -> . logical_or_expr
    (97) type_spec -> . STRING
    (98) type_spec -> . BOOL
    (99) type_spec -> . FLOAT
    (100) type_spec -> . INT
    (101) type_spec -> . VOID
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    ;               reduce using rule 133 (empty -> .)
    IDENT           shift and go to state 70
    STRING          shift and go to state 11
    BOOL            shift and go to state 12
    FLOAT           shift and go to state 13
    INT             shift and go to state 14
    VOID            shift and go to state 15
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    for_init                       shift and go to state 224
    empty                          shift and go to state 225
    assignment_expr                shift and go to state 226
    var_decl_no_semi               shift and go to state 227
    expr                           shift and go to state 72
    type_spec                      shift and go to state 228
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 210

    (59) super_stmt -> SUPER ( . args_list ) ;
    (88) args_list -> . expr
    (89) args_list -> . args_list , expr
    (90) args_list -> . empty
    (102) expr -> . logical_or_expr
    (133) empty -> .
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    )               reduce using rule 133 (empty -> .)
    ,               reduce using rule 133 (empty -> .)
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    args_list                      shift and go to state 229
    expr                           shift and go to state 132
    empty                          shift and go to state 133
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 211

    (87) continue_stmt -> CONTINUE ; .
    }               reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    STRING          reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    BOOL            reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    FLOAT           reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    INT             reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    VOID            reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    SPRINTF         reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    PRINTF          reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    THIS            reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    FOR             reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    IDENT           reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    SUPER           reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    IF              reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    {               reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    (               reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    NOT             reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    !               reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    -               reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    +               reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    DECREMENT       reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    INCREMENT       reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    FALSE           reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    TRUE            reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    STRINGLIT       reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    BOOLIT          reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    FLOATLIT        reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    INTLIT          reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    NULL            reduce using rule 87 (continue_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 87 (continue_stmt -> CONTINUE ; .)


state 212

    (86) break_stmt -> BREAK ; .
    }               reduce using rule 86 (break_stmt -> BREAK ; .)
    STRING          reduce using rule 86 (break_stmt -> BREAK ; .)
    BOOL            reduce using rule 86 (break_stmt -> BREAK ; .)
    FLOAT           reduce using rule 86 (break_stmt -> BREAK ; .)
    INT             reduce using rule 86 (break_stmt -> BREAK ; .)
    VOID            reduce using rule 86 (break_stmt -> BREAK ; .)
    SPRINTF         reduce using rule 86 (break_stmt -> BREAK ; .)
    PRINTF          reduce using rule 86 (break_stmt -> BREAK ; .)
    THIS            reduce using rule 86 (break_stmt -> BREAK ; .)
    FOR             reduce using rule 86 (break_stmt -> BREAK ; .)
    IDENT           reduce using rule 86 (break_stmt -> BREAK ; .)
    SUPER           reduce using rule 86 (break_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 86 (break_stmt -> BREAK ; .)
    BREAK           reduce using rule 86 (break_stmt -> BREAK ; .)
    WHILE           reduce using rule 86 (break_stmt -> BREAK ; .)
    RETURN          reduce using rule 86 (break_stmt -> BREAK ; .)
    IF              reduce using rule 86 (break_stmt -> BREAK ; .)
    {               reduce using rule 86 (break_stmt -> BREAK ; .)
    (               reduce using rule 86 (break_stmt -> BREAK ; .)
    NOT             reduce using rule 86 (break_stmt -> BREAK ; .)
    !               reduce using rule 86 (break_stmt -> BREAK ; .)
    -               reduce using rule 86 (break_stmt -> BREAK ; .)
    +               reduce using rule 86 (break_stmt -> BREAK ; .)
    DECREMENT       reduce using rule 86 (break_stmt -> BREAK ; .)
    INCREMENT       reduce using rule 86 (break_stmt -> BREAK ; .)
    FALSE           reduce using rule 86 (break_stmt -> BREAK ; .)
    TRUE            reduce using rule 86 (break_stmt -> BREAK ; .)
    STRINGLIT       reduce using rule 86 (break_stmt -> BREAK ; .)
    BOOLIT          reduce using rule 86 (break_stmt -> BREAK ; .)
    FLOATLIT        reduce using rule 86 (break_stmt -> BREAK ; .)
    INTLIT          reduce using rule 86 (break_stmt -> BREAK ; .)
    NULL            reduce using rule 86 (break_stmt -> BREAK ; .)
    ELSE            reduce using rule 86 (break_stmt -> BREAK ; .)


state 213

    (85) while_stmt -> WHILE ( . expr ) stmt
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 230
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 214

    (83) return_stmt -> RETURN expr . ;
    ;               shift and go to state 231


state 215

    (84) return_stmt -> RETURN ; .
    }               reduce using rule 84 (return_stmt -> RETURN ; .)
    STRING          reduce using rule 84 (return_stmt -> RETURN ; .)
    BOOL            reduce using rule 84 (return_stmt -> RETURN ; .)
    FLOAT           reduce using rule 84 (return_stmt -> RETURN ; .)
    INT             reduce using rule 84 (return_stmt -> RETURN ; .)
    VOID            reduce using rule 84 (return_stmt -> RETURN ; .)
    SPRINTF         reduce using rule 84 (return_stmt -> RETURN ; .)
    PRINTF          reduce using rule 84 (return_stmt -> RETURN ; .)
    THIS            reduce using rule 84 (return_stmt -> RETURN ; .)
    FOR             reduce using rule 84 (return_stmt -> RETURN ; .)
    IDENT           reduce using rule 84 (return_stmt -> RETURN ; .)
    SUPER           reduce using rule 84 (return_stmt -> RETURN ; .)
    CONTINUE        reduce using rule 84 (return_stmt -> RETURN ; .)
    BREAK           reduce using rule 84 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 84 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 84 (return_stmt -> RETURN ; .)
    IF              reduce using rule 84 (return_stmt -> RETURN ; .)
    {               reduce using rule 84 (return_stmt -> RETURN ; .)
    (               reduce using rule 84 (return_stmt -> RETURN ; .)
    NOT             reduce using rule 84 (return_stmt -> RETURN ; .)
    !               reduce using rule 84 (return_stmt -> RETURN ; .)
    -               reduce using rule 84 (return_stmt -> RETURN ; .)
    +               reduce using rule 84 (return_stmt -> RETURN ; .)
    DECREMENT       reduce using rule 84 (return_stmt -> RETURN ; .)
    INCREMENT       reduce using rule 84 (return_stmt -> RETURN ; .)
    FALSE           reduce using rule 84 (return_stmt -> RETURN ; .)
    TRUE            reduce using rule 84 (return_stmt -> RETURN ; .)
    STRINGLIT       reduce using rule 84 (return_stmt -> RETURN ; .)
    BOOLIT          reduce using rule 84 (return_stmt -> RETURN ; .)
    FLOATLIT        reduce using rule 84 (return_stmt -> RETURN ; .)
    INTLIT          reduce using rule 84 (return_stmt -> RETURN ; .)
    NULL            reduce using rule 84 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 84 (return_stmt -> RETURN ; .)


state 216

    (81) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (82) if_stmt -> IF ( . expr ) stmt
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 232
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 217

    (71) primary_expr -> IDENT . IDENT ( args_list . )
    (89) args_list -> args_list . , expr
    )               shift and go to state 233
    ,               shift and go to state 194


state 218

    (89) args_list -> args_list , expr .
    )               reduce using rule 89 (args_list -> args_list , expr .)
    ,               reduce using rule 89 (args_list -> args_list , expr .)


state 219

    (61) assignment_expr -> IDENT [ expr ] = . assignment_expr
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    IDENT           shift and go to state 70
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 72
    assignment_expr                shift and go to state 234
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 220

    (95) object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .
    IDENT           reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    CLASS           reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    STRING          reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    BOOL            reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    FLOAT           reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    INT             reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    VOID            reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    $end            reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    }               reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    SPRINTF         reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    PRINTF          reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    THIS            reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    FOR             reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    SUPER           reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    CONTINUE        reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    BREAK           reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    WHILE           reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    RETURN          reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    IF              reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    {               reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    (               reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    NOT             reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    !               reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    -               reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    +               reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    DECREMENT       reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    INCREMENT       reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    FALSE           reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    TRUE            reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    STRINGLIT       reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    BOOLIT          reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    FLOATLIT        reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    INTLIT          reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    NULL            reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)
    ELSE            reduce using rule 95 (object_decl -> IDENT IDENT = NEW IDENT ( args_list ) ; .)


state 221

    (18) method_decl -> type_spec IDENT ( param_list ) compound_stmt .
    PUBLIC          reduce using rule 18 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    PRIVATE         reduce using rule 18 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    IDENT           reduce using rule 18 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    STRING          reduce using rule 18 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    BOOL            reduce using rule 18 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    FLOAT           reduce using rule 18 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    INT             reduce using rule 18 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    VOID            reduce using rule 18 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)
    }               reduce using rule 18 (method_decl -> type_spec IDENT ( param_list ) compound_stmt .)


state 222

    (46) sprintf_stmt -> SPRINTF ( expr . , STRINGLIT ) ;
    (47) sprintf_stmt -> SPRINTF ( expr . , STRINGLIT , args_list ) ;
    ,               shift and go to state 235


state 223

    (44) printf_stmt -> PRINTF ( STRINGLIT . ) ;
    (45) printf_stmt -> PRINTF ( STRINGLIT . , args_list ) ;
    )               shift and go to state 236
    ,               shift and go to state 237


state 224

    (48) for_stmt -> FOR ( for_init . ; for_cond ; for_incr ) compound_stmt
    ;               shift and go to state 238


state 225

    (49) for_init -> empty .
    ;               reduce using rule 49 (for_init -> empty .)


state 226

    (50) for_init -> assignment_expr .
    ;               reduce using rule 50 (for_init -> assignment_expr .)


state 227

    (51) for_init -> var_decl_no_semi .
    ;               reduce using rule 51 (for_init -> var_decl_no_semi .)


state 228

    (52) var_decl_no_semi -> type_spec . IDENT [ expr ]
    (53) var_decl_no_semi -> type_spec . IDENT = assignment_expr
    (54) var_decl_no_semi -> type_spec . IDENT
    IDENT           shift and go to state 239


state 229

    (59) super_stmt -> SUPER ( args_list . ) ;
    (89) args_list -> args_list . , expr
    )               shift and go to state 240
    ,               shift and go to state 194


state 230

    (85) while_stmt -> WHILE ( expr . ) stmt
    )               shift and go to state 241


state 231

    (83) return_stmt -> RETURN expr ; .
    }               reduce using rule 83 (return_stmt -> RETURN expr ; .)
    STRING          reduce using rule 83 (return_stmt -> RETURN expr ; .)
    BOOL            reduce using rule 83 (return_stmt -> RETURN expr ; .)
    FLOAT           reduce using rule 83 (return_stmt -> RETURN expr ; .)
    INT             reduce using rule 83 (return_stmt -> RETURN expr ; .)
    VOID            reduce using rule 83 (return_stmt -> RETURN expr ; .)
    SPRINTF         reduce using rule 83 (return_stmt -> RETURN expr ; .)
    PRINTF          reduce using rule 83 (return_stmt -> RETURN expr ; .)
    THIS            reduce using rule 83 (return_stmt -> RETURN expr ; .)
    FOR             reduce using rule 83 (return_stmt -> RETURN expr ; .)
    IDENT           reduce using rule 83 (return_stmt -> RETURN expr ; .)
    SUPER           reduce using rule 83 (return_stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 83 (return_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 83 (return_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 83 (return_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 83 (return_stmt -> RETURN expr ; .)
    IF              reduce using rule 83 (return_stmt -> RETURN expr ; .)
    {               reduce using rule 83 (return_stmt -> RETURN expr ; .)
    (               reduce using rule 83 (return_stmt -> RETURN expr ; .)
    NOT             reduce using rule 83 (return_stmt -> RETURN expr ; .)
    !               reduce using rule 83 (return_stmt -> RETURN expr ; .)
    -               reduce using rule 83 (return_stmt -> RETURN expr ; .)
    +               reduce using rule 83 (return_stmt -> RETURN expr ; .)
    DECREMENT       reduce using rule 83 (return_stmt -> RETURN expr ; .)
    INCREMENT       reduce using rule 83 (return_stmt -> RETURN expr ; .)
    FALSE           reduce using rule 83 (return_stmt -> RETURN expr ; .)
    TRUE            reduce using rule 83 (return_stmt -> RETURN expr ; .)
    STRINGLIT       reduce using rule 83 (return_stmt -> RETURN expr ; .)
    BOOLIT          reduce using rule 83 (return_stmt -> RETURN expr ; .)
    FLOATLIT        reduce using rule 83 (return_stmt -> RETURN expr ; .)
    INTLIT          reduce using rule 83 (return_stmt -> RETURN expr ; .)
    NULL            reduce using rule 83 (return_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 83 (return_stmt -> RETURN expr ; .)


state 232

    (81) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (82) if_stmt -> IF ( expr . ) stmt
    )               shift and go to state 242


state 233

    (71) primary_expr -> IDENT . IDENT ( args_list ) .
    DECREMENT       reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    INCREMENT       reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    %               reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    /               reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    *               reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    -               reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    +               reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    GE              reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    GT              reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    LE              reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    LT              reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    NE              reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    EQ              reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    AND             reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    OR              reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    ]               reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    ;               reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    )               reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)
    ,               reduce using rule 71 (primary_expr -> IDENT . IDENT ( args_list ) .)


state 234

    (61) assignment_expr -> IDENT [ expr ] = assignment_expr .
    ;               reduce using rule 61 (assignment_expr -> IDENT [ expr ] = assignment_expr .)
    )               reduce using rule 61 (assignment_expr -> IDENT [ expr ] = assignment_expr .)


state 235

    (46) sprintf_stmt -> SPRINTF ( expr , . STRINGLIT ) ;
    (47) sprintf_stmt -> SPRINTF ( expr , . STRINGLIT , args_list ) ;
    STRINGLIT       shift and go to state 243


state 236

    (44) printf_stmt -> PRINTF ( STRINGLIT ) . ;
    ;               shift and go to state 244


state 237

    (45) printf_stmt -> PRINTF ( STRINGLIT , . args_list ) ;
    (88) args_list -> . expr
    (89) args_list -> . args_list , expr
    (90) args_list -> . empty
    (102) expr -> . logical_or_expr
    (133) empty -> .
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    )               reduce using rule 133 (empty -> .)
    ,               reduce using rule 133 (empty -> .)
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    args_list                      shift and go to state 245
    expr                           shift and go to state 132
    empty                          shift and go to state 133
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 238

    (48) for_stmt -> FOR ( for_init ; . for_cond ; for_incr ) compound_stmt
    (55) for_cond -> . empty
    (56) for_cond -> . expr
    (133) empty -> .
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    ;               reduce using rule 133 (empty -> .)
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    for_cond                       shift and go to state 246
    empty                          shift and go to state 247
    expr                           shift and go to state 248
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 239

    (52) var_decl_no_semi -> type_spec IDENT . [ expr ]
    (53) var_decl_no_semi -> type_spec IDENT . = assignment_expr
    (54) var_decl_no_semi -> type_spec IDENT .
    [               shift and go to state 249
    =               shift and go to state 250
    ;               reduce using rule 54 (var_decl_no_semi -> type_spec IDENT .)


state 240

    (59) super_stmt -> SUPER ( args_list ) . ;
    ;               shift and go to state 251


state 241

    (85) while_stmt -> WHILE ( expr ) . stmt
    (31) stmt -> . sprintf_stmt
    (32) stmt -> . printf_stmt
    (33) stmt -> . this_stmt
    (34) stmt -> . for_stmt
    (35) stmt -> . object_decl
    (36) stmt -> . super_stmt
    (37) stmt -> . continue_stmt
    (38) stmt -> . break_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . return_stmt
    (41) stmt -> . if_stmt
    (42) stmt -> . compound_stmt
    (43) stmt -> . expr_stmt
    (46) sprintf_stmt -> . SPRINTF ( expr , STRINGLIT ) ;
    (47) sprintf_stmt -> . SPRINTF ( expr , STRINGLIT , args_list ) ;
    (44) printf_stmt -> . PRINTF ( STRINGLIT ) ;
    (45) printf_stmt -> . PRINTF ( STRINGLIT , args_list ) ;
    (91) this_stmt -> . THIS ;
    (48) for_stmt -> . FOR ( for_init ; for_cond ; for_incr ) compound_stmt
    (95) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (96) object_decl -> . IDENT IDENT ;
    (59) super_stmt -> . SUPER ( args_list ) ;
    (87) continue_stmt -> . CONTINUE ;
    (86) break_stmt -> . BREAK ;
    (85) while_stmt -> . WHILE ( expr ) stmt
    (83) return_stmt -> . RETURN expr ;
    (84) return_stmt -> . RETURN ;
    (81) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (82) if_stmt -> . IF ( expr ) stmt
    (26) compound_stmt -> . { block_items }
    (60) expr_stmt -> . assignment_expr ;
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    SPRINTF         shift and go to state 181
    PRINTF          shift and go to state 182
    THIS            shift and go to state 183
    FOR             shift and go to state 184
    IDENT           shift and go to state 166
    SUPER           shift and go to state 185
    CONTINUE        shift and go to state 186
    BREAK           shift and go to state 187
    WHILE           shift and go to state 188
    RETURN          shift and go to state 189
    IF              shift and go to state 190
    {               shift and go to state 126
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 72
    stmt                           shift and go to state 252
    sprintf_stmt                   shift and go to state 168
    printf_stmt                    shift and go to state 169
    this_stmt                      shift and go to state 170
    for_stmt                       shift and go to state 171
    object_decl                    shift and go to state 172
    super_stmt                     shift and go to state 173
    continue_stmt                  shift and go to state 174
    break_stmt                     shift and go to state 175
    while_stmt                     shift and go to state 176
    return_stmt                    shift and go to state 177
    if_stmt                        shift and go to state 178
    compound_stmt                  shift and go to state 179
    expr_stmt                      shift and go to state 180
    assignment_expr                shift and go to state 167
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 242

    (81) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (82) if_stmt -> IF ( expr ) . stmt
    (31) stmt -> . sprintf_stmt
    (32) stmt -> . printf_stmt
    (33) stmt -> . this_stmt
    (34) stmt -> . for_stmt
    (35) stmt -> . object_decl
    (36) stmt -> . super_stmt
    (37) stmt -> . continue_stmt
    (38) stmt -> . break_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . return_stmt
    (41) stmt -> . if_stmt
    (42) stmt -> . compound_stmt
    (43) stmt -> . expr_stmt
    (46) sprintf_stmt -> . SPRINTF ( expr , STRINGLIT ) ;
    (47) sprintf_stmt -> . SPRINTF ( expr , STRINGLIT , args_list ) ;
    (44) printf_stmt -> . PRINTF ( STRINGLIT ) ;
    (45) printf_stmt -> . PRINTF ( STRINGLIT , args_list ) ;
    (91) this_stmt -> . THIS ;
    (48) for_stmt -> . FOR ( for_init ; for_cond ; for_incr ) compound_stmt
    (95) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (96) object_decl -> . IDENT IDENT ;
    (59) super_stmt -> . SUPER ( args_list ) ;
    (87) continue_stmt -> . CONTINUE ;
    (86) break_stmt -> . BREAK ;
    (85) while_stmt -> . WHILE ( expr ) stmt
    (83) return_stmt -> . RETURN expr ;
    (84) return_stmt -> . RETURN ;
    (81) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (82) if_stmt -> . IF ( expr ) stmt
    (26) compound_stmt -> . { block_items }
    (60) expr_stmt -> . assignment_expr ;
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    SPRINTF         shift and go to state 181
    PRINTF          shift and go to state 182
    THIS            shift and go to state 183
    FOR             shift and go to state 184
    IDENT           shift and go to state 166
    SUPER           shift and go to state 185
    CONTINUE        shift and go to state 186
    BREAK           shift and go to state 187
    WHILE           shift and go to state 188
    RETURN          shift and go to state 189
    IF              shift and go to state 190
    {               shift and go to state 126
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 72
    stmt                           shift and go to state 253
    sprintf_stmt                   shift and go to state 168
    printf_stmt                    shift and go to state 169
    this_stmt                      shift and go to state 170
    for_stmt                       shift and go to state 171
    object_decl                    shift and go to state 172
    super_stmt                     shift and go to state 173
    continue_stmt                  shift and go to state 174
    break_stmt                     shift and go to state 175
    while_stmt                     shift and go to state 176
    return_stmt                    shift and go to state 177
    if_stmt                        shift and go to state 178
    compound_stmt                  shift and go to state 179
    expr_stmt                      shift and go to state 180
    assignment_expr                shift and go to state 167
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 243

    (46) sprintf_stmt -> SPRINTF ( expr , STRINGLIT . ) ;
    (47) sprintf_stmt -> SPRINTF ( expr , STRINGLIT . , args_list ) ;
    )               shift and go to state 255
    ,               shift and go to state 254


state 244

    (44) printf_stmt -> PRINTF ( STRINGLIT ) ; .
    }               reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    STRING          reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    BOOL            reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    FLOAT           reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    INT             reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    VOID            reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    SPRINTF         reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    PRINTF          reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    THIS            reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    FOR             reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    IDENT           reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    SUPER           reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    CONTINUE        reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    BREAK           reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    WHILE           reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    RETURN          reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    IF              reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    {               reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    (               reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    NOT             reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    !               reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    -               reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    +               reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    DECREMENT       reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    INCREMENT       reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    FALSE           reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    TRUE            reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    STRINGLIT       reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    BOOLIT          reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    FLOATLIT        reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    INTLIT          reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    NULL            reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)
    ELSE            reduce using rule 44 (printf_stmt -> PRINTF ( STRINGLIT ) ; .)


state 245

    (45) printf_stmt -> PRINTF ( STRINGLIT , args_list . ) ;
    (89) args_list -> args_list . , expr
    )               shift and go to state 256
    ,               shift and go to state 194


state 246

    (48) for_stmt -> FOR ( for_init ; for_cond . ; for_incr ) compound_stmt
    ;               shift and go to state 257


state 247

    (55) for_cond -> empty .
    ;               reduce using rule 55 (for_cond -> empty .)


state 248

    (56) for_cond -> expr .
    ;               reduce using rule 56 (for_cond -> expr .)


state 249

    (52) var_decl_no_semi -> type_spec IDENT [ . expr ]
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 258
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 250

    (53) var_decl_no_semi -> type_spec IDENT = . assignment_expr
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    IDENT           shift and go to state 70
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    assignment_expr                shift and go to state 259
    expr                           shift and go to state 72
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 251

    (59) super_stmt -> SUPER ( args_list ) ; .
    }               reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    STRING          reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    BOOL            reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    FLOAT           reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    INT             reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    VOID            reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    SPRINTF         reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    PRINTF          reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    THIS            reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    FOR             reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    IDENT           reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    SUPER           reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    CONTINUE        reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    BREAK           reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    WHILE           reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    RETURN          reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    IF              reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    {               reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    (               reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    NOT             reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    !               reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    -               reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    +               reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    DECREMENT       reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    INCREMENT       reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    FALSE           reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    TRUE            reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    STRINGLIT       reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    BOOLIT          reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    FLOATLIT        reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    INTLIT          reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    NULL            reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)
    ELSE            reduce using rule 59 (super_stmt -> SUPER ( args_list ) ; .)


state 252

    (85) while_stmt -> WHILE ( expr ) stmt .
    }               reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    STRING          reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    BOOL            reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    FLOAT           reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    INT             reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    VOID            reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    SPRINTF         reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    PRINTF          reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    THIS            reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    IDENT           reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    SUPER           reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    NOT             reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    DECREMENT       reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    INCREMENT       reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    FALSE           reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    TRUE            reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    STRINGLIT       reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    BOOLIT          reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    FLOATLIT        reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    INTLIT          reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    NULL            reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 85 (while_stmt -> WHILE ( expr ) stmt .)


state 253

    (81) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (82) if_stmt -> IF ( expr ) stmt .
    ELSE            shift and go to state 260
    }               reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    STRING          reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    BOOL            reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    FLOAT           reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    INT             reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    VOID            reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    SPRINTF         reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    PRINTF          reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    THIS            reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    IDENT           reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    SUPER           reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    NOT             reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    DECREMENT       reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    INCREMENT       reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    FALSE           reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    TRUE            reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    STRINGLIT       reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    BOOLIT          reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    FLOATLIT        reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    INTLIT          reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)
    NULL            reduce using rule 82 (if_stmt -> IF ( expr ) stmt .)


state 254

    (47) sprintf_stmt -> SPRINTF ( expr , STRINGLIT , . args_list ) ;
    (88) args_list -> . expr
    (89) args_list -> . args_list , expr
    (90) args_list -> . empty
    (102) expr -> . logical_or_expr
    (133) empty -> .
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    )               reduce using rule 133 (empty -> .)
    ,               reduce using rule 133 (empty -> .)
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    IDENT           shift and go to state 45
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 132
    args_list                      shift and go to state 261
    empty                          shift and go to state 133
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 255

    (46) sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) . ;
    ;               shift and go to state 262


state 256

    (45) printf_stmt -> PRINTF ( STRINGLIT , args_list ) . ;
    ;               shift and go to state 263


state 257

    (48) for_stmt -> FOR ( for_init ; for_cond ; . for_incr ) compound_stmt
    (57) for_incr -> . empty
    (58) for_incr -> . assignment_expr
    (133) empty -> .
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    )               reduce using rule 133 (empty -> .)
    IDENT           shift and go to state 70
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    for_incr                       shift and go to state 264
    empty                          shift and go to state 265
    assignment_expr                shift and go to state 266
    expr                           shift and go to state 72
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 258

    (52) var_decl_no_semi -> type_spec IDENT [ expr . ]
    ]               shift and go to state 267


state 259

    (53) var_decl_no_semi -> type_spec IDENT = assignment_expr .
    ;               reduce using rule 53 (var_decl_no_semi -> type_spec IDENT = assignment_expr .)


state 260

    (81) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (31) stmt -> . sprintf_stmt
    (32) stmt -> . printf_stmt
    (33) stmt -> . this_stmt
    (34) stmt -> . for_stmt
    (35) stmt -> . object_decl
    (36) stmt -> . super_stmt
    (37) stmt -> . continue_stmt
    (38) stmt -> . break_stmt
    (39) stmt -> . while_stmt
    (40) stmt -> . return_stmt
    (41) stmt -> . if_stmt
    (42) stmt -> . compound_stmt
    (43) stmt -> . expr_stmt
    (46) sprintf_stmt -> . SPRINTF ( expr , STRINGLIT ) ;
    (47) sprintf_stmt -> . SPRINTF ( expr , STRINGLIT , args_list ) ;
    (44) printf_stmt -> . PRINTF ( STRINGLIT ) ;
    (45) printf_stmt -> . PRINTF ( STRINGLIT , args_list ) ;
    (91) this_stmt -> . THIS ;
    (48) for_stmt -> . FOR ( for_init ; for_cond ; for_incr ) compound_stmt
    (95) object_decl -> . IDENT IDENT = NEW IDENT ( args_list ) ;
    (96) object_decl -> . IDENT IDENT ;
    (59) super_stmt -> . SUPER ( args_list ) ;
    (87) continue_stmt -> . CONTINUE ;
    (86) break_stmt -> . BREAK ;
    (85) while_stmt -> . WHILE ( expr ) stmt
    (83) return_stmt -> . RETURN expr ;
    (84) return_stmt -> . RETURN ;
    (81) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (82) if_stmt -> . IF ( expr ) stmt
    (26) compound_stmt -> . { block_items }
    (60) expr_stmt -> . assignment_expr ;
    (61) assignment_expr -> . IDENT [ expr ] = assignment_expr
    (62) assignment_expr -> . expr
    (63) assignment_expr -> . IDENT DIV_ASSIGN assignment_expr
    (64) assignment_expr -> . IDENT MULT_ASSIGN assignment_expr
    (65) assignment_expr -> . IDENT MINUS_ASSIGN assignment_expr
    (66) assignment_expr -> . IDENT PLUS_ASSIGN assignment_expr
    (67) assignment_expr -> . IDENT = assignment_expr
    (102) expr -> . logical_or_expr
    (103) logical_or_expr -> . logical_and_expr
    (104) logical_or_expr -> . logical_or_expr OR logical_and_expr
    (105) logical_and_expr -> . equality_expr
    (106) logical_and_expr -> . logical_and_expr AND equality_expr
    (107) equality_expr -> . relational_expr
    (108) equality_expr -> . equality_expr NE relational_expr
    (109) equality_expr -> . equality_expr EQ relational_expr
    (110) relational_expr -> . additive_expr
    (111) relational_expr -> . relational_expr GE additive_expr
    (112) relational_expr -> . relational_expr GT additive_expr
    (113) relational_expr -> . relational_expr LE additive_expr
    (114) relational_expr -> . relational_expr LT additive_expr
    (115) additive_expr -> . multiplicative_expr
    (116) additive_expr -> . additive_expr - multiplicative_expr
    (117) additive_expr -> . additive_expr + multiplicative_expr
    (118) multiplicative_expr -> . unary_expr
    (119) multiplicative_expr -> . multiplicative_expr % unary_expr
    (120) multiplicative_expr -> . multiplicative_expr / unary_expr
    (121) multiplicative_expr -> . multiplicative_expr * unary_expr
    (122) unary_expr -> . ( type_spec ) unary_expr
    (123) unary_expr -> . postfix_expr
    (124) unary_expr -> . NOT unary_expr
    (125) unary_expr -> . ! unary_expr
    (126) unary_expr -> . - unary_expr
    (127) unary_expr -> . + unary_expr
    (128) unary_expr -> . DECREMENT unary_expr
    (129) unary_expr -> . INCREMENT unary_expr
    (130) postfix_expr -> . primary_expr
    (131) postfix_expr -> . postfix_expr DECREMENT
    (132) postfix_expr -> . postfix_expr INCREMENT
    (68) primary_expr -> . IDENT . SIZE
    (69) primary_expr -> . IDENT
    (70) primary_expr -> . IDENT [ expr ]
    (71) primary_expr -> . IDENT . IDENT ( args_list )
    (72) primary_expr -> . IDENT ( args_list )
    (73) primary_expr -> . FALSE
    (74) primary_expr -> . TRUE
    (75) primary_expr -> . STRINGLIT
    (76) primary_expr -> . BOOLIT
    (77) primary_expr -> . FLOATLIT
    (78) primary_expr -> . INTLIT
    (79) primary_expr -> . ( expr )
    (80) primary_expr -> . NULL
    SPRINTF         shift and go to state 181
    PRINTF          shift and go to state 182
    THIS            shift and go to state 183
    FOR             shift and go to state 184
    IDENT           shift and go to state 166
    SUPER           shift and go to state 185
    CONTINUE        shift and go to state 186
    BREAK           shift and go to state 187
    WHILE           shift and go to state 188
    RETURN          shift and go to state 189
    IF              shift and go to state 190
    {               shift and go to state 126
    (               shift and go to state 56
    NOT             shift and go to state 58
    !               shift and go to state 59
    -               shift and go to state 53
    +               shift and go to state 54
    DECREMENT       shift and go to state 60
    INCREMENT       shift and go to state 61
    FALSE           shift and go to state 63
    TRUE            shift and go to state 64
    STRINGLIT       shift and go to state 65
    BOOLIT          shift and go to state 66
    FLOATLIT        shift and go to state 67
    INTLIT          shift and go to state 68
    NULL            shift and go to state 69

    expr                           shift and go to state 72
    stmt                           shift and go to state 268
    sprintf_stmt                   shift and go to state 168
    printf_stmt                    shift and go to state 169
    this_stmt                      shift and go to state 170
    for_stmt                       shift and go to state 171
    object_decl                    shift and go to state 172
    super_stmt                     shift and go to state 173
    continue_stmt                  shift and go to state 174
    break_stmt                     shift and go to state 175
    while_stmt                     shift and go to state 176
    return_stmt                    shift and go to state 177
    if_stmt                        shift and go to state 178
    compound_stmt                  shift and go to state 179
    expr_stmt                      shift and go to state 180
    assignment_expr                shift and go to state 167
    logical_or_expr                shift and go to state 47
    logical_and_expr               shift and go to state 48
    equality_expr                  shift and go to state 49
    relational_expr                shift and go to state 50
    additive_expr                  shift and go to state 51
    multiplicative_expr            shift and go to state 52
    unary_expr                     shift and go to state 55
    postfix_expr                   shift and go to state 57
    primary_expr                   shift and go to state 62

state 261

    (47) sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list . ) ;
    (89) args_list -> args_list . , expr
    )               shift and go to state 269
    ,               shift and go to state 194


state 262

    (46) sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .
    }               reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    STRING          reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    BOOL            reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    FLOAT           reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    INT             reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    VOID            reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    SPRINTF         reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    PRINTF          reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    THIS            reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    FOR             reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    IDENT           reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    SUPER           reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    CONTINUE        reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    BREAK           reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    WHILE           reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    RETURN          reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    IF              reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    {               reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    (               reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    NOT             reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    !               reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    -               reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    +               reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    DECREMENT       reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    INCREMENT       reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    FALSE           reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    TRUE            reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    STRINGLIT       reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    BOOLIT          reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    FLOATLIT        reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    INTLIT          reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    NULL            reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)
    ELSE            reduce using rule 46 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT ) ; .)


state 263

    (45) printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .
    }               reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    STRING          reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    BOOL            reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    FLOAT           reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    INT             reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    VOID            reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    SPRINTF         reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    PRINTF          reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    THIS            reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    FOR             reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    IDENT           reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    SUPER           reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    CONTINUE        reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    BREAK           reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    WHILE           reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    RETURN          reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    IF              reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    {               reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    (               reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    NOT             reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    !               reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    -               reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    +               reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    DECREMENT       reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    INCREMENT       reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    FALSE           reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    TRUE            reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    STRINGLIT       reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    BOOLIT          reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    FLOATLIT        reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    INTLIT          reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    NULL            reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)
    ELSE            reduce using rule 45 (printf_stmt -> PRINTF ( STRINGLIT , args_list ) ; .)


state 264

    (48) for_stmt -> FOR ( for_init ; for_cond ; for_incr . ) compound_stmt
    )               shift and go to state 270


state 265

    (57) for_incr -> empty .
    )               reduce using rule 57 (for_incr -> empty .)


state 266

    (58) for_incr -> assignment_expr .
    )               reduce using rule 58 (for_incr -> assignment_expr .)


state 267

    (52) var_decl_no_semi -> type_spec IDENT [ expr ] .
    ;               reduce using rule 52 (var_decl_no_semi -> type_spec IDENT [ expr ] .)


state 268

    (81) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING          reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL            reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT           reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT             reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    VOID            reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SPRINTF         reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINTF          reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    THIS            reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENT           reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SUPER           reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NOT             reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    DECREMENT       reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INCREMENT       reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FALSE           reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    TRUE            reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRINGLIT       reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOLIT          reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOATLIT        reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INTLIT          reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NULL            reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 81 (if_stmt -> IF ( expr ) stmt ELSE stmt .)


state 269

    (47) sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) . ;
    ;               shift and go to state 271


state 270

    (48) for_stmt -> FOR ( for_init ; for_cond ; for_incr ) . compound_stmt
    (26) compound_stmt -> . { block_items }
    {               shift and go to state 126

    compound_stmt                  shift and go to state 272

state 271

    (47) sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .
    }               reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    STRING          reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    BOOL            reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    FLOAT           reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    INT             reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    VOID            reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    SPRINTF         reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    PRINTF          reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    THIS            reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    FOR             reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    IDENT           reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    SUPER           reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    CONTINUE        reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    BREAK           reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    WHILE           reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    RETURN          reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    IF              reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    {               reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    (               reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    NOT             reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    !               reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    -               reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    +               reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    DECREMENT       reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    INCREMENT       reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    FALSE           reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    TRUE            reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    STRINGLIT       reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    BOOLIT          reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    FLOATLIT        reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    INTLIT          reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    NULL            reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)
    ELSE            reduce using rule 47 (sprintf_stmt -> SPRINTF ( expr , STRINGLIT , args_list ) ; .)


state 272

    (48) for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .
    }               reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    STRING          reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    BOOL            reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    FLOAT           reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    INT             reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    VOID            reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    SPRINTF         reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    PRINTF          reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    THIS            reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    FOR             reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    IDENT           reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    SUPER           reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    CONTINUE        reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    BREAK           reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    WHILE           reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    RETURN          reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    IF              reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    {               reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    (               reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    NOT             reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    !               reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    -               reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    +               reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    DECREMENT       reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    INCREMENT       reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    FALSE           reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    TRUE            reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    STRINGLIT       reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    BOOLIT          reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    FLOATLIT        reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    INTLIT          reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    NULL            reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
    ELSE            reduce using rule 48 (for_stmt -> FOR ( for_init ; for_cond ; for_incr ) compound_stmt .)
